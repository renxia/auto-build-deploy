<!doctype html><html lang=zh-Hans dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-0.12.0 docs-doc-page docs-doc-id-reference/langref/relay_expr" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.7.0"><title data-rh=true>Expressions in Relay | Apache TVM 中文站</title><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_expr><meta data-rh=true property=og:locale content=zh_Hans><meta data-rh=true name=docusaurus_locale content=zh-Hans><meta data-rh=true name=docsearch:language content=zh-Hans><meta data-rh=true name=docusaurus_version content=0.12.0><meta data-rh=true name=docusaurus_tag content=docs-default-0.12.0><meta data-rh=true name=docsearch:version content=0.12.0><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-0.12.0><meta data-rh=true property=og:title content="Expressions in Relay | Apache TVM 中文站"><meta data-rh=true name=description content="The Relay IR is a pure, expression-oriented language. The below sections"><meta data-rh=true property=og:description content="The Relay IR is a pure, expression-oriented language. The below sections"><link data-rh=true rel=icon href=/docs/tvm-cn/img/favicon.png><link data-rh=true rel=canonical href=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_expr><link data-rh=true rel=alternate href=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_expr hreflang=zh-Hans><link data-rh=true rel=alternate href=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_expr hreflang=x-default><link data-rh=true rel=preconnect href=https://KU6TD2KAGA-dsn.algolia.net crossorigin=anonymous><link rel=preconnect href=https://www.google-analytics.com><link rel=preconnect href=https://www.googletagmanager.com><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-TVRNTQWL"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-TVRNTQWL",{})</script><link rel=search type=application/opensearchdescription+xml title="Apache TVM 中文站" href=/docs/tvm-cn/opensearch.xml><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css type=text/css integrity=sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM crossorigin=anonymous><script src=https://lzw.me/x/lib/utils/h5-common.js defer data-domain=lzw.me></script><link rel=stylesheet href=/docs/tvm-cn/assets/css/styles.d660bc20.css><script src=/docs/tvm-cn/assets/js/runtime~main.412de774.js defer></script><script src=/docs/tvm-cn/assets/js/main.60e49e7b.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":(window.matchMedia("(prefers-color-scheme: light)").matches,"light"),document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><link rel=preload as=image href=/docs/tvm-cn/img/favicon-dark.svg><link rel=preload as=image href=/docs/tvm-cn/img/favicon.svg><div role=region aria-label=跳到主要内容><a class=skipToContent_ZYxR href=#__docusaurus_skipToContent_fallback>跳到主要内容</a></div><nav aria-label=主导航 class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label=切换导航栏 aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/docs/tvm-cn/><div class=navbar__logo><img src=/docs/tvm-cn/img/favicon-dark.svg alt="TVM Logo" class="themedComponent_PKz1 themedComponent--light_TYnW"><img src=/docs/tvm-cn/img/favicon.svg alt="TVM Logo" class="themedComponent_PKz1 themedComponent--dark_RKZm"></div><b class="navbar__title text--truncate">TVM 中文站</b></a><a class="navbar__item navbar__link" href=/docs/tvm-cn/docs/0.12.0/>查看文档</a><a class="navbar__item navbar__link" href=/docs/tvm-cn/about>关于</a><a href=https://tool.lzw.me target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">有趣工具箱<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a><a href=https://lzw.me/x/reference/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">IT速查清单<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a></div><div class="navbar__items navbar__items--right"><a href=https://github.com/hyperai/tvm-cn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class=navbar__link aria-haspopup=true aria-expanded=false role=button href=/docs/tvm-cn/docs/0.12.0/reference/langref/relay_expr>0.12.0</a><ul class=dropdown__menu><li><a class=dropdown__link href=/docs/tvm-cn/docs/reference/langref/relay_expr>0.13.0</a><li><a aria-current=page class="dropdown__link dropdown__link--active" href=/docs/tvm-cn/docs/0.12.0/reference/langref/relay_expr>0.12.0</a><li><a class=dropdown__link href=/docs/tvm-cn/docs/0.10.0/reference/langref/relay_expr>0.10.0</a></ul></div><div class="toggle_azEg colorModeToggle_ACQd"><button class="clean-btn toggleButton_rDEP toggleButtonDisabled_BTpm" type=button disabled title=切换浅色/暗黑模式（当前为浅色模式） aria-label=切换浅色/暗黑模式（当前为浅色模式） aria-live=polite aria-pressed=false><svg viewBox="0 0 24 24" width=24 height=24 class=lightToggleIcon_FWei><path fill=currentColor d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 class=darkToggleIcon_OH98><path fill=currentColor d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/></svg></button></div><div class=navbarSearchContainer_CQDF><button type=button class="DocSearch DocSearch-Button" aria-label="搜索 (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>搜索</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_YyXw"><div class=docsWrapper_QpQH><button aria-label=回到顶部 class="clean-btn theme-back-to-top-button backToTopButton_J2hp" type=button></button><div class=docRoot_e4fL><main class="docMainContainer_ch7h docMainContainerEnhanced_gMK8"><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol__o6A"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role=alert><div>此为 <!-- -->Apache TVM 中文站<!-- --> <b>0.12.0</b> 版的文档，现已不再积极维护。</div><div class=margin-top--md>最新的文档请参阅 <b><a href=/docs/tvm-cn/docs/reference/langref/relay_expr>最新版本</a></b> (<!-- -->0.13.0<!-- -->)。</div></div><div class=docItemContainer_Wtch><article><span class="theme-doc-version-badge badge badge--secondary">版本：0.12.0</span><div class="tocCollapsible_hZNL theme-doc-toc-mobile tocMobile_UGcD"><button type=button class="clean-btn tocCollapsibleButton_z7oa">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Expressions in Relay</h1></header><p>The Relay IR is a pure, expression-oriented language. The below sections
describe the different expressions in Relay and give details of their
semantics.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=dataflow-and-control-fragments>Dataflow and Control Fragments<a href=#dataflow-and-control-fragments class=hash-link aria-label="Dataflow and Control Fragments的直接链接" title="Dataflow and Control Fragments的直接链接">​</a></h2>
<p>For the purposes of comparing Relay to traditional computational
graph-based IRs, it can be useful to consider Relay expressions in terms
of dataflow and control fragments. Each portion of a Relay program
containing expressions that only affect the dataflow can be viewed as a
traditional computation graph when writing and expressing
transformations.</p>
<p>The dataflow fragment covers the set of Relay expressions that do not
involve control flow. That is, any portion of a program containing only
the following constructs corresponds to a pure computation graph:</p>
<ul>
<li><a href=#variables>Variables</a></li>
<li>Tuple <a href=#construction>Construction</a> and <a href=#projection>Projection</a></li>
<li><a href=#let-bindings>Let Bindings</a></li>
<li><a href=#graph-bindings>Graph Bindings</a></li>
<li>Calls to <a href=#operators>Operators</a> and <a href=#adt-constructors>ADT
Constructors</a></li>
</ul>
<p>Control flow expressions allow the graph topology to change based on the
value of previously executed expressions. The control fragment in Relay
includes the following constructs:</p>
<ul>
<li><a href=#if-then-else>If-Then-Else</a> Expressions</li>
<li><a href=#adt-matching>ADT Matching</a> Expressions</li>
<li>Recursive Calls in Functions</li>
</ul>
<p>From the point of view of a computation graph, a function is a subgraph
and a function call inlines the subgraph, substituting its arguments for
the free variables in the subgraph with corresponding names. Thus, if a
function's body uses only dataflow constructs, a call to that function
is in the dataflow fragment; conversely, if the function's body
contains control flow, a call to that function is not part of the
dataflow fragment.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=variables>Variables<a href=#variables class=hash-link aria-label=Variables的直接链接 title=Variables的直接链接>​</a></h2>
<p>Inspired by LLVM, Relay explicitly distinguishes between local and
global variables both in the AST and in the text format. In the text
format, global and local variables are distinguished by prefixes, or
<em>sigils</em>. Global variables are prefixed with <code>@</code> and local variables
with <code>%</code>.</p>
<p>This explicit distinction makes certain optimizations easier to
implement. For example, inlining a global definition requires no
analysis: simply substituting the definition suffices.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=global-variable>Global Variable<a href=#global-variable class=hash-link aria-label="Global Variable的直接链接" title="Global Variable的直接链接">​</a></h3>
<p>Global identifiers are prefixed by the <code>@</code> sigil, such as "<code>@global</code>".
A global identifier always references a globally visible definition
contained in the globally visible environment, known as the
<a href=#module-and-global-functions>module</a>. Global identifiers must be
unique.</p>
<p>See <code>GlobalVar</code> for
its implementation and documentation.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=local-variable>Local Variable<a href=#local-variable class=hash-link aria-label="Local Variable的直接链接" title="Local Variable的直接链接">​</a></h3>
<p>Local identifiers are prefixed by the <code>%</code> sigil, such as "<code>%local</code>". A
local identifier always references a function argument or a variable
bound in a <code>let</code> expression, and will be scoped to the function where it
appears or the <code>let</code> expression where it is bound, respectively.</p>
<p>In the below code segment, notice that <code>%a</code> is defined twice. This is
permitted, as in most functional languages; in the scope of the second
<code>let</code> expression, the name <code>%a</code> is "shadowed," meaning all references
to <code>%a</code> in the inner scope refer to the later definition, while
references to <code>%a</code> in the outer scope continue to refer to the first
one.</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %a = 1;</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %b = 2 * %a;  // %b = 2</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %a = %a + %a; // %a = 2. %a is shadowed</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%a + %b           // has value 2 + 2 = 4</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>(Note that in Relay's implementation, each definition of a local
variable creates a new <code>Var</code>, so a shadowed local variable, despite having the same
name as one in an outer scope, will be a different object. This allows
for comparing local variables by pointer identity with the knowledge
that the same local variable object corresponds to a different binding
site.)</p>
<p>See <code>Var</code> for its
implementation and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=functions>Functions<a href=#functions class=hash-link aria-label=Functions的直接链接 title=Functions的直接链接>​</a></h2>
<p>Functions in Relay act similarly to procedures or functions in other
programming languages and serve to generalize the concept of a named
subgraph.</p>
<p>Functions are first class in Relay, which means they are expressions
just like variables, constants, and tuples. Additionally, functions in
Relay are higher-order, which means that a function can be passed as an
argument to a function or returned by a function, as function
expressions evaluate to closures (see the <a href=#closures>Closures</a>
subsection), which are values like tensors and tuples.</p>
<p>See <code>Function</code>
for the definition and documentation of function nodes.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=syntax>Syntax<a href=#syntax class=hash-link aria-label=Syntax的直接链接 title=Syntax的直接链接>​</a></h3>
<p>A definition minimally consists of the keyword <code>fn</code>, an empty set of
parameters, and a body expression
(<code>Expr</code>) contained by
curly braces.</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn() { body }</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>A definition may contain any number of parameters. For example, a simple
function that invokes the <code>add</code> operator:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%x, %y) { add(%x, %y) }</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Notice that within the function's body, the parameters are local
variables, just like those bound in a <code>let</code> expression.</p>
<p>One may also annotate explicit types on functions. For example, we can
restrict the above function to only work on certain types:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%x : Tensor[(10, 10), float32], %y : Tensor[(10, 10), float32])</span><br></span><span class=token-line style=color:#393A34><span class="token plain">           -> Tensor[(10, 10), float32] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    add(%x, %y)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The above function only takes arguments of type
<code>Tensor[(10, 10), float32]</code> and returns a value of type
<code>Tensor[(10, 10), float32]</code>. A function parameter is just a local
variable (<code>LocalVar</code>)
optionally annotated with a type, written as <code>%x : T</code>.</p>
<p>When the type information is omitted, Relay attempts to infer the most
general type for the users. This property is known as generalization:
for a definition without explicit annotations, Relay attempts to assign
the most general type to the parameters and return type based on the
function body and call sites.</p>
<p>A recursive function expression can be defined using a <code>let</code> binding, as
here:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %fact = fn(%x : Tensor[(10, 10), float32]) -> Tensor[(10, 10), float32] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    if (%x == Constant(0, (10, 10), float32)) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        Constant(1, (10, 10), float32)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    } else {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        %x * %fact(%x - Constant(1, (10, 10), float32))</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">};</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%fact(Constant(10, (10, 10), float32))</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=closures>Closures<a href=#closures class=hash-link aria-label=Closures的直接链接 title=Closures的直接链接>​</a></h3>
<p>A function expression evaluates to a closure. Closures are values that
are represented as a pair of a local environment (storing the values for
all variables defined outside the scope of the function's body) and the
function itself.</p>
<p>For example, in the below example, the final result will be a tensor of
zero values because the closure for <code>%f</code> stores the value of <code>%x</code> at the
pointer where <code>%f</code> was defined.</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %g = fn() {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %x = Constant(0, (10, 10), float32);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  // %x is a free variable in the below function</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  fn(%y) { %y * %x }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">};</span><br></span><span class=token-line style=color:#393A34><span class="token plain">// the %x in %g's body is not in scope anymore</span><br></span><span class=token-line style=color:#393A34><span class="token plain">// %f is a closure where %x maps to Constant(0, (10, 10), float32)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %f = %g();</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %x = Constant(1, (10, 10), float32);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%f(%x) // evaluates to Constant(0, (10, 10), float32)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=polymorphism-and-type-relations>Polymorphism and Type Relations<a href=#polymorphism-and-type-relations class=hash-link aria-label="Polymorphism and Type Relations的直接链接" title="Polymorphism and Type Relations的直接链接">​</a></h3>
<p><em>Note: type parameter syntax is not yet supported in the text format.</em></p>
<p>A function may also be given a set of type parameters, which can be
substituted for specific types at call sites. Functions with type
parameters are <em>type polymorphic</em>; their return type or the types of
arguments they will accept can vary based on the type arguments given at
call sites.</p>
<p>Type parameters are classified by <em>kind</em> and can only appear in parts of
the type signature where their kind is appropriate (e.g., type
parameters of kind <code>Shape</code> can only appear where a shape would be
expected in a tensor type); for a full discussion, see
<code>the documentation on type parameters &lt;type-parameter></code>.</p>
<p>For example, one can define a polymorphic identity function for any
Relay type as follows:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn&lt;t : Type>(%x : t) -> t {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    %x</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The below definition is also polymorphic, but restricts its arguments to
tensor types:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn&lt;s : Shape, bt : BaseType>(%x : Tensor[s, bt]) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    %x</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Notice that the return type is omitted and will be inferred.</p>
<p><em>Note: "where" syntax is not yet supported in the text format.</em></p>
<p>A function may also be subject to one or more type relations, such as in
the following:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%x, %y) where Broadcast { add(%x, %y) }</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>In the above definition, the types of <code>%x</code> and <code>%y</code> and the return type
are subject to the <code>Broadcast</code> relation, meaning all three must be
tensors and their shapes follow the elementwise broadcast relation. As
with operators, the definitions of relations are not transparent to
Relay and they are instead implemented externally in either C++ or
Python.</p>
<p>As in the case of <code>Broadcast</code>, relations are used to express complicated
constraints on types (especially tensor shapes). All function relations
must hold at all call sites; type checking is thus treated as a
constraint-solving problem. For more detail on type relations and their
implementations, please see
<code>their section in the documentation on Relay's type system &lt;type-relation></code>.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=operators>Operators<a href=#operators class=hash-link aria-label=Operators的直接链接 title=Operators的直接链接>​</a></h2>
<p>An operator is a primitive operation, such as <code>add</code> or <code>conv2d</code>, not
defined in the Relay language. Operators are declared in the global
operator registry in C++. Many common operators are backed by TVM's
Tensor Operator Inventory.</p>
<p>To register an operator a user must provide an implementation of the
operator, its type, and any other desired metadata. The operator
registry is a column-based store where operators are keys, so any
metadata (which might be referenced by optimization passes) may be
registered as a new column.</p>
<p>From the perspective of Relay's type system, an operator is a function,
so operators may be called like any other function and have function
types. In particular, operator types are registered using a single type
relation (see
<code>the documentation on type relations &lt;type-relation></code>, typically a relation specialized to that operator. For
example, the <code>add</code> operator is registered with the <code>Broadcast</code> relation,
indicating that the arguments of <code>add</code> must be tensors and that the
return type is a tensor whose shape depends on those of its arguments.</p>
<p>Operators are rendered without a sigil (e.g <code>conv2d</code>, <code>flatten</code>) when
pretty-printing Relay programs. Operators are explicitly contained in
the program and are uniquely identifiable by pointer.</p>
<p>Note that common arithmetic operators such as <code>add</code> and <code>multiply</code> may
be written using the corresponding arithmetic operators in the text
format (e.g., <code>+</code> or <code>*</code>) as syntactic sugar.</p>
<p>See <code>Op</code> for the
definition and documentation of operator nodes, demonstrating the
infrastructure for registering operator metadata. The other files in
<code>op</code> give handles for
generating a call to various pre-registered operators. The
<code>tutorial on adding operators to Relay &lt;relay-add-op></code> shows how to add further operators into the language.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=adt-constructors>ADT Constructors<a href=#adt-constructors class=hash-link aria-label="ADT Constructors的直接链接" title="ADT Constructors的直接链接">​</a></h2>
<p>Algebraic data types (ADTs) in Relay are described in detail in a
<code>separate overview&lt;adt-overview></code> and
their integration into the type system is described
<code>here&lt;adt-typing></code>.</p>
<p>In this section, we will simply note that ADT constructors are given a
function type and should be used inside call nodes like a function or
operator. An ADT constructor is defined by giving the name of the ADT it
constructs (a global type variable) and the types of the expected
arguments for the constructor.</p>
<p>If the ADT definition includes type variables, those type variables may
appear in the constructor. Constructors cannot include any other type
variables.</p>
<p>Let us suppose that <code>D</code> is an ADT that takes type parameters <code>a</code> and
<code>b</code>. If <code>C1</code> is a constructor for <code>D</code> and expects two arguments, one of
type <code>a</code> and one of type <code>b</code>, then <code>C1</code> has the following type
signature: <code>fun&lt;a, b>(a, b) -> D[a, b]</code>. (See either the ADT overview or
the discussion of ADT typing for an explanation of the type call in the
return type.) If another constructor for <code>D</code>, <code>C2</code>, takes no arguments,
then it has the following type signature: <code>fun&lt;a, b>() -> D[a, b]</code>; the
type parameters will always appear in the return type.</p>
<p>Once called, a constructor produces an ADT instance, which is a
container that stores the values of the arguments to the constructor as
well as the name ("tag") of the constructor. The tag will be used for
deconstructing the instances and retrieving the values when <a href=#adt-matching>ADT
Matching</a>.</p>
<p>See <code>Constructor</code> for
the definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=call>Call<a href=#call class=hash-link aria-label=Call的直接链接 title=Call的直接链接>​</a></h2>
<p>Expressions with function types in Relay are "callable," meaning that
they can be invoked via a function call. These consist of any expression
that evaluates to a closure (i.e., function expressions or global
functions) and Relay operators.</p>
<p>The syntax of calls follows that used in C-like languages, demonstrated
in the example below:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %c = 1;</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %f = fn(%x : Tensor[(), float32], %y : Tensor[(), float32]) { %x + %y + %c };</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%f(10, 11)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>When a closure is called (see <a href=#closures>Closures</a>), the closure's
body is evaluated in the stored environment (i.e., using the stored
values for free variables) with local variable bindings added for each
argument; the final value obtained by evaluating the body is the call's
return value. Thus, in the above example, the call evaluates to 22. In
the case of operators, the implementation is opaque to Relay, so the
result is left up to the registered TVM implementation.</p>
<p><em>Note: type parameters are not yet supported in the text format.</em></p>
<p>A type-polymorphic function can also include type arguments at a call
site. The type arguments are substituted for type parameters when type
checking. If a function is type-polymorphic and type arguments are not
given, type inference will attempt to infer type arguments if possible.
The following code gives examples of explicit and inferred type
arguments:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">// %f : fn&lt;a : Type, b : Type, c : Type>(a, b) -> c</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %x1 = %f&lt;Tensor[(), bool], Tensor[(), bool], Tensor[(), bool)]>(True, False);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">// %x1 is of type Tensor[(), bool]</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %x2 : () = %f(%x1, %x1)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">// the type arguments in the second call are inferred to be &lt;Tensor[(), bool], Tensor[(), bool], ()></span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Note that all type relations in the function type must hold at each call
site. Specifically, this means that the relation will be checked against
the specific types of the arguments at a given call site. This is also a
form of polymorphism, since there may be multiple valid assignments of
argument types and a return type so long as the relation is satisfied.</p>
<p>For example, if we have a function <code>%f</code> that takes tensor arguments and
has the <code>Broadcast</code> relation, then there are many different shapes that
the arguments in the below call could have that would satisfy the type
annotation:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %x : Tensor[(100, 100, 100), float32] = %f(%a, %b);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%x</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>Call</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=module-and-global-functions>Module and Global Functions<a href=#module-and-global-functions class=hash-link aria-label="Module and Global Functions的直接链接" title="Module and Global Functions的直接链接">​</a></h2>
<p>Relay keeps a global data structure known as a "module" (often called
an "environment" in other functional programming languages) to keep
track of the definitions of global functions. In particular, the module
keeps a globally accessible mapping of global variables to the function
expressions they denote. The utility of the module is that it allows
global functions to recursively refer to themselves or any other global
function (e.g., as in mutual recursion).</p>
<p>Note Relay's module is analogous to data structures for keeping track
of subgraphs in computation graph-based IRs.</p>
<p>Global functions in Relay behave identically to the function expressions
defined in <a href=#functions>Functions</a>, but have syntactic sugar in the text
format to enter their definitions into the module. Namely, a global
function definition includes a global identifier and is allowed to
recursively refer to that identifier in the body, as in the following
example:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @ackermann(%m : Tensor[(), int32], %n : Tensor[(), int32]) -> Tensor[(), int32] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    if (%m == 0) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        %n + 1</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    } else if (%m > 0 && %n == 0) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        @ackermann(%m - 1, 1)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    } else {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        @ackermann(%m - 1, @ackermann(%m, %n - 1))</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>This definition would result in a module entry mapping the identifier
<code>@ackermann</code> to a function expression with the parameters, return type,
and body above. Any reference to the identifier <code>@ackermann</code> elsewhere
in the code could then look up the identifier in the module and replace
the function definition as needed.</p>
<p>See <code>IRModule</code> for the
definition and documentation of a module.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=constant>Constant<a href=#constant class=hash-link aria-label=Constant的直接链接 title=Constant的直接链接>​</a></h2>
<p>This node represents a constant tensor value (see
<code>Value</code> for more details). A
constant is represented as a <code>NDArray</code>, allowing Relay to utilize TVM operators for constant
evaluation.</p>
<p>This node can also represent scalar constants, since scalars are tensors
with a shape of <code>()</code>. In the text format, numerical and boolean literals
are thus syntactic sugar for constants encoding a tensor type with a
rank-zero shape.</p>
<p>See <code>Constant</code> for
its definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=tuples>Tuples<a href=#tuples class=hash-link aria-label=Tuples的直接链接 title=Tuples的直接链接>​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=construction>Construction<a href=#construction class=hash-link aria-label=Construction的直接链接 title=Construction的直接链接>​</a></h3>
<p>The tuple node builds a finite (that is, of statically known size)
sequence of heterogeneous data. These tuples match Python's closely,
and their fixed length allows for efficient projection of their members.</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%a : Tensor[(10, 10), float32], %b : float32, %c : Tensor[(100, 100), float32]) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    let %tup = (%a, %b);     // type: (Tensor[(10, 10), float32], float32)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    ((%tup.0 + %tup.1), %c)  // type: (Tensor[(10, 10), float32], Tensor[(100, 100), float32])</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>Tuple</code> for its
definition and documentation.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=projection>Projection<a href=#projection class=hash-link aria-label=Projection的直接链接 title=Projection的直接链接>​</a></h3>
<p>A tuple must be indexed by an integer constant in order to extract a
particular member of the tuple. Projections are 0-indexed.</p>
<p>For example, the below projection evaluates to <code>%b</code>:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">(%a, %b, %c).1</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>TupleGetItem</code>
for its definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=let-bindings>Let Bindings<a href=#let-bindings class=hash-link aria-label="Let Bindings的直接链接" title="Let Bindings的直接链接">​</a></h2>
<p>A <code>let</code> binding is an immutable local variable binding, allowing the
user to bind an expression to a name.</p>
<p>A <code>let</code> binding contains a local variable, an optional type annotation,
a value, and a body expression that may reference the bound identifier.
If a type annotation on the bound variable is omitted, Relay attempts to
infer the most general type permitted for the variable.</p>
<p>The bound variable in a <code>let</code> expression is only in scope in its body,
except when the variable defines a function expression. When a <code>let</code>
expression creates a function, the variable is also in scope in its
value to allow for recursively defined functions (see the previous
subsection).</p>
<p>The value of a <code>let</code> binding is the value of the final expression after
evaluating the bindings it depends on. For example, in the following
example the entire expression evaluates to a tensor of shape <code>(10, 10)</code>
where all elements are 2:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %x : Tensor[(10, 10), float32] = Constant(1, (10, 10), float32);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%x + %x</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>A sequence of <code>let</code> bindings can be considered as a dataflow graph,
where the bindings are a series of sub-graphs connected by bound
variables. Since these binding sequences are pure, a pair of bindings
where neither depends on the other can be safely reordered. For example,
the first and second <code>let</code> bindings below may be evaluated in either
order because neither has a dataflow dependency on the other:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %x = %a + %b;</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %y = %c + %d;</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%x * %y</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>Let</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=graph-bindings>Graph Bindings<a href=#graph-bindings class=hash-link aria-label="Graph Bindings的直接链接" title="Graph Bindings的直接链接">​</a></h2>
<p>A <code>let</code> binding creates a named variable that is bound to the given
value and scoped to the subsequent expression. By contrast, a graph
binding allows for explicitly constructing dataflow graphs in a Relay
program by binding an expression (graph node) directly to a temporary
variable, which is not scoped. Each reference to the variable
corresponds to an edge in the dataflow graph. This has the semantics of
substituting the expression wherever the variable appears, even though
the graph node will only be evaluated once by the compiled program.</p>
<p>These bindings allow for a style of programming that corresponds to that
already employed by NNVM and other dataflow graph-based input formats.
The fact that the variables are not scoped offers some flexibility in
evaluation order compared to <code>let</code> bindings, though this can also
introduce some ambiguity in programs (the
<code>developer introduction to the Relay IR&lt;relay-dev-intro></code> includes more detailed discussion of this nuance).</p>
<p><em>Note: Graph bindings are not currently parsed by the text format.</em></p>
<p>In Relay's text format, a graph binding can be written as below (note
the lack of a <code>let</code> keyword and a semicolon):</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">%1 = %a + %b</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%2 = %1 + %1</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%2 * %2</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Unlike a let binding, a graph binding is not represented as an AST node
in Relay, but rather as a meta-variable referencing its AST node value.
For example, a program like the above could be constructed in Relay's
Python front-end by setting <em>Python variables</em> equal to the
corresponding Relay AST node and using the variables repeatedly, as
below (a C++ program using the corresponding API bindings could
accomplish the same thing):</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">sum1 = relay.add(a, b)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">sum2 = relay.add(sum1, sum1)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">relay.multiply(sum2, sum2)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>For development purposes and to enable certain optimizations, Relay
includes passes to convert between dataflow graphs defined using graph
bindings and programs with <code>let</code> bindings in A-normal form, employed by
many compiler optimizations from the functional programming community
(see <a href=http://matt.might.net/articles/a-normalization/ target=_blank rel="noopener noreferrer">"A-Normalization: Why and How" by Matt
Might</a> for an
introduction to A-normal form).</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=if-then-else>If-Then-Else<a href=#if-then-else class=hash-link aria-label=If-Then-Else的直接链接 title=If-Then-Else的直接链接>​</a></h2>
<p>Relay has a simple if-then-else expression that allows programs to
branch on a single value of type <code>bool</code>, i.e., a zero-rank tensor of
booleans (<code>Tensor[(), bool]</code>).</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">if (%t == %u) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    %t</span><br></span><span class=token-line style=color:#393A34><span class="token plain">} else {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    %u</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Since if-then-else branches are expressions, they may appear inline
wherever any other expression may be expected, like invocations of the
ternary operator in C-like languages. The if-then-else expression
evaluates to the value of the "then" branch if the condition value
evaluates to <code>True</code> and evaluates to the value of the "else" branch if
the condition value evaluates to <code>False</code>.</p>
<p>See <code>If</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=adt-matching>ADT Matching<a href=#adt-matching class=hash-link aria-label="ADT Matching的直接链接" title="ADT Matching的直接链接">​</a></h2>
<p>Instances of algebraic data types (ADTs), as discussed in the
<code>ADT overview&lt;adt-overview></code>, are
containers that store the arguments passed to the constructor used to
create them, tagged by the constructor name.</p>
<p>Match expressions in Relay allow for retrieving the values stored in an
ADT instance ("deconstructing" it) based on their constructor tag. A
match expression behaves similarly to a C-style <code>switch</code> statement,
branching on the different possible constructors for the type of the
value being deconstructed. As the ADT overview details, match
expressions are capable of more general pattern-matching than simply
splitting by constructors: any ADT instance nested inside an instance
(e.g., a list of lists) can be deconstructed at the same time as the
outer instance, while the different fields of the instance can be bound
to variables. (See <code>this section&lt;adt-pattern></code> for a detailed description of ADT pattern-matching.)</p>
<p>A match expression is defined using the input value (an expression) and
a list of clauses, each of which consists of a pattern and an
expression. When executed, the <em>first</em> clause whose pattern matches the
structure of the queried value is executed; the clause expression is
evaluated and returned.</p>
<p>For example, suppose we have an ADT for natural numbers:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">data Nat {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Z : () -> Nat # zero</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  S : (Nat) -> Nat # successor (+1) to a nat</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Then the following function subtracts one from a passed nat:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%v: Nat[]) -> Nat[] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%v) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Z() { Z() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case S(%n) { %n } # the variable %n is bound in the scope of this clause</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The following function subtracts two from its argument if it is at least
two and returns the argument otherwise, using a nested constructor
pattern:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%v : Nat[]) -> Nat[] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%v) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     case S(S(%n)) { %n }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     # wildcard pattern: matches all cases not matched already</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     case _ { %v }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>As aforementioned, the ordering of match clauses is relevant. In the
below example, the first clause will always match so those below it can
never run:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">fn(%v : Nat[]) -> Nat[] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%v) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case _ { %v }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case S(S(%n)) { S(%n) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case S(%n) { %n }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Z() { S(Z()) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>Match</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=tempexprs>TempExprs<a href=#tempexprs class=hash-link aria-label=TempExprs的直接链接 title=TempExprs的直接链接>​</a></h2>
<p>Program transformations (passes) in Relay may require inserting
temporary state into the program AST to guide further transformations.
The <code>TempExpr</code> node is provided as a utility to developers for this
purpose; nodes inheriting from <code>TempExpr</code> cannot appear directly in
user-provided code but may be inserted in a pass. Any <code>TempExpr</code> created
in a pass should ideally be eliminated before the pass is complete, as a
<code>TempExpr</code> only stores internal state and has no semantics of its own.</p>
<p>For an example of <code>TempExpr</code> being used in a pass, see
<code>src/relay/transforms/fold_scale_axis.cc</code>, which uses <code>TempExpr</code> nodes
to store information about scaling parameters as the pass tries to fold
these into the weights of a convolution.</p>
<p>See <code>TempExpr</code> for
its definition and documentation.</div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class=col><a href=https://github.com/hyperai/tvm-cn/edit/master/versioned_docs/version-0.12.0/reference/langref/relay_expr.md target=_blank rel="noopener noreferrer" class=theme-edit-this-page><svg fill=currentColor height=20 width=20 viewBox="0 0 40 40" class=iconEdit_OUzX aria-hidden=true><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"/></g></svg>编辑此页</a></div><div class="col lastUpdated_ccpN"><span class=theme-last-updated>最后<!-- -->由 <b>sparanoid</b> <!-- -->于 <b><time datetime=2025-04-15T11:50:10.000Z itemprop=dateModified>2025年4月15日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label=文件选项卡></nav></div></div><div class="col col--3"><div class="tableOfContents_cD69 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#dataflow-and-control-fragments class="table-of-contents__link toc-highlight">Dataflow and Control Fragments</a><li><a href=#variables class="table-of-contents__link toc-highlight">Variables</a><ul><li><a href=#global-variable class="table-of-contents__link toc-highlight">Global Variable</a><li><a href=#local-variable class="table-of-contents__link toc-highlight">Local Variable</a></ul><li><a href=#functions class="table-of-contents__link toc-highlight">Functions</a><ul><li><a href=#syntax class="table-of-contents__link toc-highlight">Syntax</a><li><a href=#closures class="table-of-contents__link toc-highlight">Closures</a><li><a href=#polymorphism-and-type-relations class="table-of-contents__link toc-highlight">Polymorphism and Type Relations</a></ul><li><a href=#operators class="table-of-contents__link toc-highlight">Operators</a><li><a href=#adt-constructors class="table-of-contents__link toc-highlight">ADT Constructors</a><li><a href=#call class="table-of-contents__link toc-highlight">Call</a><li><a href=#module-and-global-functions class="table-of-contents__link toc-highlight">Module and Global Functions</a><li><a href=#constant class="table-of-contents__link toc-highlight">Constant</a><li><a href=#tuples class="table-of-contents__link toc-highlight">Tuples</a><ul><li><a href=#construction class="table-of-contents__link toc-highlight">Construction</a><li><a href=#projection class="table-of-contents__link toc-highlight">Projection</a></ul><li><a href=#let-bindings class="table-of-contents__link toc-highlight">Let Bindings</a><li><a href=#graph-bindings class="table-of-contents__link toc-highlight">Graph Bindings</a><li><a href=#if-then-else class="table-of-contents__link toc-highlight">If-Then-Else</a><li><a href=#adt-matching class="table-of-contents__link toc-highlight">ADT Matching</a><li><a href=#tempexprs class="table-of-contents__link toc-highlight">TempExprs</a></ul></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>© 2025 Apache Software Foundation and Hyper.AI for Chinese Simplified mirror</div></div></div></footer></div>