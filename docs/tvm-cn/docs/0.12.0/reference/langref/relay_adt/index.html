<!doctype html><html lang=zh-Hans dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-0.12.0 docs-doc-page docs-doc-id-reference/langref/relay_adt" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.7.0"><title data-rh=true>Algebraic Data Types in Relay | Apache TVM 中文站</title><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_adt><meta data-rh=true property=og:locale content=zh_Hans><meta data-rh=true name=docusaurus_locale content=zh-Hans><meta data-rh=true name=docsearch:language content=zh-Hans><meta data-rh=true name=docusaurus_version content=0.12.0><meta data-rh=true name=docusaurus_tag content=docs-default-0.12.0><meta data-rh=true name=docsearch:version content=0.12.0><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-0.12.0><meta data-rh=true property=og:title content="Algebraic Data Types in Relay | Apache TVM 中文站"><meta data-rh=true name=description content="Algebraic data types (ADTs) are a staple feature of functional"><meta data-rh=true property=og:description content="Algebraic data types (ADTs) are a staple feature of functional"><link data-rh=true rel=icon href=/docs/tvm-cn/img/favicon.png><link data-rh=true rel=canonical href=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_adt><link data-rh=true rel=alternate href=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_adt hreflang=zh-Hans><link data-rh=true rel=alternate href=https://lzw.me/docs/tvm-cn/docs/0.12.0/reference/langref/relay_adt hreflang=x-default><link data-rh=true rel=preconnect href=https://KU6TD2KAGA-dsn.algolia.net crossorigin=anonymous><link rel=preconnect href=https://www.google-analytics.com><link rel=preconnect href=https://www.googletagmanager.com><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-TVRNTQWL"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-TVRNTQWL",{})</script><link rel=search type=application/opensearchdescription+xml title="Apache TVM 中文站" href=/docs/tvm-cn/opensearch.xml><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css type=text/css integrity=sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM crossorigin=anonymous><script src=https://lzw.me/x/lib/utils/h5-common.js defer data-domain=lzw.me></script><link rel=stylesheet href=/docs/tvm-cn/assets/css/styles.d660bc20.css><script src=/docs/tvm-cn/assets/js/runtime~main.412de774.js defer></script><script src=/docs/tvm-cn/assets/js/main.60e49e7b.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":(window.matchMedia("(prefers-color-scheme: light)").matches,"light"),document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><link rel=preload as=image href=/docs/tvm-cn/img/favicon-dark.svg><link rel=preload as=image href=/docs/tvm-cn/img/favicon.svg><div role=region aria-label=跳到主要内容><a class=skipToContent_ZYxR href=#__docusaurus_skipToContent_fallback>跳到主要内容</a></div><nav aria-label=主导航 class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label=切换导航栏 aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/docs/tvm-cn/><div class=navbar__logo><img src=/docs/tvm-cn/img/favicon-dark.svg alt="TVM Logo" class="themedComponent_PKz1 themedComponent--light_TYnW"><img src=/docs/tvm-cn/img/favicon.svg alt="TVM Logo" class="themedComponent_PKz1 themedComponent--dark_RKZm"></div><b class="navbar__title text--truncate">TVM 中文站</b></a><a class="navbar__item navbar__link" href=/docs/tvm-cn/docs/0.12.0/>查看文档</a><a class="navbar__item navbar__link" href=/docs/tvm-cn/about>关于</a><a href=https://tool.lzw.me target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">有趣工具箱<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a><a href=https://lzw.me/x/reference/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">IT速查清单<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a></div><div class="navbar__items navbar__items--right"><a href=https://github.com/hyperai/tvm-cn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class=navbar__link aria-haspopup=true aria-expanded=false role=button href=/docs/tvm-cn/docs/0.12.0/reference/langref/relay_adt>0.12.0</a><ul class=dropdown__menu><li><a class=dropdown__link href=/docs/tvm-cn/docs/reference/langref/relay_adt>0.13.0</a><li><a aria-current=page class="dropdown__link dropdown__link--active" href=/docs/tvm-cn/docs/0.12.0/reference/langref/relay_adt>0.12.0</a><li><a class=dropdown__link href=/docs/tvm-cn/docs/0.10.0/reference/langref/relay_adt>0.10.0</a></ul></div><div class="toggle_azEg colorModeToggle_ACQd"><button class="clean-btn toggleButton_rDEP toggleButtonDisabled_BTpm" type=button disabled title=切换浅色/暗黑模式（当前为浅色模式） aria-label=切换浅色/暗黑模式（当前为浅色模式） aria-live=polite aria-pressed=false><svg viewBox="0 0 24 24" width=24 height=24 class=lightToggleIcon_FWei><path fill=currentColor d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 class=darkToggleIcon_OH98><path fill=currentColor d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/></svg></button></div><div class=navbarSearchContainer_CQDF><button type=button class="DocSearch DocSearch-Button" aria-label="搜索 (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>搜索</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_YyXw"><div class=docsWrapper_QpQH><button aria-label=回到顶部 class="clean-btn theme-back-to-top-button backToTopButton_J2hp" type=button></button><div class=docRoot_e4fL><main class="docMainContainer_ch7h docMainContainerEnhanced_gMK8"><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol__o6A"><div class="theme-doc-version-banner alert alert--warning margin-bottom--md" role=alert><div>此为 <!-- -->Apache TVM 中文站<!-- --> <b>0.12.0</b> 版的文档，现已不再积极维护。</div><div class=margin-top--md>最新的文档请参阅 <b><a href=/docs/tvm-cn/docs/reference/langref/relay_adt>最新版本</a></b> (<!-- -->0.13.0<!-- -->)。</div></div><div class=docItemContainer_Wtch><article><span class="theme-doc-version-badge badge badge--secondary">版本：0.12.0</span><div class="tocCollapsible_hZNL theme-doc-toc-mobile tocMobile_UGcD"><button type=button class="clean-btn tocCollapsibleButton_z7oa">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Algebraic Data Types in Relay</h1></header><p>Algebraic data types (ADTs) are a staple feature of functional
programming languages, particularly those derived from ML, because they
express data structures in a manner that is easy to reason about when
writing recursive computations. Because recursion is intended to be one
of the primary mechanisms of control flow in Relay, it is important that
Relay include ADTs in order to best express loops and other control flow
structures that must be implemented using recursion.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=defining-and-matching-on-an-adt>Defining and Matching on an ADT<a href=#defining-and-matching-on-an-adt class=hash-link aria-label="Defining and Matching on an ADT的直接链接" title="Defining and Matching on an ADT的直接链接">​</a></h2>
<p><em>Note: ADTs are not presently supported in the text format. The syntax
here is speculative, based on ADTs in other languages.</em></p>
<p>ADTs can be understood as a generalized version of <code>enum</code> and <code>struct</code>
types from C-like languages. Like a C <code>struct:</code>, an ADT instance is a
container for fields of specified types, but the type system allows for
the same type to encode different possible groupings of fields in a
systematic manner, similar to C <code>enum</code> types, which are defined using a
finite set of possible values named by the user.</p>
<p>Specifically, an ADT is defined as a named group of constructors, each
of which is a function that takes values of specified types as arguments
and returns an instance of the named ADT. An ADT instance simply
contains the values of the arguments passed to the constructor call used
to produce it.</p>
<p>An ADT value is opaque until it is <em>deconstructed</em>, allowing the
arguments to the constructor to be accessed again and used to compute
new values. Because a particular ADT can have multiple constructors with
different signatures, it is usually necessary to branch on the different
possible constructors, resulting in the <em>match</em> syntax for ADTs. Hence,
ADTs are sometimes called "tagged unions" because an ADT instance is
tagged by the name of the constructor used to produce it and can later
be inspected based on the tag.</p>
<p>Because each ADT has a finite set of constructors, it is straightforward
to determine whether a function processing an ADT instance is handling
all possible cases. In particular, the type system can ensure that types
are properly assigned in all cases when deconstructing an ADT instance,
in contrast to <code>union</code> types in C. Hence, it is often easy to reason
about ADTs.</p>
<p><em>Implementation detail: Relay ADT definitions are global and are stored
in the module, similarly to global function definitions. An ADT name is,
in fact, a global type variable (just as a global function name is a
global variable). The module keeps a mapping of ADT names (global type
variables) to the list of constructors for that ADT.</em></p>
<p>Below is a simple example of defining an ADT and using it in a function
via a match expression:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># Defines an ADT named "Numbers"</span><br></span><span class=token-line style=color:#393A34><span class="token plain">data Numbers {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Empty : () -> Numbers</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Single : (Tensor[(), int32]) -> Numbers</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Pair : (Tensor[(), int32], Tensor[(), int32]) -> Numbers</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># A Numbers value can be produced using an Empty, Single, or Pair</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># constructor, each with a signature given above</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @sum(%n : Numbers[]) -> Tensor[(), int32] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   # The match expression branches on the constructor that was</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   # used to produce %n. The variables in each case are bound</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   # if the constructor matches that used for %n</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   match(%n) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     case Empty() { 0 }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     case Single(x) { x }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     case Pair(x, y) { x + y }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">@sum(Empty())    # evaluates to 0</span><br></span><span class=token-line style=color:#393A34><span class="token plain">@sum(Single(3))  # evaluates to 3</span><br></span><span class=token-line style=color:#393A34><span class="token plain">@sum(Pair(5, 6)) # evaluates to 11</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Note that ADTs are identified by name, meaning that two ADTs with
structurally identical constructors will nevertheless be distinct data
types from the point of view of the typechecker.</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># structurally identical constructors to Numbers</span><br></span><span class=token-line style=color:#393A34><span class="token plain">data Numbers2 {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Empty2 : () -> Numbers2</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Single2 : (Tensor[(), int32]) -> Numbers2</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Pair2 : (Tensor[(), int32], Tensor[(), int32]) -> Numbers2</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># the below results in a type error because Numbers2</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># is a distinct type from Numbers</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># fn() { @sum(Empty2()) }</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=type-checking-adts-and-polymorphism>Type-Checking ADTs and Polymorphism<a href=#type-checking-adts-and-polymorphism class=hash-link aria-label="Type-Checking ADTs and Polymorphism的直接链接" title="Type-Checking ADTs and Polymorphism的直接链接">​</a></h2>
<p>This section will go into more specific detail about the typing of ADTs.
Most of the complexity involved results from the fact that, as with
functions, ADTs can be polymorphic and take type parameters.</p>
<p>For example, one of the standard ADTs commonly used in functional
programming languages is the optional type, defined here:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># a is a type parameter</span><br></span><span class=token-line style=color:#393A34><span class="token plain">data Optional&lt;a> {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  None : () -> Optional</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Some : (a) -> Optional</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Optional types are commonly used as the return type for any operation
involving querying into a data structure (returning <code>Some(v)</code> if a value
is found and <code>None</code> if it isn't). Taking a type parameter in the
definition allows the same optional type to be used in a wide variety of
situations, rather than having to define a unique ADT for each different
type that could be contained in it.</p>
<p>However, it is important to ensure that option types whose contents are
of different types can still be distinguished by the type system, since
it would violate type safety if a function expecting an option
containing a <code>Tensor[(), int32]</code> instead receives an option containing a
<code>Tensor[(3, 4), float32]</code>. As this example may imply, an ADT instance is
thus given a type that contains the concrete type arguments for that
instance, ensuring the information is kept around. Let the below example
illustrate:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># the signature for option indicates the type argument</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @inc_scalar(%opt : Optional[Tensor[(), int32]]) -> Tensor[(), int32] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%opt) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case None() { 1 }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Some(%s) { %s + 1 }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @main() {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %one : Optional[Tensor[(), int32]] = Some(1);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %big : Optional[Tensor[(10, 10), float32]]</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    = Some(Constant(1, (10, 10), float32));</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %two = inc_scalar(%one);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  # let %bigger = inc_scalar(%big); # type system rejects</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  # None does not take an argument so it can always implicitly</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  # be given the correct type arguments</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %z = inc_scalar(None());</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  ()</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The syntax for the annotated type arguments (e.g.,
<code>Optional[Tensor[(), int32]]</code>) in the above examples is called a "type
call," treating the polymorphic ADT definition as a type-level function
(taking type params and returning a type, namely the ADT). Any ADT
appearing in a type annotation or function signature must be annotated
with type arguments (a non-polymorphic ADT must be in a type call with
no arguments).</p>
<p>Thus, we can say in general that if constructor <code>C</code> that takes arguments
of types <code>T1, ..., Tn</code> is a constructor for an ADT <code>D</code> that takes type
parameters <code>v1, ..., vn</code> (where <code>T1, ..., Tn</code> may contain any of the
<code>v1, ..., vn</code>), then <code>C</code> has the type
<code>fun&lt;v1, ..., vn>(T1, ..., Tn) -> D[v1, ..., vn]</code>. This means that
constructors are typed like ordinary functions and thus appear inside
call nodes and can be passed to or returned by other functions. In
particular, the <code>Some</code> example above has the signature
<code>fun&lt;a>(a) -> Optional[a]</code>, while <code>None</code> has the signature
<code>fun&lt;a>() -> Optional[a]</code>.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=recursion-with-adts>Recursion with ADTs<a href=#recursion-with-adts class=hash-link aria-label="Recursion with ADTs的直接链接" title="Recursion with ADTs的直接链接">​</a></h2>
<p>ADT definitions are allowed to be recursive, that is, a definition for
an ADT named <code>D</code> can assume the existence of type <code>D</code> and use it as an
argument to constructors. Recursion allows ADTs to represent complex
structures such as lists or trees; it is the source of much of ADTs'
power in functional programming, since an appropriately designed data
structure could make it easy to concisely express a computation with a
recursive function.</p>
<p>Many commonly used ADTs involve recursion; some of these are given in
<a href=#common-adt-uses>Common ADT Uses</a>. As an example here, we will examine
the list ADT, ubiquitous in functional languages:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">data List&lt;a> {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   Nil : () -> List</span><br></span><span class=token-line style=color:#393A34><span class="token plain">   Cons : (a, List[a]) -> List</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>(Notice that the recursive reference to <code>List</code> is wrapped in a type call
even in the constructor.)</p>
<p>The above definition means that a list of values of a particular type
can be represented by nesting <code>Cons</code> constructors until the end of the
list is reached, which can be indicated with a <code>Nil</code> (representing an
empty list).</p>
<p>Lists represented in this manner can easily be recursively processed.
For example, the following function sums a list of integers:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @list_sum(%l : List[Tensor[(), int32]]) -> Tensor[(), int32] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { 0 }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    # add the head of the list to the sum of the tail</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { %h + @list_sum(%t) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>As it happens, many recursive functions on lists like the one just given
share structures that can be factored out into generic, easily usable
functions that will be discussed under <a href=#common-adt-uses>Common ADT
Uses</a>.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=pattern-matching-in-match-expressions>Pattern Matching in Match Expressions<a href=#pattern-matching-in-match-expressions class=hash-link aria-label="Pattern Matching in Match Expressions的直接链接" title="Pattern Matching in Match Expressions的直接链接">​</a></h2>
<p>Match expressions in Relay, as in other functional languages, are
capable of more versatile pattern matching than simply having one case
for each constructor for the datatype of the value being deconstructed.</p>
<p>In particular, the patterns in match cases can be built up recursively:</p>
<ul>
<li>Constructor patterns match for a particular ADT constructor. If a
value matches the constructor, each argument to the constructor will
be matched against a nested pattern.</li>
<li>Wildcard patterns will match any value and will not bind to a
variable.</li>
<li>Variable patterns will match any value and bind it to a local
variable, scoped to the match clause.</li>
</ul>
<p>In the simple case of <code>@list_sum</code> above, the first match case has a
<code>Nil</code> constructor pattern (with no nested arguments) and the second has
a <code>Cons</code> constructor pattern that uses variable patterns for each of the
arguments to <code>Cons</code>.</p>
<p>The below example uses a wildcard pattern to ignore one of the arguments
to <code>Cons</code>:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @first&lt;a>(%l : List[a]) -> Optional[a] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { None() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, _) { Some(%h) } # list tail is unused and ignored</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Here, a constructor pattern is nested inside another constructor pattern
to avoid nested match expressions for a list option. A top-level
wildcard pattern is also used to handle all cases that do not match the
first clause:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @second_opt&lt;a>(%ll : Optional[List[a]]) -> Optional[a] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%ll) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    # we only need the second member of the list if there is one</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Some(Cons(_, Cons(%s, _))) { Some(%s) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case _ { None() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># @second_opt(Some(Cons(1, Nil()))) evaluates to None()</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># @second_opt(Some(Cons(1, Cons(2, Nil())))) evaluates to Some(2)</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># @second_opt(Some(Nil())) evaluates to None()</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># @second_opt(None()) evaluates to None()</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Note that a match expression checks its patterns in the order the cases
are listed: the first clause whose pattern that matches the input value
is the one that is evaluated. Here, a top-level variable pattern binds
the whole input value:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @match_order_beware&lt;a>(%l : List[a]) -> List[a] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case %v { %v }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    # the above matches everything so neither of these runs</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { Cons(%h, @match_order_beware(%t)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=common-adt-uses>Common ADT Uses<a href=#common-adt-uses class=hash-link aria-label="Common ADT Uses的直接链接" title="Common ADT Uses的直接链接">​</a></h2>
<p>In functional programming languages, certain ADTs provide useful
facilities for writing common programs. Parametric polymorphism and
higher-order functions allow these ADTs to be easily reuseable and for
generic functions to manipulate them in common situations. Relay
includes a "Prelude" of certain pre-defined ADTs and functions for
them that correspond to the indispensable ADTs of other languages.</p>
<p>The option type defined under <a href=#type-checking-adts-and-polymorphism>Type-Checking ADTs and
Polymorphism</a> is one such ADT,
used whenever it can make sense for a function to only return a value
under certain circumstances. Having the option type allows for the type
system to keep track of which functions always return a value of a
certain type versus returning an option of that type, ensuring that any
options are always explicitly checked (contrast with returning null
pointers or throwing exceptions as other ways to addressing that
problem).</p>
<p>Lists (defined in <a href=#recursion-with-adts>Recursion with ADTs</a>) can be
manipulated by generic functions in a manner similar to list
comprehensions and certain library functions in Python. Below are very
common functions for iterating through lists, which are included in
Relay's Prelude. (These have all been extensively characterized in the
functional programming literature, and we do not attempt to reproduce
that work in this document.)</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># Map: for [h1, h2, ..., hn] returns [f(h1), f(h2), ..., f(hn)]</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @map&lt;a, b>(%f : fn(a) -> b, %l : List[a]) -> List[b] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { Cons(%f(%h), @map(%f, %t)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># Left fold: for [h1, h2, ..., hn] returns f(...(f(f(z, h1), h2)...), hn)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @foldl&lt;a, b>(%f : fn(b, a) -> b, %z : b, %l : List[a]) -> b {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { %z }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { @foldl(%f, %f(%z, %h), %t) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># Right fold: for [h1, h2, ..., hn] returns f(h1, f(h2, f(..., (f(hn, z)...)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @foldr&lt;a, b>(%f : fn(a, b) -> b, %z : b, %l : List[a] -> b {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { %z }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { %f(%h, @foldr(%f, %z, %t)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Using these iteration constructs, many common operations over lists can
be expressed compactly. For example, the following map doubles all
members of a list:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># directly written</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @double(%l : List[Tensor[(), int32]]) -> List[Tensor[(), int32]] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { Cons(%h * 2, @double(%t)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># map takes care of the recursion</span><br></span><span class=token-line style=color:#393A34><span class="token plain">@map(fn(%i) { %i * 2 }, %l)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The following right fold concatenates two lists:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># directly written</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @concat&lt;a>(%l1 : List[a], %l2 : List[a]) -> List[a] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l1) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { %l2 }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { Cons(%h, @concat(%t, %l2) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># foldr takes care of the recursion</span><br></span><span class=token-line style=color:#393A34><span class="token plain">@foldr(fn(%h, %z) { Cons(%h, %z) }, %l2, %l1)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The following left fold flattens a list of lists (using concatenation):</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># directly written</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @flatten&lt;a>(%ll : List[List[a]]) -> List[a] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%ll) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%h, %t) { @concat(%h, @flatten(%t)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># foldl takes care of the recursion</span><br></span><span class=token-line style=color:#393A34><span class="token plain">@foldl(@concat, Nil(), %ll)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Note that these iteration constructs can be implemented directly in
Relay's source language and more can easily be defined (and for more
data types, like trees), rather than being constructs built into the
language (e.g., <a href=https://mxnet.apache.org/versions/master/tutorials/control_flow/ControlFlowTutorial.html target=_blank rel="noopener noreferrer">"foreach" in
MXNet</a>).
ADTs and their extensibility allow for a broad range of iterations and
data structures to be expressed in Relay and supported by the type
system without having to modify the language implementation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=implementing-neural-nets-using-adts>Implementing Neural Nets Using ADTs<a href=#implementing-neural-nets-using-adts class=hash-link aria-label="Implementing Neural Nets Using ADTs的直接链接" title="Implementing Neural Nets Using ADTs的直接链接">​</a></h2>
<p>In <a href=http://colah.github.io/posts/2015-09-NN-Types-FP/ target=_blank rel="noopener noreferrer">this 2015 blog
post</a>, Christopher
Olah notes that many neural networks can be easily expressed using
common functional programming constructs. Relay's ADTs allow those
examples to be implemented directly in TVM.</p>
<p>First let us suppose that we have a function corresponding to a trained
recurrent neural net (RNN) cell, which takes in a past state and an
input value and returns a new state and output value. In Relay, this
would have the following signature:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">@cell : fn&lt;state_type, in_type, out_type>(state_type, in_type) -> (state_type, out_type)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>We might consider a ReLU cell as a simple concrete example, with a
trained version below:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @linear(%x, %w, %b) { %w*%x + %b }</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @relu_cell(%w, # weights</span><br></span><span class=token-line style=color:#393A34><span class="token plain">               %b, # offsets</span><br></span><span class=token-line style=color:#393A34><span class="token plain">               %s, # state</span><br></span><span class=token-line style=color:#393A34><span class="token plain">               %x  # input</span><br></span><span class=token-line style=color:#393A34><span class="token plain">) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %x2 = @linear(%x, %w.0, %b.0);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %s2 = @linear(%s, %w.1, %b.1);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  # doesn't change the state</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  (%s, nn.relu(%x2 + %s2))</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># this is a higher-order function because it returns a closure</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @trained_cell(%w, %b) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  fn(%x, %h) { @relu_cell(%w, %b, %x, %h) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Following Olah's example, we can encode a sequence (list) of inputs
with the following left fold:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @encode&lt;state_type, in_type, out_type>(%cell, %input : List[in_type], %init : state_type) -> state_type {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  # not using the output</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  @foldl(fn(%state, %in) { %cell(%state, %in).0 }, %init, %input)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Using an <em>unfold</em> iterator (from Haskell's standard library), the same
cell could be used to make a generator network (which takes a single
input and produces a sequence of outputs):</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># included in Relay's Prelude</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @unfoldr&lt;a, b>(%f : fn(b) -> Optional[(a, b)], %z : b) -> List[a] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%f(%z)) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Some(%pair) { Cons(%pair.0, @unfoldr(%f, %pair.1)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case None() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># we need some way of generating an input to the cell function given only a state</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @gen_func&lt;state_type, in_type, out_type>(%state : state_type) : Optional[(out_type, state_type)] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  let %in : Optional[in_type] = @generate_input(%state);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%in) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Some(%n) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      let %cell_out = @cell(%n, %state);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      Some((%cell_out.1, %cell_out.0)) # pair of output and state</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case None() { None() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @generator&lt;state_type, in_type, out_type>(%cell, %init : state_type) -> List[out_type] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  @unfoldr(fn(%state) { @gen_func(%cell, %state) }, %init)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>An accumulating map (a fold that simultaneously updates an accumulator
value and a list of outputs) can be used to write a general RNN (with an
output for every input):</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @map_accumr&lt;a, b, c>(%f : fn(a, b) -> (a, c), %acc : a, %l : List[b]) -> (a, List[c]) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { (%acc, Nil()) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%b, %t) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      let %update = %f(%acc, %b);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      let %rest = @map_accumr(%f, %update.0, %t));</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      (%rest.0, Cons(%update.1, %rest.1))</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># can also be implemented as a right fold</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># (this version is included in Relay's Prelude)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @map_accumr_fold(%f, %acc, %l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  @foldr(fn(%b, %p) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    let %f_out = %f(%p.0, %b);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    (%f_out.0, Cons(%f_out.1, %p.1))</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  },</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  (%acc, Nil()), %l)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @general_rnn&lt;state_type, in_type, out_type>(%cell, %init : state_type, %input : List[in_type])</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  -> (state_type, List[out_type]) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  @map_accumr(%cell, %init, %input)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Olah also gives an example of a bidirectional neural network, in which
two sets of cells (which may have different weights) process the input
in both directions and produce a single set of outputs. The following is
a Relay implementation of that example:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># creates a list of tuples from two lists</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># included in Relay's Prelude</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @zip&lt;a, b>(%l : List[a], %m : List[b]) -> List[(a, b)] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  match(%l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Nil() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    case Cons(%a, %t1) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      match(%m) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        case Nil() { Nil() }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">        case Cons(%b, %t2) { Cons((%a, %b), @zip(%t1, %t2)) }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">      }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain"># analogous to map_accumr</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># included in Relay's Prelude</span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @map_accmul(%f, %acc, %l) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  @foldl(fn(%p, %b){</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    let %f_out = %f(%p.0, %b);</span><br></span><span class=token-line style=color:#393A34><span class="token plain">    (%f_out.0, Cons(%f_out.1, %p.1))</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  }, (%acc, Nil()), %l)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain" style=display:inline-block></span><br></span><span class=token-line style=color:#393A34><span class="token plain">def @bidirectional_rnn&lt;state1_type, state2_type, in_type, out1_type, out2_type></span><br></span><span class=token-line style=color:#393A34><span class="token plain">  (%cell1, %cell2, %state1 : state1_type, %state2 : state2_type, %input : List[in_type])</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  -> List[(out1_type, out2_type)] {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  @zip(@map_accumr(%cell1, %state1, %input).1, @map_accuml(%cell2, %state2, %input).1)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class=col><a href=https://github.com/hyperai/tvm-cn/edit/master/versioned_docs/version-0.12.0/reference/langref/relay_adt.md target=_blank rel="noopener noreferrer" class=theme-edit-this-page><svg fill=currentColor height=20 width=20 viewBox="0 0 40 40" class=iconEdit_OUzX aria-hidden=true><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"/></g></svg>编辑此页</a></div><div class="col lastUpdated_ccpN"><span class=theme-last-updated>最后<!-- -->由 <b>sparanoid</b> <!-- -->于 <b><time datetime=2025-04-15T11:50:10.000Z itemprop=dateModified>2025年4月15日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label=文件选项卡></nav></div></div><div class="col col--3"><div class="tableOfContents_cD69 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#defining-and-matching-on-an-adt class="table-of-contents__link toc-highlight">Defining and Matching on an ADT</a><li><a href=#type-checking-adts-and-polymorphism class="table-of-contents__link toc-highlight">Type-Checking ADTs and Polymorphism</a><li><a href=#recursion-with-adts class="table-of-contents__link toc-highlight">Recursion with ADTs</a><li><a href=#pattern-matching-in-match-expressions class="table-of-contents__link toc-highlight">Pattern Matching in Match Expressions</a><li><a href=#common-adt-uses class="table-of-contents__link toc-highlight">Common ADT Uses</a><li><a href=#implementing-neural-nets-using-adts class="table-of-contents__link toc-highlight">Implementing Neural Nets Using ADTs</a></ul></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>© 2025 Apache Software Foundation and Hyper.AI for Chinese Simplified mirror</div></div></div></footer></div>