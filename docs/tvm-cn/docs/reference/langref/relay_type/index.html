<!doctype html><html lang=zh-Hans dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-reference/langref/relay_type" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.7.0"><title data-rh=true>Relay\'s Type System | Apache TVM 中文站</title><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://lzw.me/docs/tvm-cn/docs/reference/langref/relay_type><meta data-rh=true property=og:locale content=zh_Hans><meta data-rh=true name=docusaurus_locale content=zh-Hans><meta data-rh=true name=docsearch:language content=zh-Hans><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="Relay\'s Type System | Apache TVM 中文站"><meta data-rh=true name=description content="We briefly introduced types while detailing Relay\'s expression"><meta data-rh=true property=og:description content="We briefly introduced types while detailing Relay\'s expression"><link data-rh=true rel=icon href=/docs/tvm-cn/img/favicon.png><link data-rh=true rel=canonical href=https://lzw.me/docs/tvm-cn/docs/reference/langref/relay_type><link data-rh=true rel=alternate href=https://lzw.me/docs/tvm-cn/docs/reference/langref/relay_type hreflang=zh-Hans><link data-rh=true rel=alternate href=https://lzw.me/docs/tvm-cn/docs/reference/langref/relay_type hreflang=x-default><link data-rh=true rel=preconnect href=https://KU6TD2KAGA-dsn.algolia.net crossorigin=anonymous><link rel=preconnect href=https://www.google-analytics.com><link rel=preconnect href=https://www.googletagmanager.com><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-TVRNTQWL"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","GTM-TVRNTQWL",{})</script><link rel=search type=application/opensearchdescription+xml title="Apache TVM 中文站" href=/docs/tvm-cn/opensearch.xml><link rel=stylesheet href=https://fastly.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css type=text/css integrity=sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM crossorigin=anonymous><script src=https://lzw.me/x/lib/utils/h5-common.js defer data-domain=lzw.me></script><link rel=stylesheet href=/docs/tvm-cn/assets/css/styles.d660bc20.css><script src=/docs/tvm-cn/assets/js/runtime~main.412de774.js defer></script><script src=/docs/tvm-cn/assets/js/main.60e49e7b.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":(window.matchMedia("(prefers-color-scheme: light)").matches,"light"),document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><link rel=preload as=image href=/docs/tvm-cn/img/favicon-dark.svg><link rel=preload as=image href=/docs/tvm-cn/img/favicon.svg><div role=region aria-label=跳到主要内容><a class=skipToContent_ZYxR href=#__docusaurus_skipToContent_fallback>跳到主要内容</a></div><nav aria-label=主导航 class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label=切换导航栏 aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/docs/tvm-cn/><div class=navbar__logo><img src=/docs/tvm-cn/img/favicon-dark.svg alt="TVM Logo" class="themedComponent_PKz1 themedComponent--light_TYnW"><img src=/docs/tvm-cn/img/favicon.svg alt="TVM Logo" class="themedComponent_PKz1 themedComponent--dark_RKZm"></div><b class="navbar__title text--truncate">TVM 中文站</b></a><a class="navbar__item navbar__link" href=/docs/tvm-cn/docs/>查看文档</a><a class="navbar__item navbar__link" href=/docs/tvm-cn/about>关于</a><a href=https://tool.lzw.me target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">有趣工具箱<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a><a href=https://lzw.me/x/reference/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">IT速查清单<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a></div><div class="navbar__items navbar__items--right"><a href=https://github.com/hyperai/tvm-cn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width=13.5 height=13.5 aria-hidden=true viewBox="0 0 24 24" class=iconExternalLink_wR_l><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class=navbar__link aria-haspopup=true aria-expanded=false role=button href=/docs/tvm-cn/docs/reference/langref/relay_type>0.13.0</a><ul class=dropdown__menu><li><a aria-current=page class="dropdown__link dropdown__link--active" href=/docs/tvm-cn/docs/reference/langref/relay_type>0.13.0</a><li><a class=dropdown__link href=/docs/tvm-cn/docs/0.12.0/reference/langref/relay_type>0.12.0</a><li><a class=dropdown__link href=/docs/tvm-cn/docs/0.10.0/reference/langref/relay_type>0.10.0</a></ul></div><div class="toggle_azEg colorModeToggle_ACQd"><button class="clean-btn toggleButton_rDEP toggleButtonDisabled_BTpm" type=button disabled title=切换浅色/暗黑模式（当前为浅色模式） aria-label=切换浅色/暗黑模式（当前为浅色模式） aria-live=polite aria-pressed=false><svg viewBox="0 0 24 24" width=24 height=24 class=lightToggleIcon_FWei><path fill=currentColor d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 class=darkToggleIcon_OH98><path fill=currentColor d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/></svg></button></div><div class=navbarSearchContainer_CQDF><button type=button class="DocSearch DocSearch-Button" aria-label="搜索 (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>搜索</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_YyXw"><div class=docsWrapper_QpQH><button aria-label=回到顶部 class="clean-btn theme-back-to-top-button backToTopButton_J2hp" type=button></button><div class=docRoot_e4fL><main class="docMainContainer_ch7h docMainContainerEnhanced_gMK8"><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol__o6A"><div class=docItemContainer_Wtch><article><span class="theme-doc-version-badge badge badge--secondary">版本：0.13.0</span><div class="tocCollapsible_hZNL theme-doc-toc-mobile tocMobile_UGcD"><button type=button class="clean-btn tocCollapsibleButton_z7oa">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Relay\'s Type System</h1></header><p>We briefly introduced types while detailing Relay's expression
language, but have not yet described its type system. Relay is a
statically typed and type-inferred language, allowing programs to be
fully typed while requiring just a few explicit type annotations.</p>
<p>Static types are useful when performing compiler optimizations because
they communicate properties about the data a program manipulates, such
as runtime shape, data layout, and storage, without needing to run the
program. Relay's <a href=#algebraic-data-types>Algebraic Data Types</a> allow
for easily and flexibly composing types in order to build data
structures that can be reasoned about inductively and used to write
recursive functions.</p>
<p>Relay's type system features a form of <em>dependent typing</em> for shapes.
That is, its type system keeps track of the shapes of tensors in a Relay
program. Treating tensor shapes as types allows Relay to perform more
powerful reasoning at compile time; in particular, Relay can statically
reason about operations whose output shapes vary based on the input
shapes in complex ways. Casting shape inference as a type inference
problem allows Relay to infer the shapes of all tensors at compile time,
including in programs that use branching and function calls.</p>
<p>Statically reasoning about shapes in this manner allows Relay to be
ahead-of-time compiled and provides much more information about tensors
for optimizations further in the compilation pipeline. Such
optimizations can be implemented as passes, which are Relay-to-Relay AST
transformations, and may use the inferred types (e.g., shape
information) for making decisions about program transformations. For
instance, <code>src/relay/transforms/fuse_ops.cc</code> gives an implementation of
a pass that uses inferred tensor shapes to replace invocations of
operators in a Relay program with fused operator implementations.</p>
<p>Reasoning about tensor types in Relay is encoded using <em>type relations</em>,
which means that the bulk of type checking in Relay is constraint
solving (ensuring that all type relations are satisfied at call sites).
Type relations offer a flexible and relatively simple way of making the
power of dependent typing available in Relay without greatly increasing
the complexity of its type system.</p>
<p>Below we detail the language of types in Relay and how they are assigned
to Relay expressions.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=type>Type<a href=#type class=hash-link aria-label=Type的直接链接 title=Type的直接链接>​</a></h2>
<p>The base type for all Relay types. All Relay types are sub-classes of
this base type.</p>
<p>See <code>Type</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=tensor-type>Tensor Type<a href=#tensor-type class=hash-link aria-label="Tensor Type的直接链接" title="Tensor Type的直接链接">​</a></h2>
<p>A concrete tensor type in Relay.</p>
<p>Tensors are typed according to data type and shape. At present, these
use TVM's data types and shapes, but in the future, Relay may include a
separate AST for shapes. In particular, data types include <code>bool</code>,
<code>float32</code>, <code>int8</code> and various other bit widths and numbers of lanes.
Shapes are given as tuples of dimensions (TVM <code>IndexExpr</code>), such as
<code>(5, 5)</code>; scalars are also given tuple types and have a shape of <code>()</code>.</p>
<p>Note, though, that TVM shapes can also include variables and arithmetic
expressions including variables, so Relay's constraint solving phase
will attempt to find assignments to all shape variables to ensure all
shapes will be concrete before running a program.</p>
<p>For example, here is a simple concrete tensor type corresponding to a
10-by-10 tensor of 32-bit floats:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">Tensor[(10, 10), float32]</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>TensorType</code> for
its definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=tuple-type>Tuple Type<a href=#tuple-type class=hash-link aria-label="Tuple Type的直接链接" title="Tuple Type的直接链接">​</a></h2>
<p>A type of a tuple in Relay.</p>
<p>Just as a tuple is simply a sequence of values of statically known
length, the type of a tuple consists of a sequence of the types
corresponding to each member of the tuple.</p>
<p>Because a tuple type is of statically known size, the type of a tuple
projection is simply the corresponding index into the tuple type.</p>
<p>For example, in the below code, <code>%t</code> is of type
<code>(Tensor[(), bool], Tensor[(10, 10), float32])</code> and <code>%c</code> is of type
<code>Tensor[(10, 10), float32]</code>.</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">let %t = (False, Constant(1, (10, 10), float32));</span><br></span><span class=token-line style=color:#393A34><span class="token plain">let %c = %t.1;</span><br></span><span class=token-line style=color:#393A34><span class="token plain">%c</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>TupleType</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=type-parameter>Type Parameter<a href=#type-parameter class=hash-link aria-label="Type Parameter的直接链接" title="Type Parameter的直接链接">​</a></h2>
<p>Type parameters represent placeholder types used for polymorphism in
functions. Type parameters are specified according to <em>kind</em>,
corresponding to the types those parameters are allowed to replace:</p>
<ul>
<li><code>Type</code>, corresponding to top-level Relay types like tensor types,
tuple types, and function types</li>
<li><code>BaseType</code>, corresponding to the base type of a tensor (e.g.,
<code>float32</code>, <code>bool</code>)</li>
<li><code>Shape</code>, corresponding to a tensor shape</li>
<li><code>ShapeVar</code>, corresponding to variables within a tensor shape</li>
</ul>
<p>Relay's type system enforces that type parameters are only allowed to
appear where their kind permits them, so if type variable <code>t</code> is of kind
<code>Type</code>, <code>Tensor[t, float32]</code> is not a valid type.</p>
<p>Like normal parameters, concrete arguments must be given for type
parameters at call sites.</p>
<p>For example, <code>s</code> below is a type parameter of kind <code>Shape</code> and it will
be substituted with <code>(10, 10)</code> at the call site below:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">def @plus&lt;s : Shape>(%t1 : Tensor[s, float32], %t2 : Tensor[s, float32]) {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">     add(%t1, %t2)</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span><span class=token-line style=color:#393A34><span class="token plain">plus&lt;(10, 10)>(%a, %b)</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>See <code>TypeVar</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=type-constraint>Type Constraint<a href=#type-constraint class=hash-link aria-label="Type Constraint的直接链接" title="Type Constraint的直接链接">​</a></h2>
<p>This is an abstract class representing a type constraint, to be
elaborated upon in further releases. Currently, type relations are the
only type constraints provided; they are discussed below.</p>
<p>See <code>TypeConstraint</code>
for its definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=function-type>Function Type<a href=#function-type class=hash-link aria-label="Function Type的直接链接" title="Function Type的直接链接">​</a></h2>
<p>A function type in Relay, see [tvm/relay/type.h] for more
details.</p>
<p>This is the type assigned to functions in Relay. A function type
consists of a list of type parameters, a set of type constraints, a
sequence of argument types, and a return type.</p>
<p>We informally write function types as:
<code>fn&lt;type_params>(arg_types) -> ret_type where type_constraints</code></p>
<p>A type parameter in the function type may appear in the argument types
or the return types. Additionally, each of the type constraints must
hold at every call site of the function. The type constraints typically
take the function's argument types and the function's return type as
arguments, but may take a subset instead.</p>
<p>See <code>FuncType</code> for its
definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=type-relation>Type Relation<a href=#type-relation class=hash-link aria-label="Type Relation的直接链接" title="Type Relation的直接链接">​</a></h2>
<p>A type relation is the most complex type system feature in Relay. It
allows users to extend type inference with new rules. We use type
relations to define types for operators that work with tensor shapes in
complex ways, such as broadcasting operators or <code>flatten</code>, allowing
Relay to statically reason about the shapes in these cases.</p>
<p>A type relation <code>R</code> describes a relationship between the input and
output types of a Relay function. Namely, <code>R</code> is a function on types
that outputs [true] if the relationship holds and
[false] if it fails to hold. Types given to a relation may
be incomplete or include shape variables, so type inference must assign
appropriate values to incomplete types and shape variables for necessary
relations to hold, if such values exist.</p>
<p>For example we can define an identity relation to be:</p>
<div class="language-prolog codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-prolog codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">Identity(I, I) :- true</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>It is usually convenient to type operators in Relay by defining a
relation specific to that operator that encodes all the necessary
constraints on the argument types and the return type. For example, we
can define the relation for <code>flatten</code>:</p>
<div class="language-prolog codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-prolog codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">Flatten(Tensor(sh, bt), O) :-</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  O = Tensor(sh[0], prod(sh[1:]))</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>If we have a relation like <code>Broadcast</code> it becomes possible to type
operators like <code>add</code>:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">add : fn&lt;t1 : Type, t2 : Type, t3 : Type>(t1, t2) -> t3</span><br></span><span class=token-line style=color:#393A34><span class="token plain">            where Broadcast</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>The inclusion of <code>Broadcast</code> above indicates that the argument types and
the return type must be tensors where the shape of <code>t3</code> is the broadcast
of the shapes of <code>t1</code> and <code>t2</code>. The type system will accept any argument
types and return type so long as they fulfill <code>Broadcast</code>.</p>
<p>Note that the above example relations are written in Prolog-like syntax,
but currently the relations must be implemented by users in C++ or
Python. More specifically, Relay's type system uses an <em>ad hoc</em> solver
for type relations in which type relations are actually implemented as
C++ or Python functions that check whether the relation holds and
imperatively update any shape variables or incomplete types. In the
current implementation, the functions implementing relations should
return <code>False</code> if the relation fails to hold and <code>True</code> if the relation
holds or if there is not enough information to determine whether it
holds or not.</p>
<p>The functions for all the relations are run as needed (if an input is
updated) until one of the following conditions holds:</p>
<ol>
<li>All relations hold and no incomplete types remain (typechecking
succeeds).</li>
<li>A relation fails to hold (a type error).</li>
<li>A fixpoint is reached where shape variables or incomplete types
remain (either a type error or more type annotations may be needed).</li>
</ol>
<p>Presently all of the relations used in Relay are implemented in C++. See
the files in <code>src/relay/op</code> for examples of relations implemented in
C++.</p>
<p>See <code>TypeRelation</code> for
its definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=incomplete-type>Incomplete Type<a href=#incomplete-type class=hash-link aria-label="Incomplete Type的直接链接" title="Incomplete Type的直接链接">​</a></h2>
<p>An incomplete type is a type or portion of a type that is not yet known.
This is only used during type inference. Any omitted type annotation is
replaced by an incomplete type, which will be replaced by another type
at a later point.</p>
<p>Incomplete types are known as "type variables" or "type holes" in
the programming languages literature. We use the name "incomplete
type" in order to more clearly distinguish them from type parameters:
Type parameters must be bound to a function and are replaced with
concrete type arguments (instantiated) at call sites, whereas incomplete
types may appear anywhere in the program and are filled in during type
inference.</p>
<p>See <code>IncompleteType</code>
for its definition and documentation.</p>
<h2 class="anchor anchorWithStickyNavbar_csPL" id=algebraic-data-types>Algebraic Data Types<a href=#algebraic-data-types class=hash-link aria-label="Algebraic Data Types的直接链接" title="Algebraic Data Types的直接链接">​</a></h2>
<p><em>Note: ADTs are not currently supported in the text format.</em></p>
<p>Algebraic data types (ADTs) are described in more detail in
<code>their overview &lt;adt-overview></code>; this
section describes their implementation in the type system.</p>
<p>An ADT is defined by a collection of named constructors, each of which
takes arguments of certain types. An instance of an ADT is a container
that stores the values of the constructor arguments used to produce it
as well as the name of the constructor; the values can be retrieved by
deconstructing the instance by matching based on its constructor. Hence,
ADTs are sometimes called "tagged unions": like a C-style union, the
contents of an instance for a given ADT may have different types in
certain cases, but the constructor serves as a tag to indicate how to
interpret the contents.</p>
<p>From the type system's perspective, it is most pertinent that ADTs can
take type parameters (constructor arguments can be type parameters,
though ADT instances with different type parameters must be treated as
different types) and be recursive (a constructor for an ADT can take an
instance of that ADT, thus an ADT like a tree or list can be inductively
built up). The representation of ADTs in the type system must be able to
accommodate these facts, as the below sections will detail.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=global-type-variable>Global Type Variable<a href=#global-type-variable class=hash-link aria-label="Global Type Variable的直接链接" title="Global Type Variable的直接链接">​</a></h3>
<p>To represent ADTs compactly and easily allow for recursive ADT
definitions, an ADT definition is given a handle in the form of a global
type variable that uniquely identifies it. Each ADT definition is given
a fresh global type variable as a handle, so pointer equality can be
used to distinguish different ADT names.</p>
<p>For the purposes of Relay's type system, ADTs are differentiated by
name; that means that if two ADTs have different handles, they will be
considered different types even if all their constructors are
structurally identical.</p>
<p>Recursion in an ADT definition thus follows just like recursion for a
global function: the constructor can simply reference the ADT handle
(global type variable) in its definition.</p>
<p>See <code>GlobalTypeVar</code> for
its definition and documentation.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=definitions-type-data>Definitions (Type Data)<a href=#definitions-type-data class=hash-link aria-label="Definitions (Type Data)的直接链接" title="Definitions (Type Data)的直接链接">​</a></h3>
<p>Besides a name, an ADT needs to store the constructors that are used to
define it and any type parameters used within them. These are stored in
the module,
<code>analogous to global function definitions&lt;module-description></code>.</p>
<p>While type-checking uses of ADTs, the type system sometimes must index
into the module using the ADT name to look up information about
constructors. For example, if a constructor is being pattern-matched in
a match expression clause, the type-checker must check the
constructor's signature to ensure that any bound variables are being
assigned the correct types.</p>
<p>See <code>TypeData</code> for its
definition and documentation.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=type-call>Type Call<a href=#type-call class=hash-link aria-label="Type Call的直接链接" title="Type Call的直接链接">​</a></h3>
<p>Because an ADT definition can take type parameters, Relay's type system
considers an ADT definition to be a <em>type-level function</em> (in that the
definition takes type parameters and returns the type of an ADT instance
with those type parameters). Thus, any instance of an ADT is typed using
a type call, which explicitly lists the type parameters given to the ADT
definition.</p>
<p>It is important to list the type parameters for an ADT instance, as two
ADT instances built using different constructors but the same type
parameters are of the <em>same type</em> while two ADT instances with different
type parameters should not be considered the same type (e.g., a list of
integers should not have the same type as a list of pairs of floating
point tensors).</p>
<p>The "function" in the type call is the ADT handle and there must be
one argument for each type parameter in the ADT definition. (An ADT
definition with no arguments means that any instance will have no type
arguments passed to the type call).</p>
<p>See <code>TypeCall</code> for its
definition and documentation.</p>
<h3 class="anchor anchorWithStickyNavbar_csPL" id=example-list-adt>Example: List ADT<a href=#example-list-adt class=hash-link aria-label="Example: List ADT的直接链接" title="Example: List ADT的直接链接">​</a></h3>
<p>This subsection uses the simple list ADT (included as a default ADT in
Relay) to illustrate the constructs described in the previous sections.
Its definition is as follows:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">data List&lt;a> {</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Nil : () -> List</span><br></span><span class=token-line style=color:#393A34><span class="token plain">  Cons : (a, List[a]) -> List</span><br></span><span class=token-line style=color:#393A34><span class="token plain">}</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Thus, the global type variable <code>List</code> is the handle for the ADT. The
type data for the list ADT in the module notes that <code>List</code> takes one
type parameter and has two constructors, <code>Nil</code> (with signature
<code>fn&lt;a>() -> List[a]</code>) and <code>Cons</code> (with signature
<code>fn&lt;a>(a, List[a]) -> List[a]</code>). The recursive reference to <code>List</code> in
the <code>Cons</code> constructor is accomplished by using the global type variable
<code>List</code> in the constructor definition.</p>
<p>Below two instances of lists with their types given, using type calls:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain">Cons(1, Cons(2, Nil())) # List[Tensor[(), int32]]</span><br></span><span class=token-line style=color:#393A34><span class="token plain">Cons((1, 1), Cons((2, 2), Nil())) # List[(Tensor[(), int32], Tensor[(), int32])]</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>Note that <code>Nil()</code> can be an instance of any list because it does not
take any arguments that use a type parameter. (Nevertheless, for any
<em>particular</em> instance of <code>Nil()</code>, the type parameter must be specified.)</p>
<p>Here are two lists that are rejected by the type system because the type
parameters do not match:</p>
<div class="codeBlockContainer_MndA theme-code-block" style=--prism-color:#393A34;--prism-background-color:#f6f8fa><div class=codeBlockContent_WK21><pre tabindex=0 class="prism-code language-text codeBlock_Eu_S thin-scrollbar" style=color:#393A34;background-color:#f6f8fa><code class=codeBlockLines_OAXn><span class=token-line style=color:#393A34><span class="token plain"># attempting to put an integer on a list of int * int tuples</span><br></span><span class=token-line style=color:#393A34><span class="token plain">Cons(1, Cons((1, 1), Nil()))</span><br></span><span class=token-line style=color:#393A34><span class="token plain"># attempting to put a list of ints on a list of lists of int * int tuples</span><br></span><span class=token-line style=color:#393A34><span class="token plain">Cons(Cons(1, Cons(2, Nil())), Cons(Cons((1, 1), Cons((2, 2), Nil())), Nil()))</span><br></span></code></pre><div class=buttonGroup_zuHS><button type=button aria-label=复制代码到剪贴板 title=复制 class=clean-btn><span class=copyButtonIcons_x9oo aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_K8Fc><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_AKIi><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class=col><a href=https://github.com/hyperai/tvm-cn/edit/master/docs/reference/langref/relay_type.md target=_blank rel="noopener noreferrer" class=theme-edit-this-page><svg fill=currentColor height=20 width=20 viewBox="0 0 40 40" class=iconEdit_OUzX aria-hidden=true><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"/></g></svg>编辑此页</a></div><div class="col lastUpdated_ccpN"><span class=theme-last-updated>最后<!-- -->由 <b>sparanoid</b> <!-- -->于 <b><time datetime=2025-04-15T11:50:10.000Z itemprop=dateModified>2025年4月15日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label=文件选项卡></nav></div></div><div class="col col--3"><div class="tableOfContents_cD69 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#type class="table-of-contents__link toc-highlight">Type</a><li><a href=#tensor-type class="table-of-contents__link toc-highlight">Tensor Type</a><li><a href=#tuple-type class="table-of-contents__link toc-highlight">Tuple Type</a><li><a href=#type-parameter class="table-of-contents__link toc-highlight">Type Parameter</a><li><a href=#type-constraint class="table-of-contents__link toc-highlight">Type Constraint</a><li><a href=#function-type class="table-of-contents__link toc-highlight">Function Type</a><li><a href=#type-relation class="table-of-contents__link toc-highlight">Type Relation</a><li><a href=#incomplete-type class="table-of-contents__link toc-highlight">Incomplete Type</a><li><a href=#algebraic-data-types class="table-of-contents__link toc-highlight">Algebraic Data Types</a><ul><li><a href=#global-type-variable class="table-of-contents__link toc-highlight">Global Type Variable</a><li><a href=#definitions-type-data class="table-of-contents__link toc-highlight">Definitions (Type Data)</a><li><a href=#type-call class="table-of-contents__link toc-highlight">Type Call</a><li><a href=#example-list-adt class="table-of-contents__link toc-highlight">Example: List ADT</a></ul></ul></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>© 2025 Apache Software Foundation and Hyper.AI for Chinese Simplified mirror</div></div></div></footer></div>