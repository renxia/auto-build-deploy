"use strict";(self.webpackChunktvm_cn=self.webpackChunktvm_cn||[]).push([["29768"],{93314:function(n,e,t){t.r(e),t.d(e,{default:()=>l,frontMatter:()=>s,metadata:()=>i,assets:()=>o,toc:()=>c,contentTitle:()=>_});var i=JSON.parse('{"id":"topic/vta/tutorials/mat_mul_blocking","title":"\u77E9\u9635\u4E58\u6CD5\u5206\u5757","description":"\u5355\u51FB \u6B64\u5904 \u4E0B\u8F7D\u5B8C\u6574\u7684\u793A\u4F8B\u4EE3\u7801","source":"@site/docs/topic/vta/tutorials/06-mat_mul_blocking.md","sourceDirName":"topic/vta/tutorials","slug":"/topic/vta/tutorials/mat_mul_blocking","permalink":"/docs/tvm-cn/docs/topic/vta/tutorials/mat_mul_blocking","draft":false,"unlisted":false,"editUrl":"https://github.com/hyperai/tvm-cn/edit/master/docs/topic/vta/tutorials/06-mat_mul_blocking.md","tags":[],"version":"current","lastUpdatedBy":"sparanoid","lastUpdatedAt":1744717810000,"sidebarPosition":6,"frontMatter":{"title":"\u77E9\u9635\u4E58\u6CD5\u5206\u5757"},"sidebar":"tutorialSidebar","previous":{"title":"2D \u5377\u79EF\u4F18\u5316","permalink":"/docs/tvm-cn/docs/topic/vta/tutorials/conv_opt"},"next":{"title":"\u5728 VTA \u4E0A\u81EA\u52A8\u8C03\u4F18 ALU \u878D\u5408\u7B97\u5B50","permalink":"/docs/tvm-cn/docs/topic/vta/tutorials/autotuning_alu"}}'),r=t("74132"),a=t("21494");let s={title:"\u77E9\u9635\u4E58\u6CD5\u5206\u5757"},_="\u77E9\u9635\u4E58\u6CD5\u5206\u5757",o={},c=[{value:"RPC \u8BBE\u7F6E",id:"rpc-\u8BBE\u7F6E",level:2},{value:"\u8BA1\u7B97\u58F0\u660E",id:"\u8BA1\u7B97\u58F0\u660E",level:2},{value:"\u8C03\u5EA6\u8BA1\u7B97",id:"\u8C03\u5EA6\u8BA1\u7B97",level:2},{value:"\u5BF9\u8BA1\u7B97\u5206\u5757",id:"\u5BF9\u8BA1\u7B97\u5206\u5757",level:3},{value:"\u5C06\u62F7\u8D1D\u964D\u7EA7\u5230 DMA \u4F20\u8F93",id:"\u5C06\u62F7\u8D1D\u964D\u7EA7\u5230-dma-\u4F20\u8F93",level:3},{value:"\u5C06\u8BA1\u7B97\u964D\u7EA7\u5230 VTA \u8BA1\u7B97\u5185\u8054\u51FD\u6570",id:"\u5C06\u8BA1\u7B97\u964D\u7EA7\u5230-vta-\u8BA1\u7B97\u5185\u8054\u51FD\u6570",level:3},{value:"TVM \u7F16\u8BD1\u548C\u9A8C\u8BC1",id:"tvm-\u7F16\u8BD1\u548C\u9A8C\u8BC1",level:2},{value:"\u603B\u7ED3",id:"\u603B\u7ED3",level:2}];function p(n){let e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"\u77E9\u9635\u4E58\u6CD5\u5206\u5757",children:"\u77E9\u9635\u4E58\u6CD5\u5206\u5757"})}),"\n",(0,r.jsx)(e.admonition,{type:"note",children:(0,r.jsxs)(e.p,{children:["\u5355\u51FB ",(0,r.jsx)(e.a,{href:"https://tvm.apache.org/docs/topic/vta/tutorials/optimize/matrix_multiply_opt.html#sphx-glr-download-topic-vta-tutorials-optimize-matrix-multiply-opt-py",children:"\u6B64\u5904"})," \u4E0B\u8F7D\u5B8C\u6574\u7684\u793A\u4F8B\u4EE3\u7801"]})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"\u4F5C\u8005"}),"\uFF1A",(0,r.jsx)(e.a,{href:"https://homes.cs.washington.edu/~moreau/",children:"Thierry Moreau"})]}),"\n",(0,r.jsxs)(e.p,{children:["\u672C\u6559\u7A0B\u6982\u8FF0\u4E86\u5982\u4F55\u7528 TVM \u5728 VTA \u8BBE\u8BA1\u4E0A\u6709\u6548\u5730\u6620\u5C04\u77E9\u9635\u4E58\u6CD5\u3002\u63A8\u8350\u5148\u5B66\u4E60 ",(0,r.jsx)(e.a,{href:"mat_mul",children:"\u7B80\u5355\u77E9\u9635\u4E58\u6CD5"})," \u6559\u7A0B\u3002"]}),"\n",(0,r.jsx)(e.p,{children:"\u672C\u6559\u7A0B\u6F14\u793A TVM \u8C03\u5EA6\u4F18\u5316\uFF0C\u5C06\u5927\u578B\u795E\u7ECF\u7F51\u7EDC\u7B97\u5B50\u5206\u89E3\u4E3A\u66F4\u5C0F\u7684\u5757\uFF0C\u4F7F\u5F97\u53EF\u4EE5\u5728\u6709\u9650\u7684\u786C\u4EF6\u52A0\u901F\u5668\u8D44\u6E90\u5185\u5B9E\u73B0\u8BA1\u7B97\u3002"}),"\n",(0,r.jsx)(e.h2,{id:"rpc-\u8BBE\u7F6E",children:"RPC \u8BBE\u7F6E"}),"\n",(0,r.jsx)(e.p,{children:"\u9996\u5148\u5BF9 Pynq \u7684 FPGA \u8FDB\u884C\u7F16\u7A0B\uFF0C\u5E76\u6784\u5EFA\u5176 RPC runtime\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from __future__ import absolute_import, print_function\n\nimport os\nimport tvm\nfrom tvm import te\nimport vta\nimport numpy as np\nfrom tvm import rpc\nfrom tvm.contrib import utils\nfrom vta.testing import simulator\n\n# \u4ECE 3rdparty/vta-hw/config/vta_config.json \u6587\u4EF6\u52A0\u8F7D VTA \u53C2\u6570\nenv = vta.get_env()\n\n# \u4ECE OS \u73AF\u5883\u4E2D\u8BFB\u53D6 Pynq RPC \u4E3B\u673A IP \u5730\u5740\u548C\u7AEF\u53E3\u53F7\nhost = os.environ.get("VTA_RPC_HOST", "192.168.2.99")\nport = int(os.environ.get("VTA_RPC_PORT", "9091"))\n\n# \u5728 Pynq \u4E0A\u914D\u7F6E\u6BD4\u7279\u6D41\u548C runtime \u7CFB\u7EDF\uFF0C\u5339\u914D vta_config.json \u6587\u4EF6\u6307\u5B9A\u7684 VTA \u914D\u7F6E\u3002\nif env.TARGET == "pynq":\n    # \u786E\u4FDD TVM \u662F\u7528 RPC=1 \u7F16\u8BD1\u7684\n    assert tvm.runtime.enabled("rpc")\n    remote = rpc.connect(host, port)\n\n    # \u91CD\u65B0\u914D\u7F6E JIT runtime\n    vta.reconfig_runtime(remote)\n\n    # \u7528\u9884\u7F16\u8BD1\u7684 VTA \u6BD4\u7279\u6D41\u5BF9 FPGA \u8FDB\u884C\u7F16\u7A0B\u3002\n    # \u53EF\u4EE5\u901A\u8FC7\u4F20\u9012\u6BD4\u7279\u6D41\u6587\u4EF6\u7684\u8DEF\u5F84\u800C\u975E None\uFF0C\u7528\u81EA\u5B9A\u4E49\u6BD4\u7279\u6D41\u5BF9 FPGA \u8FDB\u884C\u7F16\u7A0B\u3002\n    vta.program_fpga(remote, bitstream=None)\n\n# \u5728\u6A21\u62DF\u6A21\u5F0F\u4E0B\uFF0C\u672C\u5730\u6258\u7BA1 RPC \u670D\u52A1\u5668\u3002\nelif env.TARGET in ["sim", "tsim"]:\n    remote = rpc.LocalSession()\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u8BA1\u7B97\u58F0\u660E",children:"\u8BA1\u7B97\u58F0\u660E"}),"\n",(0,r.jsx)(e.p,{children:"\u7B2C\u4E00\u6B65\uFF0C\u63CF\u8FF0\u77E9\u9635\u4E58\u6CD5\u8BA1\u7B97\u3002"}),"\n",(0,r.jsxs)(e.p,{children:["\u5C06\u77E9\u9635\u4E58\u6CD5\u5B9A\u4E49\u4E3A\u5168\u8FDE\u63A5\u5C42\u4E2D\u53EF\u4EE5\u627E\u5230\u7684\u8BA1\u7B97\uFF0C\u7531\u5176 batch size\u3001\u8F93\u5165\u901A\u9053\u548C\u8F93\u51FA\u901A\u9053\u5B9A\u4E49\u3002\u5B83\u4EEC\u5FC5\u987B\u662F VTA \u5F20\u91CF shape \u7684\u6574\u6570\u500D\uFF1A\u5206\u522B\u4E3A ",(0,r.jsx)(e.code,{children:"BATCH"}),"\u3001",(0,r.jsx)(e.code,{children:"BLOCK_IN"})," \u548C ",(0,r.jsx)(e.code,{children:"BLOCK_OUT"}),"\u3002"]}),"\n",(0,r.jsx)(e.p,{children:"\u5728\u77E9\u9635\u4E58\u6CD5\u4E2D\u6DFB\u52A0\u4E86\u989D\u5916\u7684\u7B97\u5B50\uFF0C\u8FD9\u4E9B\u7B97\u5B50\u5BF9\u8F93\u51FA\u8FDB\u884C\u79FB\u4F4D\u548C\u88C1\u526A\uFF0C\u4ECE\u800C\u6A21\u62DF\u5B9A\u70B9\u5377\u79EF\uFF0C\u7136\u540E\u8FDB\u884C\u6821\u6B63\u7EBF\u6027\u6FC0\u6D3B\u3002\u4E0B\u9762\u63CF\u8FF0\u5168\u8FDE\u63A5\u5C42\u7684 TVM \u6570\u636E\u6D41\u56FE\uFF1A"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{alt:"/img/docs/uwsampl/web-data/main/vta/tutorial/fc_dataflow.png",src:t(8630).Z+"",width:"3916",height:"1212"})}),"\n",(0,r.jsx)(e.p,{children:"\u7531\u4E8E\u8FD9\u79CD\u8BA1\u7B97\u592A\u5927\uFF0C\u65E0\u6CD5\u4E00\u6B21\u5168\u90E8\u653E\u5165 VTA \u7684\u82AF\u7247\u7F13\u51B2\u533A\u3002\u56E0\u6B64\uFF0C\u5728\u8C03\u5EA6\u9636\u6BB5\uFF0C\u4F9D\u9760\u8BA1\u7B97\u5206\u5757\u7B56\u7565\u5C06\u8BA1\u7B97\u5206\u89E3\u4E3A\u53EF\u7BA1\u7406\u7684\u5757\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# \u5168\u8FDE\u63A5\u5C42\u7EF4\u5EA6\uFF1A1024 x 1024\nbatch_size = 1\nin_channels = 1024\nout_channels = 1024\nassert batch_size % env.BATCH == 0\nassert in_channels % env.BLOCK_IN == 0\nassert out_channels % env.BLOCK_OUT == 0\n\n# \u63A8\u5BFC\u5E73\u94FA\u7684\u8F93\u5165\u5F20\u91CF shape\ndata_shape = (batch_size // env.BATCH, in_channels // env.BLOCK_IN, env.BATCH, env.BLOCK_IN)\nweight_shape = (\n    out_channels // env.BLOCK_OUT,\n    in_channels // env.BLOCK_IN,\n    env.BLOCK_OUT,\n    env.BLOCK_IN,\n)\noutput_shape = (batch_size // env.BATCH, out_channels // env.BLOCK_OUT, env.BATCH, env.BLOCK_OUT)\nnum_ops = in_channels * out_channels * batch_size * 2\n\n# Reduction \u8F74\nic = te.reduce_axis((0, in_channels // env.BLOCK_IN), name="ic")\nic_tns = te.reduce_axis((0, env.BLOCK_IN), name="ic_tns")\n\n# \u8F93\u5165\u5360\u4F4D\u7B26\u5F20\u91CF\ndata = te.placeholder(data_shape, name="data", dtype=env.inp_dtype)\nweight = te.placeholder(weight_shape, name="weight", dtype=env.wgt_dtype)\n\n# \u590D\u5236\u7F13\u51B2\u533A\ndata_buf = te.compute(data_shape, lambda *i: data(*i), "data_buf")\nweight_buf = te.compute(weight_shape, lambda *i: weight(*i), "weight_buf")\n\n# \u58F0\u660E\u77E9\u9635\u4E58\u6CD5\u8BA1\u7B97\nres_gemm = te.compute(\n    output_shape,\n    lambda bo, co, bi, ci: te.sum(\n        data_buf[bo, ic, bi, ic_tns].astype(env.acc_dtype)\n        * weight_buf[co, ic, ci, ic_tns].astype(env.acc_dtype),\n        axis=[ic, ic_tns],\n    ),\n    name="res_gem",\n)\n\n# \u4E3A\u5B9A\u70B9\u5F52\u4E00\u5316\u6DFB\u52A0\u79FB\u4F4D\u9636\u6BB5\nres_shr = te.compute(output_shape, lambda *i: res_gemm(*i) >> env.INP_WIDTH, name="res_shr")\n\n# \u5728\uFF080\uFF0C\u8F93\u5165\u6700\u5927\u503C\uFF09\u4E4B\u95F4\u5E94\u7528\u88C1\u526A\ninp_max = (1 << (env.INP_WIDTH - 1)) - 1\nres_max = te.compute(output_shape, lambda *i: tvm.te.max(res_shr(*i), 0), "res_max")\nres_min = te.compute(output_shape, lambda *i: tvm.te.min(res_max(*i), inp_max), "res_min")\n\n# \u8FD4\u56DE\u7ED3\u679C\u524D\uFF0C\u5BF9\u8F93\u5165\u6570\u636E\u7C7B\u578B\u8FDB\u884C\u7C7B\u578B\u8F6C\u6362\nres = te.compute(output_shape, lambda *i: res_min(*i).astype(env.inp_dtype), name="res")\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u8C03\u5EA6\u8BA1\u7B97",children:"\u8C03\u5EA6\u8BA1\u7B97"}),"\n",(0,r.jsx)(e.p,{children:"\u4E0B\u9762\u5C06\u7814\u7A76\u7528\u6709\u6548\u65B9\u5F0F\u5C06\u77E9\u9635\u4E58\u6CD5\u6620\u5C04\u5230 VTA \u6240\u9700\u7684\u4E00\u7EC4\u8C03\u5EA6\u8F6C\u6362\u3002\u5305\u62EC\uFF1A"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u8BA1\u7B97\u5206\u5757"}),"\n",(0,r.jsx)(e.li,{children:"\u964D\u7EA7\u5230 VTA \u786C\u4EF6\u5185\u8054\u51FD\u6570"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# \u521B\u5EFA TVM schedule\ns = te.create_schedule(res.op)\n# \u67E5\u770B\u9ED8\u8BA4\u7684 TVM schedule\nprint(tvm.lower(s, [data, weight, res], simple_mode=True))\n"})}),"\n",(0,r.jsx)(e.p,{children:"\u8F93\u51FA\u7ED3\u679C\uFF1A"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'@main = primfn(data_1: handle, weight_1: handle, res_1: handle) -> ()\n  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}\n  buffers = {data: Buffer(data_2: Pointer(int8), int8, [1024], []),\n             weight: Buffer(weight_2: Pointer(int8), int8, [1048576], []),\n             res: Buffer(res_2: Pointer(int8), int8, [1024], [])}\n  buffer_map = {data_1: data, weight_1: weight, res_1: res}\n  preflattened_buffer_map = {data_1: data_3: Buffer(data_2, int8, [1, 64, 1, 16], []), weight_1: weight_3: Buffer(weight_2, int8, [64, 64, 16, 16], []), res_1: res_3: Buffer(res_2, int8, [1, 64, 1, 16], [])} {\n  allocate(data_buf: Pointer(global int8), int8, [1024]), storage_scope = global;\n  allocate(weight_buf: Pointer(global int8), int8, [1048576]), storage_scope = global;\n  allocate(res_gem: Pointer(global int32), int32, [1024]), storage_scope = global {\n    for (i1: int32, 0, 64) {\n      for (i3: int32, 0, 16) {\n        let cse_var_1: int32 = ((i1*16) + i3)\n        data_buf_1: Buffer(data_buf, int8, [1024], [])[cse_var_1] = data[cse_var_1]\n      }\n    }\n    for (i0: int32, 0, 64) {\n      for (i1_1: int32, 0, 64) {\n        for (i2: int32, 0, 16) {\n          for (i3_1: int32, 0, 16) {\n            let cse_var_2: int32 = ((((i0*16384) + (i1_1*256)) + (i2*16)) + i3_1)\n            weight_buf_1: Buffer(weight_buf, int8, [1048576], [])[cse_var_2] = weight[cse_var_2]\n          }\n        }\n      }\n    }\n    for (co: int32, 0, 64) {\n      for (ci: int32, 0, 16) {\n        res_gem_1: Buffer(res_gem, int32, [1024], [])[((co*16) + ci)] = 0\n        for (ic: int32, 0, 64) {\n          for (ic_tns: int32, 0, 16) {\n            let cse_var_3: int32 = ((co*16) + ci)\n            res_gem_1[cse_var_3] = (res_gem_1[cse_var_3] + (cast(int32, data_buf_1[((ic*16) + ic_tns)])*cast(int32, weight_buf_1[((((co*16384) + (ic*256)) + (ci*16)) + ic_tns)])))\n          }\n        }\n      }\n    }\n    for (i1_2: int32, 0, 64) {\n      for (i3_2: int32, 0, 16) {\n        let cse_var_4: int32 = ((i1_2*16) + i3_2)\n        res_gem_2: Buffer(res_gem, int32, [1024], [])[cse_var_4] = @tir.shift_right(res_gem_1[cse_var_4], 8, dtype=int32)\n      }\n    }\n    for (i1_3: int32, 0, 64) {\n      for (i3_3: int32, 0, 16) {\n        let cse_var_5: int32 = ((i1_3*16) + i3_3)\n        res_gem_3: Buffer(res_gem, int32, [1024], [])[cse_var_5] = max(res_gem_2[cse_var_5], 0)\n      }\n    }\n    for (i1_4: int32, 0, 64) {\n      for (i3_4: int32, 0, 16) {\n        let cse_var_6: int32 = ((i1_4*16) + i3_4)\n        res_gem_4: Buffer(res_gem, int32, [1024], [])[cse_var_6] = min(res_gem_3[cse_var_6], 127)\n      }\n    }\n    for (i1_5: int32, 0, 64) {\n      for (i3_5: int32, 0, 16) {\n        let cse_var_7: int32 = ((i1_5*16) + i3_5)\n        res[cse_var_7] = cast(int8, res_gem_4[cse_var_7])\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u5BF9\u8BA1\u7B97\u5206\u5757",children:"\u5BF9\u8BA1\u7B97\u5206\u5757"}),"\n",(0,r.jsx)(e.p,{children:"\u9ED8\u8BA4\u60C5\u51B5\u4E0B\uFF0C2D \u5377\u79EF\u5BF9\u4E8E\u6FC0\u6D3B\u6216\u5185\u6838\u6743\u91CD\u6765\u8BF4\u592A\u5927\uFF0C\u65E0\u6CD5\u4E00\u6B21\u6027\u540C\u65F6\u88C5\u5165 VTA \u7684\u82AF\u7247\u7F13\u51B2\u533A\u3002\u5C06 (1, 1024) x (1024, 1024) \u77E9\u9635\u4E58\u6CD5\u5206\u5757\u4E3A\u66F4\u5C0F\u7684 (1, 256) x (256, 256) \u77E9\u9635\u4E58\u6CD5\uFF0C\u4F7F\u5F97\u4E2D\u95F4\u5F20\u91CF\u53EF\u4EE5\u9002\u5408\u52A0\u901F\u5668\u7684\u82AF\u7247\u4E0A SRAM\u3002\u8FD9\u79CD\u65B9\u6CD5\u7C7B\u4F3C\u4E8E\u4E3A\u63D0\u9AD8\u7F13\u5B58\u547D\u4E2D\u7387\uFF0C\u5E94\u7528\u4E8E CPU \u548C GPU \u7684\u5206\u5757\u6280\u672F\u3002"}),"\n",(0,r.jsx)(e.p,{children:"\u6CBF\u6BCF\u4E2A\u8F74\u6267\u884C\u5206\u5757\uFF08\u7531\u4E8E\u6B63\u5728\u6267\u884C\u5355\u4E2A batch \u63A8\u7406\uFF0Cbatch \u8F74\u672A\u88AB\u5904\u7406\uFF09\u3002\u8FD8\u5C06\u6700\u91CC\u9762\u7684\u5F20\u91CF\u8F74\u4FDD\u6301\u539F\u6837\uFF0C\u4F7F\u5F97 TVM \u6A21\u5F0F\u5339\u914D\u5F20\u91CF\u3002\u4E0B\u56FE\u5C55\u793A\u4E86\u8BA1\u7B97\u8C03\u5EA6\u4E0A\u7684\u5206\u5757\u7ED3\u679C\uFF1A"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{alt:"/img/docs/uwsampl/web-data/main/vta/tutorial/blocking.png",src:t(89013).Z+"",width:"1548",height:"1468"})}),"\n",(0,r.jsxs)(e.admonition,{type:"note",children:[(0,r.jsx)(e.p,{children:"\u5FAA\u73AF\u62C6\u5206\u548C\u91CD\u65B0\u6392\u5E8F\u540E\u7684\u4EE3\u7801\u7B49\u4EF7\u4E8E\u4EE5\u4E0B\u4F2A\u4EE3\u7801\u3002\u7531\u4E8E\u4EE5\u4E0B\u793A\u4F8B\u53EA\u6267\u884C\u5355\u4E2A batch \u63A8\u7406\uFF0C\u56E0\u6B64\u5C06\u5FFD\u7565 batch \u8F74\uFF1A"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"for (int oc_out = 0; oc_out < 4; ++oc_out) {\n  // Initialization loop\n  // \u521D\u59CB\u5316\u5FAA\u73AF\n  for (int oc_inn = 0; oc_inn < 16; ++oc_inn) {\n   for (int oc_tns = 0; oc_tns < 16; ++oc_tns) {\n    int j = (oc_out * 16 + oc_inn) * 16 + oc_tns;\n    C[0][j] = 0;\n   }\n  }\n  for (int ic_out = 0; ic_out < 4; ++ic_out) {\n   // Block loop\n   // \u5757\u5FAA\u73AF\n   for (int oc_inn = 0; oc_inn < 16; ++oc_inn) {\n    for (int ic_inn = 0; ic_inn < 16; ++ic_inn) {\n     // Tensorization loop\n     // \u5F20\u91CF\u5FAA\u73AF\n     for (int oc_tns = 0; oc_tns < 16; ++oc_tns) {\n      for (int ic_tns = 0; ic_tns < 16; ++ic_tns) {\n       int i = (ic_out * 16 + ic_inn) * 16 + ic_tns;\n       int j = (oc_out * 16 + oc_inn) * 16 + oc_tns;\n       C[0][i] = C[0][i] + A[0][i] * B[j][i];\n      }\n     }\n    }\n   }\n  }\n }\n}\n"})})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# \u5B9A\u4E49\u5E73\u94FA\u5927\u5C0F\uFF08\u7528 VTA \u5F20\u91CF shape \u5927\u5C0F\u7684\u500D\u6570\u8868\u793A\uFF09\nb_block = 1 // env.BATCH\ni_block = 256 // env.BLOCK_IN\no_block = 256 // env.BLOCK_OUT\n\n# \u6CBF\u7A7A\u95F4\u548C\u8F93\u51FA\u901A\u9053\u7EF4\u5EA6\u5E73\u94FA\u8F93\u51FA\u5F20\u91CF\n# \uFF08\u56E0\u4E3A\u9ED8\u8BA4\u8FDB\u884C\u5355\u4E2A batch \u63A8\u7406\uFF0C\u6CBF batch \u7EF4\u5EA6\u7684\u62C6\u5206\u6CA1\u6709\u6548\u679C\uFF09\nb, oc, b_tns, oc_tns = s[res].op.axis\nb_out, b_inn = s[res].split(b, b_block)\noc_out, oc_inn = s[res].split(oc, o_block)\ns[res].reorder(b_out, oc_out, b_inn, oc_inn)\n\n# \u5C06\u4E2D\u95F4\u8BA1\u7B97\u79FB\u52A8\u5230\u6BCF\u4E2A\u8F93\u51FA\u8BA1\u7B97\u5757\u4E2D\ns[res_gemm].compute_at(s[res], oc_out)\ns[res_shr].compute_at(s[res], oc_out)\ns[res_max].compute_at(s[res], oc_out)\ns[res_min].compute_at(s[res], oc_out)\n\n# \u6CBF reduction \u8F74\uFF08\u8F93\u5165\u901A\u9053\uFF09\u5E94\u7528\u989D\u5916\u7684\u5FAA\u73AF\u5206\u5272\nb_inn, oc_inn, b_tns, oc_tns = s[res_gemm].op.axis\nic_out, ic_inn = s[res_gemm].split(ic, i_block)\n\n# \u5BF9\u8F74\u91CD\u65B0\u6392\u5E8F\u3002\u5C06 ic_out \u8F74\u79FB\u51FA\u5377\u79EF\u5FAA\u73AF\uFF0C\u6CBF reduction \u8F74\u963B\u585E\u3002\ns[res_gemm].reorder(ic_out, b_inn, oc_inn, ic_inn, b_tns, oc_tns, ic_tns)\n\n# \u67E5\u770B\u963B\u585E\u540E\u7684\u5F53\u524D TVM schedule\nprint(tvm.lower(s, [data, weight, res], simple_mode=True))\n"})}),"\n",(0,r.jsx)(e.p,{children:"\u8F93\u51FA\u7ED3\u679C\uFF1A"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'@main = primfn(data_1: handle, weight_1: handle, res_1: handle) -> ()\n  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}\n  buffers = {data: Buffer(data_2: Pointer(int8), int8, [1024], []),\n             weight: Buffer(weight_2: Pointer(int8), int8, [1048576], []),\n             res: Buffer(res_2: Pointer(int8), int8, [1024], [])}\n  buffer_map = {data_1: data, weight_1: weight, res_1: res}\n  preflattened_buffer_map = {data_1: data_3: Buffer(data_2, int8, [1, 64, 1, 16], []), weight_1: weight_3: Buffer(weight_2, int8, [64, 64, 16, 16], []), res_1: res_3: Buffer(res_2, int8, [1, 64, 1, 16], [])} {\n  allocate(data_buf: Pointer(global int8), int8, [1024]), storage_scope = global;\n  allocate(weight_buf: Pointer(global int8), int8, [1048576]), storage_scope = global;\n  allocate(res_gem: Pointer(global int32), int32, [256]), storage_scope = global {\n    for (i1: int32, 0, 64) {\n      for (i3: int32, 0, 16) {\n        let cse_var_1: int32 = ((i1*16) + i3)\n        data_buf_1: Buffer(data_buf, int8, [1024], [])[cse_var_1] = data[cse_var_1]\n      }\n    }\n    for (i0: int32, 0, 64) {\n      for (i1_1: int32, 0, 64) {\n        for (i2: int32, 0, 16) {\n          for (i3_1: int32, 0, 16) {\n            let cse_var_2: int32 = ((((i0*16384) + (i1_1*256)) + (i2*16)) + i3_1)\n            weight_buf_1: Buffer(weight_buf, int8, [1048576], [])[cse_var_2] = weight[cse_var_2]\n          }\n        }\n      }\n    }\n    for (i1.outer: int32, 0, 4) {\n      for (co.init: int32, 0, 16) {\n        for (ci.init: int32, 0, 16) {\n          res_gem_1: Buffer(res_gem, int32, [256], [])[((co.init*16) + ci.init)] = 0\n        }\n      }\n      for (ic.outer: int32, 0, 4) {\n        for (co: int32, 0, 16) {\n          for (ic.inner: int32, 0, 16) {\n            for (ci: int32, 0, 16) {\n              for (ic_tns: int32, 0, 16) {\n                let cse_var_3: int32 = ((co*16) + ci)\n                res_gem_1[cse_var_3] = (res_gem_1[cse_var_3] + (cast(int32, data_buf_1[(((ic.outer*256) + (ic.inner*16)) + ic_tns)])*cast(int32, weight_buf_1[((((((i1.outer*262144) + (co*16384)) + (ic.outer*4096)) + (ic.inner*256)) + (ci*16)) + ic_tns)])))\n              }\n            }\n          }\n        }\n      }\n      for (i1_2: int32, 0, 16) {\n        for (i3_2: int32, 0, 16) {\n          let cse_var_4: int32 = ((i1_2*16) + i3_2)\n          res_gem_2: Buffer(res_gem, int32, [256], [])[cse_var_4] = @tir.shift_right(res_gem_1[cse_var_4], 8, dtype=int32)\n        }\n      }\n      for (i1_3: int32, 0, 16) {\n        for (i3_3: int32, 0, 16) {\n          let cse_var_5: int32 = ((i1_3*16) + i3_3)\n          res_gem_3: Buffer(res_gem, int32, [256], [])[cse_var_5] = max(res_gem_2[cse_var_5], 0)\n        }\n      }\n      for (i1_4: int32, 0, 16) {\n        for (i3_4: int32, 0, 16) {\n          let cse_var_6: int32 = ((i1_4*16) + i3_4)\n          res_gem_4: Buffer(res_gem, int32, [256], [])[cse_var_6] = min(res_gem_3[cse_var_6], 127)\n        }\n      }\n      for (i1.inner: int32, 0, 16) {\n        for (i3_5: int32, 0, 16) {\n          let cse_var_7: int32 = (i1.inner*16)\n          res[(((i1.outer*256) + cse_var_7) + i3_5)] = cast(int8, res_gem_4[(cse_var_7 + i3_5)])\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u5C06\u62F7\u8D1D\u964D\u7EA7\u5230-dma-\u4F20\u8F93",children:"\u5C06\u62F7\u8D1D\u964D\u7EA7\u5230 DMA \u4F20\u8F93"}),"\n",(0,r.jsx)(e.p,{children:"\u63A5\u4E0B\u6765\uFF0C\u5C06\u7F13\u51B2\u533A\u8303\u56F4\u8BBE\u7F6E\u4E3A\u76F8\u5E94\u7684\u82AF\u7247 VTA SRAM \u7F13\u51B2\u533A\u3002\u5C06\u52A0\u8F7D\u5FAA\u73AF\u79FB\u52A8\u5230 2D \u5377\u79EF\u8BA1\u7B97\u5FAA\u73AF\u4E2D\uFF0C\u6682\u5B58\u5185\u5B58\u52A0\u8F7D\uFF0C\u4F7F\u5176\u9002\u5408\u82AF\u7247\u4E0A SRAM \u7F13\u51B2\u533A\u3002\u6700\u540E\uFF0C\u7528 DMA \u62F7\u8D1D\u7F16\u8BD1\u6307\u793A\u6765\u6CE8\u91CA\u52A0\u8F7D/\u5B58\u50A8\u5FAA\u73AF\u5916\u8F74\uFF0C\u4ECE\u800C\u5728 VTA \u4E0A\u6267\u884C\u5927\u5BB9\u91CF\u5185\u5B58\u4F20\u8F93\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# \u8BBE\u7F6E SRAM \u7F13\u51B2\u533A\u7684\u8303\u56F4\ns[data_buf].set_scope(env.inp_scope)\ns[weight_buf].set_scope(env.wgt_scope)\ns[res_gemm].set_scope(env.acc_scope)\ns[res_shr].set_scope(env.acc_scope)\ns[res_min].set_scope(env.acc_scope)\ns[res_max].set_scope(env.acc_scope)\n\n# \u5757\u6570\u636E\u548C\u6743\u91CD\u7F13\u5B58\u8BFB\u53D6\ns[data_buf].compute_at(s[res_gemm], ic_out)\ns[weight_buf].compute_at(s[res_gemm], ic_out)\n\n# \u7528 DMA \u62F7\u8D1D\u7F16\u8BD1\u6307\u793A\u64CD\u4F5C DRAM->SRAM\ns[data_buf].pragma(s[data_buf].op.axis[0], env.dma_copy)\ns[weight_buf].pragma(s[weight_buf].op.axis[0], env.dma_copy)\n\n# \u5728 SRAM->DRAM \u64CD\u4F5C\u4E0A\uFF0C\u4F7F\u7528 DMA \u62F7\u8D1D\u7F16\u8BD1\u6307\u793A\uFF08\u8FD9\u610F\u5473\u7740\u8FD9\u4E9B\u62F7\u8D1D\u5E94\u6CBF b_inn \u6216\u7ED3\u679C\u8F74 2 \u6267\u884C\uFF09\ns[res].pragma(s[res].op.axis[2], env.dma_copy)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"\u5C06\u8BA1\u7B97\u964D\u7EA7\u5230-vta-\u8BA1\u7B97\u5185\u8054\u51FD\u6570",children:"\u5C06\u8BA1\u7B97\u964D\u7EA7\u5230 VTA \u8BA1\u7B97\u5185\u8054\u51FD\u6570"}),"\n",(0,r.jsx)(e.p,{children:"\u6700\u540E\u4E00\u4E2A\u9636\u6BB5\u662F\u964D\u7EA7\u8BA1\u7B97\u5FAA\u73AF\u5230 VTA \u786C\u4EF6\u5185\u8054\u51FD\u6570\uFF0C\u8FD9\u662F\u901A\u8FC7\u5C06 2D \u5377\u79EF\u6620\u5C04\u5230\u5F20\u91CF\u5185\u8054\u51FD\u6570\uFF0C\u5E76\u5C06\u79FB\u4F4D\u548C\u88C1\u526A\u8BA1\u7B97\u6620\u5C04\u5230\u5411\u91CF ALU \u5B9E\u73B0\u7684\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# \u5728 batch \u5F20\u91CF\u5E73\u94FA\u8F74\u4E0A\u5E94\u7528\u5F20\u91CF\u5316\ns[res_gemm].tensorize(b_tns, env.gemm)\n\n# \u5728\u79FB\u4F4D\u548C\u88C1\u526A\u64CD\u4F5C\u4E0A\u6DFB\u52A0 ALU \u7F16\u8BD1\u6307\u793A\ns[res_shr].pragma(s[res_shr].op.axis[0], env.alu)\ns[res_min].pragma(s[res_min].op.axis[0], env.alu)\ns[res_max].pragma(s[res_max].op.axis[0], env.alu)\n\n# \u5C06\u5185\u5B58\u8D1F\u8F7D/\u5B58\u50A8\u964D\u7EA7\u4E3A DMA \u62F7\u8D1D\u5185\u8054\u51FD\u6570\uFF0C\u5E76\u5C06\u8BA1\u7B97\u964D\u7EA7\u4E3A VTA \u8BA1\u7B97\u5185\u8054\u51FD\u6570\u540E\uFF0C\u67E5\u770B\u6700\u7EC8\u964D\u4F4E\u7684 TVM schedule\u3002\nprint(vta.lower(s, [data, weight, res], simple_mode=True))\n"})}),"\n",(0,r.jsx)(e.p,{children:"\u8F93\u51FA\u7ED3\u679C\uFF1A"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'@main = primfn(data_1: handle, weight_1: handle, res_1: handle) -> ()\n  attr = {"from_legacy_te_schedule": True, "global_symbol": "main", "tir.noalias": True}\n  buffers = {data: Buffer(data_2: Pointer(int8), int8, [1024], []),\n             weight: Buffer(weight_2: Pointer(int8), int8, [1048576], []),\n             res: Buffer(res_2: Pointer(int8), int8, [1024], [])}\n  buffer_map = {data_1: data, weight_1: weight, res_1: res}\n  preflattened_buffer_map = {data_1: data_3: Buffer(data_2, int8, [1, 64, 1, 16], []), weight_1: weight_3: Buffer(weight_2, int8, [64, 64, 16, 16], []), res_1: res_3: Buffer(res_2, int8, [1, 64, 1, 16], [])} {\n  @tir.vta.coproc_dep_push(3, 2, dtype=int32)\n  for (i1.outer: int32, 0, 4) {\n    attr [IterVar(vta: int32, (nullptr), "ThreadIndex", "vta")] "coproc_scope" = 2 {\n      @tir.vta.coproc_dep_pop(3, 2, dtype=int32)\n      attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_uop_scope" = "VTAPushGEMMOp" {\n        @tir.call_extern("VTAUopLoopBegin", 16, 1, 0, 0, dtype=int32)\n        @tir.vta.uop_push(0, 1, 0, 0, 0, 0, 0, 0, dtype=int32)\n        @tir.call_extern("VTAUopLoopEnd", dtype=int32)\n      }\n      @tir.vta.coproc_dep_push(2, 1, dtype=int32)\n    }\n    for (ic.outer: int32, 0, 4) {\n      let cse_var_1: int32 = (ic.outer*16)\n       {\n        attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_scope" = 1 {\n          @tir.vta.coproc_dep_pop(2, 1, dtype=int32)\n          @tir.call_extern("VTALoadBuffer2D", @tir.tvm_thread_context(@tir.vta.command_handle(, dtype=handle), dtype=handle), data_2, cse_var_1, 16, 1, 16, 0, 0, 0, 0, 0, 2, dtype=int32)\n          @tir.call_extern("VTALoadBuffer2D", @tir.tvm_thread_context(@tir.vta.command_handle(, dtype=handle), dtype=handle), weight_2, ((i1.outer*1024) + cse_var_1), 16, 16, 64, 0, 0, 0, 0, 0, 1, dtype=int32)\n          @tir.vta.coproc_dep_push(1, 2, dtype=int32)\n        }\n        attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_scope" = 2 {\n          @tir.vta.coproc_dep_pop(1, 2, dtype=int32)\n          attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_uop_scope" = "VTAPushGEMMOp" {\n            @tir.call_extern("VTAUopLoopBegin", 16, 1, 0, 16, dtype=int32)\n            @tir.call_extern("VTAUopLoopBegin", 16, 0, 1, 1, dtype=int32)\n            @tir.vta.uop_push(0, 0, 0, 0, 0, 0, 0, 0, dtype=int32)\n            @tir.call_extern("VTAUopLoopEnd", dtype=int32)\n            @tir.call_extern("VTAUopLoopEnd", dtype=int32)\n          }\n          @tir.vta.coproc_dep_push(2, 1, dtype=int32)\n        }\n      }\n    }\n    @tir.vta.coproc_dep_pop(2, 1, dtype=int32)\n    attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_scope" = 2 {\n      attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_uop_scope" = "VTAPushALUOp" {\n        @tir.call_extern("VTAUopLoopBegin", 16, 1, 1, 0, dtype=int32)\n        @tir.vta.uop_push(1, 0, 0, 0, 0, 3, 1, 8, dtype=int32)\n        @tir.call_extern("VTAUopLoopEnd", dtype=int32)\n      }\n      attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_uop_scope" = "VTAPushALUOp" {\n        @tir.call_extern("VTAUopLoopBegin", 16, 1, 1, 0, dtype=int32)\n        @tir.vta.uop_push(1, 0, 0, 0, 0, 1, 1, 0, dtype=int32)\n        @tir.call_extern("VTAUopLoopEnd", dtype=int32)\n      }\n      attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_uop_scope" = "VTAPushALUOp" {\n        @tir.call_extern("VTAUopLoopBegin", 16, 1, 1, 0, dtype=int32)\n        @tir.vta.uop_push(1, 0, 0, 0, 0, 0, 1, 127, dtype=int32)\n        @tir.call_extern("VTAUopLoopEnd", dtype=int32)\n      }\n      @tir.vta.coproc_dep_push(2, 3, dtype=int32)\n    }\n    attr [IterVar(vta, (nullptr), "ThreadIndex", "vta")] "coproc_scope" = 3 {\n      @tir.vta.coproc_dep_pop(2, 3, dtype=int32)\n      for (i1.inner: int32, 0, 16) {\n        @tir.call_extern("VTAStoreBuffer2D", @tir.tvm_thread_context(@tir.vta.command_handle(, dtype=handle), dtype=handle), i1.inner, 4, res_2, ((i1.outer*16) + i1.inner), 1, 1, 1, dtype=int32)\n      }\n      @tir.vta.coproc_dep_push(3, 2, dtype=int32)\n    }\n  }\n  @tir.vta.coproc_sync(, dtype=int32)\n  @tir.vta.coproc_dep_pop(3, 2, dtype=int32)\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"tvm-\u7F16\u8BD1\u548C\u9A8C\u8BC1",children:"TVM \u7F16\u8BD1\u548C\u9A8C\u8BC1"}),"\n",(0,r.jsx)(e.p,{children:"\u6307\u5B9A schedule \u540E\uFF0C\u53EF\u4EE5\u5C06\u5176\u7F16\u8BD1\u4E3A TVM \u51FD\u6570\u3002\u4FDD\u5B58\u6A21\u5757\uFF0C\u7136\u540E\u53EF\u4EE5\u901A\u8FC7 RPC \u53D1\u9001\u3002\u8FD0\u884C\u8FD9\u4E2A\u51FD\u6570\uFF0C\u5E76\u6839\u636E numpy \u5B9E\u73B0\u5BF9\u5176\u8FDB\u884C\u9A8C\u8BC1\uFF0C\u4EE5\u786E\u4FDD\u6B63\u786E\u6027\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# \u7F16\u8BD1 TVM \u6A21\u5757\nmy_gemm = vta.build(\n    s, [data, weight, res], tvm.target.Target("ext_dev", host=env.target_host), name="my_gemm"\n)\ntemp = utils.tempdir()\nmy_gemm.save(temp.relpath("gemm.o"))\nremote.upload(temp.relpath("gemm.o"))\nf = remote.load_module("gemm.o")\n\n# \u83B7\u53D6\u8FDC\u7A0B\u8BBE\u5907\u4E0A\u4E0B\u6587\nctx = remote.ext_dev(0)\n\n# \u5728 (-128, 128] \u7684 int \u8303\u56F4\u5185\u968F\u673A\u521D\u59CB\u5316\u6570\u636E\u548C\u6743\u91CD\u6570\u7EC4\ndata_np = np.random.randint(-128, 128, size=(batch_size, in_channels)).astype(data.dtype)\nweight_np = np.random.randint(-128, 128, size=(out_channels, in_channels)).astype(weight.dtype)\n\n# \u5C06\u6570\u636E\u548C\u6743\u91CD\u6570\u7EC4\u4ECE 2D \u6253\u5305\u4E3A 4D \u6253\u5305\u5E03\u5C40\ndata_packed = data_np.reshape(\n    batch_size // env.BATCH, env.BATCH, in_channels // env.BLOCK_IN, env.BLOCK_IN\n).transpose((0, 2, 1, 3))\nweight_packed = weight_np.reshape(\n    out_channels // env.BLOCK_OUT, env.BLOCK_OUT, in_channels // env.BLOCK_IN, env.BLOCK_IN\n).transpose((0, 2, 1, 3))\n\n# \u7528 tvm.nd.array \u5C06\u8F93\u5165/\u8F93\u51FA\u6570\u7EC4\u683C\u5F0F\u5316\u4E3A DLPack \u6807\u51C6\ndata_nd = tvm.nd.array(data_packed, ctx)\nweight_nd = tvm.nd.array(weight_packed, ctx)\nres_nd = tvm.nd.array(np.zeros(output_shape).astype(res.dtype), ctx)\n\n# \u6E05\u9664\u7EDF\u8BA1\nif env.TARGET in ["sim", "tsim"]:\n    simulator.clear_stats()\n\n# \u8C03\u7528\u6A21\u5757\u8FDB\u884C\u8BA1\u7B97\nf(data_nd, weight_nd, res_nd)\n\n# \u9488\u5BF9 numpy \u5B9E\u73B0\u8FDB\u884C\u9A8C\u8BC1\nres_ref = np.dot(data_np.astype(env.acc_dtype), weight_np.T.astype(env.acc_dtype))\nres_ref = res_ref >> env.INP_WIDTH\nres_ref = np.clip(res_ref, 0, inp_max)\nres_ref = res_ref.astype(res.dtype)\nres_ref = res_ref.reshape(\n    batch_size // env.BATCH, env.BATCH, out_channels // env.BLOCK_OUT, env.BLOCK_OUT\n).transpose((0, 2, 1, 3))\nnp.testing.assert_equal(res_ref, res_nd.numpy())\n\n# \u6253\u5370\u7EDF\u8BA1\nif env.TARGET in ["sim", "tsim"]:\n    sim_stats = simulator.stats()\n    print("Execution statistics:")\n    for k, v in sim_stats.items():\n        print("\\t{:<16}: {:>16}".format(k, v))\n\nprint("Successful blocked matrix multiply test!")\n'})}),"\n",(0,r.jsx)(e.p,{children:"\u8F93\u51FA\u7ED3\u679C\uFF1A"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'/workspace/python/tvm/driver/build_module.py:267: UserWarning: target_host parameter is going to be deprecated. Please pass in tvm.target.Target(target, host=target_host) instead.\n  "target_host parameter is going to be deprecated. "\nExecution statistics:\n        inp_load_nbytes :             4096\n        wgt_load_nbytes :          1048576\n        acc_load_nbytes :                0\n        uop_load_nbytes :               20\n        out_store_nbytes:             1024\n        gemm_counter    :             4096\n        alu_counter     :              192\nSuccessful blocked matrix multiply test!\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u603B\u7ED3",children:"\u603B\u7ED3"}),"\n",(0,r.jsx)(e.p,{children:"\u672C\u6559\u7A0B\u6F14\u793A\u4E86 TVM \u8C03\u5EA6\u539F\u8BED\u5982\u4F55\u5B9E\u73B0\u77E9\u9635\u4E58\u6CD5\u793A\u4F8B\u7684\u8BA1\u7B97\u5206\u5757\uFF0C\u8FDB\u800C\u80FD\u591F\u5C06\u4EFB\u610F\u5927\u7684\u8BA1\u7B97\u6620\u5C04\u5230\u6709\u9650\u7684\u786C\u4EF6\u52A0\u901F\u5668\u8D44\u6E90\u4E0A\u3002"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://tvm.apache.org/docs/_downloads/822e9d945c0bbf1cf23fc4f53c1b7906/matrix_multiply_opt.py",children:"\u4E0B\u8F7D Python \u6E90\u4EE3\u7801\uFF1Amatrix_multiply_opt.py"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://tvm.apache.org/docs/_downloads/4d3f955a709b320db0d42740fead8ac1/matrix_multiply_opt.ipynb",children:"\u4E0B\u8F7D Jupyter Notebook\uFF1Amatrix_multiply_opt.ipynb"})})]})}function l(n={}){let{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}},89013:function(n,e,t){t.d(e,{Z:function(){return i}});let i=t.p+"assets/images/blocking-cda6431848800fc6968f03c39d4857d1.png"},8630:function(n,e,t){t.d(e,{Z:function(){return i}});let i=t.p+"assets/images/fc_dataflow-75b6dfca085e6b73b7e77f1572735ea6.png"},21494:function(n,e,t){t.d(e,{Z:function(){return _},a:function(){return s}});var i=t(39546);let r={},a=i.createContext(r);function s(n){let e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function _(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);