"use strict";(self.webpackChunktvm_cn=self.webpackChunktvm_cn||[]).push([["97090"],{44068:function(e,n,r){r.r(n),r.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>i,assets:()=>a,toc:()=>c,contentTitle:()=>d});var i=JSON.parse('{"id":"reference/langref/hybrid_script","title":"Hybrid Frontend Language Reference","description":"Overview","source":"@site/versioned_docs/version-0.12.0/reference/langref/hybrid_script.md","sourceDirName":"reference/langref","slug":"/reference/langref/hybrid_script","permalink":"/docs/tvm-cn/docs/0.12.0/reference/langref/hybrid_script","draft":false,"unlisted":false,"editUrl":"https://github.com/hyperai/tvm-cn/edit/master/versioned_docs/version-0.12.0/reference/langref/hybrid_script.md","tags":[],"version":"0.12.0","lastUpdatedBy":"sparanoid","lastUpdatedAt":1744717810000,"frontMatter":{"title":"Hybrid Frontend Language Reference"}}'),s=r("74132"),t=r("21494");let o={title:"Hybrid Frontend Language Reference"},d=void 0,a={},c=[{value:"Overview",id:"overview",level:2},{value:"Features",id:"features",level:2},{value:"Software Emulation",id:"software-emulation",level:3},{value:"Backend Compilation",id:"backend-compilation",level:3},{value:"Tuning",id:"tuning",level:3},{value:"Loops",id:"loops",level:3},{value:"Variables",id:"variables",level:3},{value:"Attributes",id:"attributes",level:3},{value:"Conditional Statement and Expression",id:"conditional-statement-and-expression",level:3},{value:"Math Intrinsics",id:"math-intrinsics",level:3},{value:"Array Allocation",id:"array-allocation",level:3},{value:"Thread Bind",id:"thread-bind",level:3},{value:"Assert Statement",id:"assert-statement",level:3},{value:"Keywords",id:"keywords",level:3}];function l(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This hybrid frontend allows users to write preliminary versions of some\nidioms that yet have been supported by TVM officially."}),"\n",(0,s.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,s.jsx)(n.h3,{id:"software-emulation",children:"Software Emulation"}),"\n",(0,s.jsxs)(n.p,{children:["Both software emulation and compilation are supported. To define a\nfunction, you need to use ",(0,s.jsx)(n.code,{children:"tvm.te.hybrid.script"})," decorator to indicate\nthis is a hybrid function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@tvm.te.hybrid.script\ndef outer_product(a, b):\n    c = output_tensor((100, 99), 'float32')\n    for i in range(a.shape[0]):\n        for j in range(b.shape[0]):\n            c[i, j] = a[i] * b[j]\n    return c\na = numpy.random.randn(100)\nb = numpy.random.randn(99)\nc = outer_product(a, b)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This decorator will import ",(0,s.jsx)(n.a,{href:"#keywords",children:"Keywords"})," required spontaneously\nwhen software emulation. After software emulation is done, the imported\nkeywords will be cleaned up. Users do not need worry about keyword\nconflict and pollution."]}),"\n",(0,s.jsxs)(n.p,{children:["Every element passed for software emulation in the argument list is\neither a python variable or ",(0,s.jsx)(n.code,{children:"numpy"})," numeric type."]}),"\n",(0,s.jsx)(n.h3,{id:"backend-compilation",children:"Backend Compilation"}),"\n",(0,s.jsx)(n.p,{children:"This function is not encouraged to use, users are encouraged to use the\nsecond interface. The current parse interface looks like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"a = tvm.te.placeholder((100, ), name='a')\nb = tvm.te.placeholder((99, ), name='b')\nparser = tvm.hybrid.parse(outer_product, [a, b]) # return the parser of this function\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we pass these tvm data structures, like ",(0,s.jsx)(n.code,{children:"Tensor"}),", ",(0,s.jsx)(n.code,{children:"Var"}),", ",(0,s.jsx)(n.code,{children:"Expr.*Imm"}),",\nor ",(0,s.jsx)(n.code,{children:"tvm.container.Array"}),", to this function, it returns a op node:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"a = tvm.te.placeholder((100, ), name='a')\nb = tvm.te.placeholder((99, ), name='b')\nc = outer_product(a, b) # return the output tensor(s) of the operator\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can use any methods that can be applied on a TVM ",(0,s.jsx)(n.code,{children:"OpNode"}),", like\ncreate_schedule, although so far, the functionality of schedule is as\nlimited as ",(0,s.jsx)(n.code,{children:"ExternOpNode"}),". At least, it can be built to LLVM module."]}),"\n",(0,s.jsx)(n.h3,{id:"tuning",children:"Tuning"}),"\n",(0,s.jsx)(n.p,{children:"Follow up the example above, you can use some tvm like interfaces to\ntune the code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"i, j = c.op.axis\nsch = te.create_schedule(op)\njo, ji = sch.split(j, 4)\nsch.vectorize(ji)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For now, you can use loop annotations (",(0,s.jsx)(n.code,{children:"unroll"}),", ",(0,s.jsx)(n.code,{children:"parallel"}),",\n",(0,s.jsx)(n.code,{children:"vectorize"}),", and ",(0,s.jsx)(n.code,{children:"bind"}),"), loop manipulation (",(0,s.jsx)(n.code,{children:"split"})," and ",(0,s.jsx)(n.code,{children:"fuse"}),"), and\n",(0,s.jsx)(n.code,{children:"reorder"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"::: note\n::: title\nNote\n:::"}),"\n",(0,s.jsx)(n.p,{children:"This is a preliminary function, so users should be in charge of the\ncorrectness of the functionality after tuning. Specifically, users\nshould be careful when fusing and reorderding imperfect loops.\n:::"}),"\n",(0,s.jsx)(n.h3,{id:"loops",children:"Loops"}),"\n",(0,s.jsxs)(n.p,{children:["In HalideIR, loops have in total 4 types: ",(0,s.jsx)(n.code,{children:"serial"}),", ",(0,s.jsx)(n.code,{children:"unrolled"}),",\n",(0,s.jsx)(n.code,{children:"parallel"}),", and ",(0,s.jsx)(n.code,{children:"vectorized"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Here we use ",(0,s.jsx)(n.code,{children:"range"})," aka ",(0,s.jsx)(n.code,{children:"serial"}),", ",(0,s.jsx)(n.code,{children:"unroll"}),", ",(0,s.jsx)(n.code,{children:"parallel"}),", and ",(0,s.jsx)(n.code,{children:"vectorize"}),",\nthese ",(0,s.jsx)(n.strong,{children:"4"})," keywords to annotate the corresponding types of for loops.\nThe the usage is roughly the same as Python standard ",(0,s.jsx)(n.code,{children:"range"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Besides all the loop types supported in Halide, ",(0,s.jsx)(n.code,{children:"const_range"})," is\nsupported for some specific conditions. Sometimes, ",(0,s.jsx)(n.code,{children:"tvm.container.Array"}),"\nis desired to pass as an argument, but in TVM-HalideIR, there is no such\nsupport that converts ",(0,s.jsx)(n.code,{children:"tvm.container.Array"})," to an ",(0,s.jsx)(n.code,{children:"Expr"}),". Thus, a\nlimited feature is supported. Users can access containers by either\nconstants or constants loops annotated."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"@tvm.te.hybrid.script\ndef foo(a, b): # b is a tvm.container.Array\n    c = output_tensor(a.shape, a.dtype)\n    for i in const_range(len(a)): # because you have b access, i should be explicitly annotated as const_range\n        c[i] = a[i] + b[i]\n    return c\n"})}),"\n",(0,s.jsx)(n.h3,{id:"variables",children:"Variables"}),"\n",(0,s.jsx)(n.p,{children:"All the mutable variables will be lowered to an array with size 1. It\nregards the first store of a variable as its declaration."}),"\n",(0,s.jsx)(n.p,{children:"::: note\n::: title\nNote\n:::"}),"\n",(0,s.jsx)(n.p,{children:"Unlike conventional Python, in hybrid script, the declared variable can\nonly be used in the scope level it is declared.\n:::"}),"\n",(0,s.jsx)(n.p,{children:"::: note\n::: title\nNote\n:::"}),"\n",(0,s.jsxs)(n.p,{children:["Currently, you can ONLY use basic-typed variables, i.e. the type of the\nvariable should be either ",(0,s.jsx)(n.code,{children:"float32"}),", or ",(0,s.jsx)(n.code,{children:"int32"}),".\n:::"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"for i in range(5):\n    s = 0 # declaration, this s will be a 1-array in lowered IR\n    for j in range(5):\n      s += a[i, j] # do something with s\n    b[i] = s # you can still use s in this level\na[0] = s # you CANNOT use s here, even though it is allowed in conventional Python\n"})}),"\n",(0,s.jsx)(n.h3,{id:"attributes",children:"Attributes"}),"\n",(0,s.jsxs)(n.p,{children:["So far, ONLY tensors' ",(0,s.jsx)(n.code,{children:"shape"})," and ",(0,s.jsx)(n.code,{children:"dtype"})," attribute are supported! The\n",(0,s.jsx)(n.code,{children:"shape"})," attribute is essentially a tuple, so you MUST access it as an\narray. Currently, only constant-indexed access is supported."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"x = a.shape[2] # OK!\nfor i in range(3):\n   for j in a.shape[i]: # BAD! i is not a constant!\n       # do something\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conditional-statement-and-expression",children:"Conditional Statement and Expression"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"if condition1 and condition2 and condition3:\n    # do something\nelse:\n    # do something else\n# Select\na = b if condition else c\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, NO ",(0,s.jsx)(n.code,{children:"True"})," and ",(0,s.jsx)(n.code,{children:"False"})," keyword supported yet."]}),"\n",(0,s.jsx)(n.h3,{id:"math-intrinsics",children:"Math Intrinsics"}),"\n",(0,s.jsxs)(n.p,{children:["So far, these math intrinsics, ",(0,s.jsx)(n.code,{children:"log"}),", ",(0,s.jsx)(n.code,{children:"exp"}),", ",(0,s.jsx)(n.code,{children:"sigmoid"}),", ",(0,s.jsx)(n.code,{children:"tanh"}),", ",(0,s.jsx)(n.code,{children:"power"}),",\nand ",(0,s.jsx)(n.code,{children:"popcount"}),", are supported. No import is required, just as it is\nmentioned in ",(0,s.jsx)(n.a,{href:"#software-emulation",children:"Software Emulation"}),", just use it!"]}),"\n",(0,s.jsx)(n.h3,{id:"array-allocation",children:"Array Allocation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Under construction, this function will be supported later!"})}),"\n",(0,s.jsxs)(n.p,{children:["Use a function call ",(0,s.jsx)(n.code,{children:"allocation(shape, type, share/local)"})," to declare an\narray buffer. The basic usage is roughly the same as a normal\n",(0,s.jsx)(n.code,{children:"numpy.array"}),", and you should access high-dim array in ",(0,s.jsx)(n.code,{children:"a[i, j, k]"}),"\nfashion instead of ",(0,s.jsx)(n.code,{children:"a[i][j][k]"}),", even for ",(0,s.jsx)(n.code,{children:"tvm.container.Array"})," for\ncompilation."]}),"\n",(0,s.jsx)(n.h3,{id:"thread-bind",children:"Thread Bind"}),"\n",(0,s.jsx)(n.p,{children:"You can also do loop-thread bind by writing code like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'for tx in bind("threadIdx.x", 100):\n    a[tx] = b[tx]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"assert-statement",children:"Assert Statement"}),"\n",(0,s.jsx)(n.p,{children:"Assert statement is supported, you can simply use it as it is in\nstandard Python."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"assert cond, mesg\n"})}),"\n",(0,s.jsx)(n.p,{children:"::: note\n::: title\nNote\n:::"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Assert"})," is NOT a function call. Users are encouraged to use assert in\nthe way presented above --- condition followed by message. It fits\nboth Python AST and HalideIR.\n:::"]}),"\n",(0,s.jsx)(n.h3,{id:"keywords",children:"Keywords"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For keywords: ",(0,s.jsx)(n.code,{children:"serial"}),", ",(0,s.jsx)(n.code,{children:"range"}),", ",(0,s.jsx)(n.code,{children:"unroll"}),", ",(0,s.jsx)(n.code,{children:"parallel"}),", ",(0,s.jsx)(n.code,{children:"vectorize"}),",\n",(0,s.jsx)(n.code,{children:"bind"}),", ",(0,s.jsx)(n.code,{children:"const_range"})]}),"\n",(0,s.jsxs)(n.li,{children:["Math keywords: ",(0,s.jsx)(n.code,{children:"log"}),", ",(0,s.jsx)(n.code,{children:"exp"}),", ",(0,s.jsx)(n.code,{children:"sqrt"}),", ",(0,s.jsx)(n.code,{children:"rsqrt"}),", ",(0,s.jsx)(n.code,{children:"sigmoid"}),", ",(0,s.jsx)(n.code,{children:"tanh"}),",\n",(0,s.jsx)(n.code,{children:"power"}),", ",(0,s.jsx)(n.code,{children:"popcount"}),", ",(0,s.jsx)(n.code,{children:"round"}),", ",(0,s.jsx)(n.code,{children:"ceil_div"})]}),"\n",(0,s.jsxs)(n.li,{children:["Allocate keywords: ",(0,s.jsx)(n.code,{children:"allocate"}),", ",(0,s.jsx)(n.code,{children:"output_tensor"})]}),"\n",(0,s.jsxs)(n.li,{children:["Data type keywords: ",(0,s.jsx)(n.code,{children:"uint8"}),", ",(0,s.jsx)(n.code,{children:"uint16"}),", ",(0,s.jsx)(n.code,{children:"uint32"}),", ",(0,s.jsx)(n.code,{children:"uint64"}),", ",(0,s.jsx)(n.code,{children:"int8"}),",\n",(0,s.jsx)(n.code,{children:"int16"}),", ",(0,s.jsx)(n.code,{children:"int32"}),", ",(0,s.jsx)(n.code,{children:"int64"}),", ",(0,s.jsx)(n.code,{children:"float16"}),", ",(0,s.jsx)(n.code,{children:"float32"}),", ",(0,s.jsx)(n.code,{children:"float64"})]}),"\n",(0,s.jsxs)(n.li,{children:["Others: ",(0,s.jsx)(n.code,{children:"max_num_threads"})]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},21494:function(e,n,r){r.d(n,{Z:function(){return d},a:function(){return o}});var i=r(39546);let s={},t=i.createContext(s);function o(e){let n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);