"use strict";(self.webpackChunktvm_cn=self.webpackChunktvm_cn||[]).push([["82673"],{80127:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>a,assets:()=>l,toc:()=>c,contentTitle:()=>r});var a=JSON.parse('{"id":"reference/langref/relay_expr","title":"Expressions in Relay","description":"The Relay IR is a pure, expression-oriented language. The below sections","source":"@site/versioned_docs/version-0.10.0/reference/langref/relay_expr.md","sourceDirName":"reference/langref","slug":"/reference/langref/relay_expr","permalink":"/docs/tvm-cn/docs/0.10.0/reference/langref/relay_expr","draft":false,"unlisted":false,"editUrl":"https://github.com/hyperai/tvm-cn/edit/master/versioned_docs/version-0.10.0/reference/langref/relay_expr.md","tags":[],"version":"0.10.0","lastUpdatedBy":"sparanoid","lastUpdatedAt":1744717810000,"frontMatter":{"title":"Expressions in Relay"}}'),s=t("74132"),i=t("21494");let o={title:"Expressions in Relay"},r=void 0,l={},c=[{value:"Dataflow and Control Fragments",id:"dataflow-and-control-fragments",level:2},{value:"Variables",id:"variables",level:2},{value:"Global Variable",id:"global-variable",level:3},{value:"Local Variable",id:"local-variable",level:3},{value:"Functions",id:"functions",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Closures",id:"closures",level:3},{value:"Polymorphism and Type Relations",id:"polymorphism-and-type-relations",level:3},{value:"Operators",id:"operators",level:2},{value:"ADT Constructors",id:"adt-constructors",level:2},{value:"Call",id:"call",level:2},{value:"Module and Global Functions",id:"module-and-global-functions",level:2},{value:"Constant",id:"constant",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Construction",id:"construction",level:3},{value:"Projection",id:"projection",level:3},{value:"Let Bindings",id:"let-bindings",level:2},{value:"Graph Bindings",id:"graph-bindings",level:2},{value:"If-Then-Else",id:"if-then-else",level:2},{value:"ADT Matching",id:"adt-matching",level:2},{value:"TempExprs",id:"tempexprs",level:2}];function d(e){let n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The Relay IR is a pure, expression-oriented language. The below sections\ndescribe the different expressions in Relay and give details of their\nsemantics."}),"\n",(0,s.jsx)(n.h2,{id:"dataflow-and-control-fragments",children:"Dataflow and Control Fragments"}),"\n",(0,s.jsx)(n.p,{children:"For the purposes of comparing Relay to traditional computational\ngraph-based IRs, it can be useful to consider Relay expressions in terms\nof dataflow and control fragments. Each portion of a Relay program\ncontaining expressions that only affect the dataflow can be viewed as a\ntraditional computation graph when writing and expressing\ntransformations."}),"\n",(0,s.jsx)(n.p,{children:"The dataflow fragment covers the set of Relay expressions that do not\ninvolve control flow. That is, any portion of a program containing only\nthe following constructs corresponds to a pure computation graph:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#variables",children:"Variables"})}),"\n",(0,s.jsxs)(n.li,{children:["Tuple ",(0,s.jsx)(n.a,{href:"#construction",children:"Construction"})," and ",(0,s.jsx)(n.a,{href:"#projection",children:"Projection"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#let-bindings",children:"Let Bindings"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#graph-bindings",children:"Graph Bindings"})}),"\n",(0,s.jsxs)(n.li,{children:["Calls to ",(0,s.jsx)(n.a,{href:"#operators",children:"Operators"})," and ",(0,s.jsx)(n.a,{href:"#adt-constructors",children:"ADT\nConstructors"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Control flow expressions allow the graph topology to change based on the\nvalue of previously executed expressions. The control fragment in Relay\nincludes the following constructs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#if-then-else",children:"If-Then-Else"})," Expressions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#adt-matching",children:"ADT Matching"})," Expressions"]}),"\n",(0,s.jsx)(n.li,{children:"Recursive Calls in Functions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"From the point of view of a computation graph, a function is a subgraph\nand a function call inlines the subgraph, substituting its arguments for\nthe free variables in the subgraph with corresponding names. Thus, if a\nfunction's body uses only dataflow constructs, a call to that function\nis in the dataflow fragment; conversely, if the function's body\ncontains control flow, a call to that function is not part of the\ndataflow fragment."}),"\n",(0,s.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,s.jsxs)(n.p,{children:["Inspired by LLVM, Relay explicitly distinguishes between local and\nglobal variables both in the AST and in the text format. In the text\nformat, global and local variables are distinguished by prefixes, or\n",(0,s.jsx)(n.em,{children:"sigils"}),". Global variables are prefixed with ",(0,s.jsx)(n.code,{children:"@"})," and local variables\nwith ",(0,s.jsx)(n.code,{children:"%"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This explicit distinction makes certain optimizations easier to\nimplement. For example, inlining a global definition requires no\nanalysis: simply substituting the definition suffices."}),"\n",(0,s.jsx)(n.h3,{id:"global-variable",children:"Global Variable"}),"\n",(0,s.jsxs)(n.p,{children:["Global identifiers are prefixed by the ",(0,s.jsx)(n.code,{children:"@"}),' sigil, such as "',(0,s.jsx)(n.code,{children:"@global"}),'".\nA global identifier always references a globally visible definition\ncontained in the globally visible environment, known as the\n',(0,s.jsx)(n.a,{href:"#module-and-global-functions",children:"module"}),". Global identifiers must be\nunique."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"GlobalVar"})," for\nits implementation and documentation."]}),"\n",(0,s.jsx)(n.h3,{id:"local-variable",children:"Local Variable"}),"\n",(0,s.jsxs)(n.p,{children:["Local identifiers are prefixed by the ",(0,s.jsx)(n.code,{children:"%"}),' sigil, such as "',(0,s.jsx)(n.code,{children:"%local"}),'". A\nlocal identifier always references a function argument or a variable\nbound in a ',(0,s.jsx)(n.code,{children:"let"})," expression, and will be scoped to the function where it\nappears or the ",(0,s.jsx)(n.code,{children:"let"})," expression where it is bound, respectively."]}),"\n",(0,s.jsxs)(n.p,{children:["In the below code segment, notice that ",(0,s.jsx)(n.code,{children:"%a"})," is defined twice. This is\npermitted, as in most functional languages; in the scope of the second\n",(0,s.jsx)(n.code,{children:"let"})," expression, the name ",(0,s.jsx)(n.code,{children:"%a"}),' is "shadowed," meaning all references\nto ',(0,s.jsx)(n.code,{children:"%a"})," in the inner scope refer to the later definition, while\nreferences to ",(0,s.jsx)(n.code,{children:"%a"})," in the outer scope continue to refer to the first\none."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %a = 1;\nlet %b = 2 * %a;  // %b = 2\nlet %a = %a + %a; // %a = 2. %a is shadowed\n%a + %b           // has value 2 + 2 = 4\n"})}),"\n",(0,s.jsxs)(n.p,{children:["(Note that in Relay's implementation, each definition of a local\nvariable creates a new ",(0,s.jsx)(n.code,{children:"Var"}),", so a shadowed local variable, despite having the same\nname as one in an outer scope, will be a different object. This allows\nfor comparing local variables by pointer identity with the knowledge\nthat the same local variable object corresponds to a different binding\nsite.)"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Var"})," for its\nimplementation and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.p,{children:"Functions in Relay act similarly to procedures or functions in other\nprogramming languages and serve to generalize the concept of a named\nsubgraph."}),"\n",(0,s.jsxs)(n.p,{children:["Functions are first class in Relay, which means they are expressions\njust like variables, constants, and tuples. Additionally, functions in\nRelay are higher-order, which means that a function can be passed as an\nargument to a function or returned by a function, as function\nexpressions evaluate to closures (see the ",(0,s.jsx)(n.a,{href:"#closures",children:"Closures"}),"\nsubsection), which are values like tensors and tuples."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Function"}),"\nfor the definition and documentation of function nodes."]}),"\n",(0,s.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsxs)(n.p,{children:["A definition minimally consists of the keyword ",(0,s.jsx)(n.code,{children:"fn"}),", an empty set of\nparameters, and a body expression\n(",(0,s.jsx)(n.code,{children:"Expr"}),") contained by\ncurly braces."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn() { body }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A definition may contain any number of parameters. For example, a simple\nfunction that invokes the ",(0,s.jsx)(n.code,{children:"add"})," operator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%x, %y) { add(%x, %y) }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that within the function's body, the parameters are local\nvariables, just like those bound in a ",(0,s.jsx)(n.code,{children:"let"})," expression."]}),"\n",(0,s.jsx)(n.p,{children:"One may also annotate explicit types on functions. For example, we can\nrestrict the above function to only work on certain types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%x : Tensor[(10, 10), float32], %y : Tensor[(10, 10), float32])\n           -> Tensor[(10, 10), float32] {\n    add(%x, %y)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above function only takes arguments of type\n",(0,s.jsx)(n.code,{children:"Tensor[(10, 10), float32]"})," and returns a value of type\n",(0,s.jsx)(n.code,{children:"Tensor[(10, 10), float32]"}),". A function parameter is just a local\nvariable (",(0,s.jsx)(n.code,{children:"LocalVar"}),")\noptionally annotated with a type, written as ",(0,s.jsx)(n.code,{children:"%x : T"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"When the type information is omitted, Relay attempts to infer the most\ngeneral type for the users. This property is known as generalization:\nfor a definition without explicit annotations, Relay attempts to assign\nthe most general type to the parameters and return type based on the\nfunction body and call sites."}),"\n",(0,s.jsxs)(n.p,{children:["A recursive function expression can be defined using a ",(0,s.jsx)(n.code,{children:"let"})," binding, as\nhere:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %fact = fn(%x : Tensor[(10, 10), float32]) -> Tensor[(10, 10), float32] {\n    if (%x == Constant(0, (10, 10), float32)) {\n        Constant(1, (10, 10), float32)\n    } else {\n        %x * %fact(%x - Constant(1, (10, 10), float32))\n    }\n};\n%fact(Constant(10, (10, 10), float32))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"closures",children:"Closures"}),"\n",(0,s.jsx)(n.p,{children:"A function expression evaluates to a closure. Closures are values that\nare represented as a pair of a local environment (storing the values for\nall variables defined outside the scope of the function's body) and the\nfunction itself."}),"\n",(0,s.jsxs)(n.p,{children:["For example, in the below example, the final result will be a tensor of\nzero values because the closure for ",(0,s.jsx)(n.code,{children:"%f"})," stores the value of ",(0,s.jsx)(n.code,{children:"%x"})," at the\npointer where ",(0,s.jsx)(n.code,{children:"%f"})," was defined."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %g = fn() {\n  let %x = Constant(0, (10, 10), float32);\n  // %x is a free variable in the below function\n  fn(%y) { %y * %x }\n};\n// the %x in %g's body is not in scope anymore\n// %f is a closure where %x maps to Constant(0, (10, 10), float32)\nlet %f = %g();\nlet %x = Constant(1, (10, 10), float32);\n%f(%x) // evaluates to Constant(0, (10, 10), float32)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"polymorphism-and-type-relations",children:"Polymorphism and Type Relations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note: type parameter syntax is not yet supported in the text format."})}),"\n",(0,s.jsxs)(n.p,{children:["A function may also be given a set of type parameters, which can be\nsubstituted for specific types at call sites. Functions with type\nparameters are ",(0,s.jsx)(n.em,{children:"type polymorphic"}),"; their return type or the types of\narguments they will accept can vary based on the type arguments given at\ncall sites."]}),"\n",(0,s.jsxs)(n.p,{children:["Type parameters are classified by ",(0,s.jsx)(n.em,{children:"kind"})," and can only appear in parts of\nthe type signature where their kind is appropriate (e.g., type\nparameters of kind ",(0,s.jsx)(n.code,{children:"Shape"})," can only appear where a shape would be\nexpected in a tensor type); for a full discussion, see\n",(0,s.jsx)(n.code,{children:"the documentation on type parameters <type-parameter>"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, one can define a polymorphic identity function for any\nRelay type as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn<t : Type>(%x : t) -> t {\n    %x\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The below definition is also polymorphic, but restricts its arguments to\ntensor types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn<s : Shape, bt : BaseType>(%x : Tensor[s, bt]) {\n    %x\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notice that the return type is omitted and will be inferred."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:'Note: "where" syntax is not yet supported in the text format.'})}),"\n",(0,s.jsx)(n.p,{children:"A function may also be subject to one or more type relations, such as in\nthe following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%x, %y) where Broadcast { add(%x, %y) }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above definition, the types of ",(0,s.jsx)(n.code,{children:"%x"})," and ",(0,s.jsx)(n.code,{children:"%y"})," and the return type\nare subject to the ",(0,s.jsx)(n.code,{children:"Broadcast"})," relation, meaning all three must be\ntensors and their shapes follow the elementwise broadcast relation. As\nwith operators, the definitions of relations are not transparent to\nRelay and they are instead implemented externally in either C++ or\nPython."]}),"\n",(0,s.jsxs)(n.p,{children:["As in the case of ",(0,s.jsx)(n.code,{children:"Broadcast"}),", relations are used to express complicated\nconstraints on types (especially tensor shapes). All function relations\nmust hold at all call sites; type checking is thus treated as a\nconstraint-solving problem. For more detail on type relations and their\nimplementations, please see\n",(0,s.jsx)(n.code,{children:"their section in the documentation on Relay's type system <type-relation>"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,s.jsxs)(n.p,{children:["An operator is a primitive operation, such as ",(0,s.jsx)(n.code,{children:"add"})," or ",(0,s.jsx)(n.code,{children:"conv2d"}),", not\ndefined in the Relay language. Operators are declared in the global\noperator registry in C++. Many common operators are backed by TVM's\nTensor Operator Inventory."]}),"\n",(0,s.jsx)(n.p,{children:"To register an operator a user must provide an implementation of the\noperator, its type, and any other desired metadata. The operator\nregistry is a column-based store where operators are keys, so any\nmetadata (which might be referenced by optimization passes) may be\nregistered as a new column."}),"\n",(0,s.jsxs)(n.p,{children:["From the perspective of Relay's type system, an operator is a function,\nso operators may be called like any other function and have function\ntypes. In particular, operator types are registered using a single type\nrelation (see\n",(0,s.jsx)(n.code,{children:"the documentation on type relations <type-relation>"}),"), typically a relation specialized to that operator. For\nexample, the ",(0,s.jsx)(n.code,{children:"add"})," operator is registered with the ",(0,s.jsx)(n.code,{children:"Broadcast"})," relation,\nindicating that the arguments of ",(0,s.jsx)(n.code,{children:"add"})," must be tensors and that the\nreturn type is a tensor whose shape depends on those of its arguments."]}),"\n",(0,s.jsxs)(n.p,{children:["Operators are rendered without a sigil (e.g ",(0,s.jsx)(n.code,{children:"conv2d"}),", ",(0,s.jsx)(n.code,{children:"flatten"}),") when\npretty-printing Relay programs. Operators are explicitly contained in\nthe program and are uniquely identifiable by pointer."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that common arithmetic operators such as ",(0,s.jsx)(n.code,{children:"add"})," and ",(0,s.jsx)(n.code,{children:"multiply"})," may\nbe written using the corresponding arithmetic operators in the text\nformat (e.g., ",(0,s.jsx)(n.code,{children:"+"})," or ",(0,s.jsx)(n.code,{children:"*"}),") as syntactic sugar."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Op"})," for the\ndefinition and documentation of operator nodes, demonstrating the\ninfrastructure for registering operator metadata. The other files in\n`` give handles for\ngenerating a call to various pre-registered operators. The\n",(0,s.jsx)(n.code,{children:"tutorial on adding operators to Relay <relay-add-op>"})," shows how to add further operators into the language."]}),"\n",(0,s.jsx)(n.h2,{id:"adt-constructors",children:"ADT Constructors"}),"\n",(0,s.jsxs)(n.p,{children:["Algebraic data types (ADTs) in Relay are described in detail in a\n",(0,s.jsx)(n.code,{children:"separate overview<adt-overview>"})," and\ntheir integration into the type system is described\n",(0,s.jsx)(n.code,{children:"here<adt-typing>"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In this section, we will simply note that ADT constructors are given a\nfunction type and should be used inside call nodes like a function or\noperator. An ADT constructor is defined by giving the name of the ADT it\nconstructs (a global type variable) and the types of the expected\narguments for the constructor."}),"\n",(0,s.jsx)(n.p,{children:"If the ADT definition includes type variables, those type variables may\nappear in the constructor. Constructors cannot include any other type\nvariables."}),"\n",(0,s.jsxs)(n.p,{children:["Let us suppose that ",(0,s.jsx)(n.code,{children:"D"})," is an ADT that takes type parameters ",(0,s.jsx)(n.code,{children:"a"})," and\n",(0,s.jsx)(n.code,{children:"b"}),". If ",(0,s.jsx)(n.code,{children:"C1"})," is a constructor for ",(0,s.jsx)(n.code,{children:"D"})," and expects two arguments, one of\ntype ",(0,s.jsx)(n.code,{children:"a"})," and one of type ",(0,s.jsx)(n.code,{children:"b"}),", then ",(0,s.jsx)(n.code,{children:"C1"})," has the following type\nsignature: ",(0,s.jsx)(n.code,{children:"fun<a, b>(a, b) -> D[a, b]"}),". (See either the ADT overview or\nthe discussion of ADT typing for an explanation of the type call in the\nreturn type.) If another constructor for ",(0,s.jsx)(n.code,{children:"D"}),", ",(0,s.jsx)(n.code,{children:"C2"}),", takes no arguments,\nthen it has the following type signature: ",(0,s.jsx)(n.code,{children:"fun<a, b>() -> D[a, b]"}),"; the\ntype parameters will always appear in the return type."]}),"\n",(0,s.jsxs)(n.p,{children:['Once called, a constructor produces an ADT instance, which is a\ncontainer that stores the values of the arguments to the constructor as\nwell as the name ("tag") of the constructor. The tag will be used for\ndeconstructing the instances and retrieving the values when ',(0,s.jsx)(n.a,{href:"#adt-matching",children:"ADT\nMatching"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Constructor"})," for\nthe definition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"call",children:"Call"}),"\n",(0,s.jsx)(n.p,{children:'Expressions with function types in Relay are "callable," meaning that\nthey can be invoked via a function call. These consist of any expression\nthat evaluates to a closure (i.e., function expressions or global\nfunctions) and Relay operators.'}),"\n",(0,s.jsx)(n.p,{children:"The syntax of calls follows that used in C-like languages, demonstrated\nin the example below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %c = 1;\nlet %f = fn(%x : Tensor[(), float32], %y : Tensor[(), float32]) { %x + %y + %c };\n%f(10, 11)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When a closure is called (see ",(0,s.jsx)(n.a,{href:"#closures",children:"Closures"}),"), the closure's\nbody is evaluated in the stored environment (i.e., using the stored\nvalues for free variables) with local variable bindings added for each\nargument; the final value obtained by evaluating the body is the call's\nreturn value. Thus, in the above example, the call evaluates to 22. In\nthe case of operators, the implementation is opaque to Relay, so the\nresult is left up to the registered TVM implementation."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note: type parameters are not yet supported in the text format."})}),"\n",(0,s.jsx)(n.p,{children:"A type-polymorphic function can also include type arguments at a call\nsite. The type arguments are substituted for type parameters when type\nchecking. If a function is type-polymorphic and type arguments are not\ngiven, type inference will attempt to infer type arguments if possible.\nThe following code gives examples of explicit and inferred type\narguments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// %f : fn<a : Type, b : Type, c : Type>(a, b) -> c\nlet %x1 = %f<Tensor[(), bool], Tensor[(), bool], Tensor[(), bool)]>(True, False);\n// %x1 is of type Tensor[(), bool]\nlet %x2 : () = %f(%x1, %x1)\n// the type arguments in the second call are inferred to be <Tensor[(), bool], Tensor[(), bool], ()>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that all type relations in the function type must hold at each call\nsite. Specifically, this means that the relation will be checked against\nthe specific types of the arguments at a given call site. This is also a\nform of polymorphism, since there may be multiple valid assignments of\nargument types and a return type so long as the relation is satisfied."}),"\n",(0,s.jsxs)(n.p,{children:["For example, if we have a function ",(0,s.jsx)(n.code,{children:"%f"})," that takes tensor arguments and\nhas the ",(0,s.jsx)(n.code,{children:"Broadcast"})," relation, then there are many different shapes that\nthe arguments in the below call could have that would satisfy the type\nannotation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %x : Tensor[(100, 100, 100), float32] = %f(%a, %b);\n%x\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Call"})," for its\ndefinition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"module-and-global-functions",children:"Module and Global Functions"}),"\n",(0,s.jsx)(n.p,{children:'Relay keeps a global data structure known as a "module" (often called\nan "environment" in other functional programming languages) to keep\ntrack of the definitions of global functions. In particular, the module\nkeeps a globally accessible mapping of global variables to the function\nexpressions they denote. The utility of the module is that it allows\nglobal functions to recursively refer to themselves or any other global\nfunction (e.g., as in mutual recursion).'}),"\n",(0,s.jsx)(n.p,{children:"Note Relay's module is analogous to data structures for keeping track\nof subgraphs in computation graph-based IRs."}),"\n",(0,s.jsxs)(n.p,{children:["Global functions in Relay behave identically to the function expressions\ndefined in ",(0,s.jsx)(n.a,{href:"#functions",children:"Functions"}),", but have syntactic sugar in the text\nformat to enter their definitions into the module. Namely, a global\nfunction definition includes a global identifier and is allowed to\nrecursively refer to that identifier in the body, as in the following\nexample:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @ackermann(%m : Tensor[(), int32], %n : Tensor[(), int32]) -> Tensor[(), int32] {\n    if (%m == 0) {\n        %n + 1\n    } else if (%m > 0 && %n == 0) {\n        @ackermann(%m - 1, 1)\n    } else {\n        @ackermann(%m - 1, @ackermann(%m, %n - 1))\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This definition would result in a module entry mapping the identifier\n",(0,s.jsx)(n.code,{children:"@ackermann"})," to a function expression with the parameters, return type,\nand body above. Any reference to the identifier ",(0,s.jsx)(n.code,{children:"@ackermann"})," elsewhere\nin the code could then look up the identifier in the module and replace\nthe function definition as needed."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"IRModule"})," for the\ndefinition and documentation of a module."]}),"\n",(0,s.jsx)(n.h2,{id:"constant",children:"Constant"}),"\n",(0,s.jsxs)(n.p,{children:["This node represents a constant tensor value (see\n",(0,s.jsx)(n.code,{children:"Value"})," for more details). A\nconstant is represented as a ",(0,s.jsx)(n.code,{children:"NDArray"}),", allowing Relay to utilize TVM operators for constant\nevaluation."]}),"\n",(0,s.jsxs)(n.p,{children:["This node can also represent scalar constants, since scalars are tensors\nwith a shape of ",(0,s.jsx)(n.code,{children:"()"}),". In the text format, numerical and boolean literals\nare thus syntactic sugar for constants encoding a tensor type with a\nrank-zero shape."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Constant"})," for\nits definition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"tuples",children:"Tuples"}),"\n",(0,s.jsx)(n.h3,{id:"construction",children:"Construction"}),"\n",(0,s.jsx)(n.p,{children:"The tuple node builds a finite (that is, of statically known size)\nsequence of heterogeneous data. These tuples match Python's closely,\nand their fixed length allows for efficient projection of their members."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%a : Tensor[(10, 10), float32], %b : float32, %c : Tensor[(100, 100), float32]) {\n    let %tup = (%a, %b);     // type: (Tensor[(10, 10), float32], float32)\n    ((%tup.0 + %tup.1), %c)  // type: (Tensor[(10, 10), float32], Tensor[(100, 100), float32])\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Tuple"})," for its\ndefinition and documentation."]}),"\n",(0,s.jsx)(n.h3,{id:"projection",children:"Projection"}),"\n",(0,s.jsx)(n.p,{children:"A tuple must be indexed by an integer constant in order to extract a\nparticular member of the tuple. Projections are 0-indexed."}),"\n",(0,s.jsxs)(n.p,{children:["For example, the below projection evaluates to ",(0,s.jsx)(n.code,{children:"%b"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(%a, %b, %c).1\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"TupleGetItem"}),"\nfor its definition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"let-bindings",children:"Let Bindings"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"let"})," binding is an immutable local variable binding, allowing the\nuser to bind an expression to a name."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"let"})," binding contains a local variable, an optional type annotation,\na value, and a body expression that may reference the bound identifier.\nIf a type annotation on the bound variable is omitted, Relay attempts to\ninfer the most general type permitted for the variable."]}),"\n",(0,s.jsxs)(n.p,{children:["The bound variable in a ",(0,s.jsx)(n.code,{children:"let"})," expression is only in scope in its body,\nexcept when the variable defines a function expression. When a ",(0,s.jsx)(n.code,{children:"let"}),"\nexpression creates a function, the variable is also in scope in its\nvalue to allow for recursively defined functions (see the previous\nsubsection)."]}),"\n",(0,s.jsxs)(n.p,{children:["The value of a ",(0,s.jsx)(n.code,{children:"let"})," binding is the value of the final expression after\nevaluating the bindings it depends on. For example, in the following\nexample the entire expression evaluates to a tensor of shape ",(0,s.jsx)(n.code,{children:"(10, 10)"}),"\nwhere all elements are 2:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %x : Tensor[(10, 10), float32] = Constant(1, (10, 10), float32);\n%x + %x\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A sequence of ",(0,s.jsx)(n.code,{children:"let"})," bindings can be considered as a dataflow graph,\nwhere the bindings are a series of sub-graphs connected by bound\nvariables. Since these binding sequences are pure, a pair of bindings\nwhere neither depends on the other can be safely reordered. For example,\nthe first and second ",(0,s.jsx)(n.code,{children:"let"})," bindings below may be evaluated in either\norder because neither has a dataflow dependency on the other:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let %x = %a + %b;\nlet %y = %c + %d;\n%x * %y\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Let"})," for its\ndefinition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"graph-bindings",children:"Graph Bindings"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"let"})," binding creates a named variable that is bound to the given\nvalue and scoped to the subsequent expression. By contrast, a graph\nbinding allows for explicitly constructing dataflow graphs in a Relay\nprogram by binding an expression (graph node) directly to a temporary\nvariable, which is not scoped. Each reference to the variable\ncorresponds to an edge in the dataflow graph. This has the semantics of\nsubstituting the expression wherever the variable appears, even though\nthe graph node will only be evaluated once by the compiled program."]}),"\n",(0,s.jsxs)(n.p,{children:["These bindings allow for a style of programming that corresponds to that\nalready employed by NNVM and other dataflow graph-based input formats.\nThe fact that the variables are not scoped offers some flexibility in\nevaluation order compared to ",(0,s.jsx)(n.code,{children:"let"})," bindings, though this can also\nintroduce some ambiguity in programs (the\n",(0,s.jsx)(n.code,{children:"developer introduction to the Relay IR<relay-dev-intro>"})," includes more detailed discussion of this nuance)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note: Graph bindings are not currently parsed by the text format."})}),"\n",(0,s.jsxs)(n.p,{children:["In Relay's text format, a graph binding can be written as below (note\nthe lack of a ",(0,s.jsx)(n.code,{children:"let"})," keyword and a semicolon):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"%1 = %a + %b\n%2 = %1 + %1\n%2 * %2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Unlike a let binding, a graph binding is not represented as an AST node\nin Relay, but rather as a meta-variable referencing its AST node value.\nFor example, a program like the above could be constructed in Relay's\nPython front-end by setting ",(0,s.jsx)(n.em,{children:"Python variables"})," equal to the\ncorresponding Relay AST node and using the variables repeatedly, as\nbelow (a C++ program using the corresponding API bindings could\naccomplish the same thing):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"sum1 = relay.add(a, b)\nsum2 = relay.add(sum1, sum1)\nrelay.multiply(sum2, sum2)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For development purposes and to enable certain optimizations, Relay\nincludes passes to convert between dataflow graphs defined using graph\nbindings and programs with ",(0,s.jsx)(n.code,{children:"let"})," bindings in A-normal form, employed by\nmany compiler optimizations from the functional programming community\n(see ",(0,s.jsx)(n.a,{href:"http://matt.might.net/articles/a-normalization/",children:'"A-Normalization: Why and How" by Matt\nMight'})," for an\nintroduction to A-normal form)."]}),"\n",(0,s.jsx)(n.h2,{id:"if-then-else",children:"If-Then-Else"}),"\n",(0,s.jsxs)(n.p,{children:["Relay has a simple if-then-else expression that allows programs to\nbranch on a single value of type ",(0,s.jsx)(n.code,{children:"bool"}),", i.e., a zero-rank tensor of\nbooleans (",(0,s.jsx)(n.code,{children:"Tensor[(), bool]"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if (%t == %u) {\n    %t\n} else {\n    %u\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:['Since if-then-else branches are expressions, they may appear inline\nwherever any other expression may be expected, like invocations of the\nternary operator in C-like languages. The if-then-else expression\nevaluates to the value of the "then" branch if the condition value\nevaluates to ',(0,s.jsx)(n.code,{children:"True"}),' and evaluates to the value of the "else" branch if\nthe condition value evaluates to ',(0,s.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"If"})," for its\ndefinition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"adt-matching",children:"ADT Matching"}),"\n",(0,s.jsxs)(n.p,{children:["Instances of algebraic data types (ADTs), as discussed in the\n",(0,s.jsx)(n.code,{children:"ADT overview<adt-overview>"}),", are\ncontainers that store the arguments passed to the constructor used to\ncreate them, tagged by the constructor name."]}),"\n",(0,s.jsxs)(n.p,{children:['Match expressions in Relay allow for retrieving the values stored in an\nADT instance ("deconstructing" it) based on their constructor tag. A\nmatch expression behaves similarly to a C-style ',(0,s.jsx)(n.code,{children:"switch"})," statement,\nbranching on the different possible constructors for the type of the\nvalue being deconstructed. As the ADT overview details, match\nexpressions are capable of more general pattern-matching than simply\nsplitting by constructors: any ADT instance nested inside an instance\n(e.g., a list of lists) can be deconstructed at the same time as the\nouter instance, while the different fields of the instance can be bound\nto variables. (See ",(0,s.jsx)(n.code,{children:"this section<adt-pattern>"})," for a detailed description of ADT pattern-matching.)"]}),"\n",(0,s.jsxs)(n.p,{children:["A match expression is defined using the input value (an expression) and\na list of clauses, each of which consists of a pattern and an\nexpression. When executed, the ",(0,s.jsx)(n.em,{children:"first"})," clause whose pattern matches the\nstructure of the queried value is executed; the clause expression is\nevaluated and returned."]}),"\n",(0,s.jsx)(n.p,{children:"For example, suppose we have an ADT for natural numbers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"data Nat {\n  Z : () -> Nat # zero\n  S : (Nat) -> Nat # successor (+1) to a nat\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then the following function subtracts one from a passed nat:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%v: Nat[]) -> Nat[] {\n  match(%v) {\n    case Z() { Z() }\n    case S(%n) { %n } # the variable %n is bound in the scope of this clause\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following function subtracts two from its argument if it is at least\ntwo and returns the argument otherwise, using a nested constructor\npattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%v : Nat[]) -> Nat[] {\n  match(%v) {\n     case S(S(%n)) { %n }\n     # wildcard pattern: matches all cases not matched already\n     case _ { %v }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"As aforementioned, the ordering of match clauses is relevant. In the\nbelow example, the first clause will always match so those below it can\nnever run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fn(%v : Nat[]) -> Nat[] {\n  match(%v) {\n    case _ { %v }\n    case S(S(%n)) { S(%n) }\n    case S(%n) { %n }\n    case Z() { S(Z()) }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"Match"})," for its\ndefinition and documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"tempexprs",children:"TempExprs"}),"\n",(0,s.jsxs)(n.p,{children:["Program transformations (passes) in Relay may require inserting\ntemporary state into the program AST to guide further transformations.\nThe ",(0,s.jsx)(n.code,{children:"TempExpr"})," node is provided as a utility to developers for this\npurpose; nodes inheriting from ",(0,s.jsx)(n.code,{children:"TempExpr"})," cannot appear directly in\nuser-provided code but may be inserted in a pass. Any ",(0,s.jsx)(n.code,{children:"TempExpr"})," created\nin a pass should ideally be eliminated before the pass is complete, as a\n",(0,s.jsx)(n.code,{children:"TempExpr"})," only stores internal state and has no semantics of its own."]}),"\n",(0,s.jsxs)(n.p,{children:["For an example of ",(0,s.jsx)(n.code,{children:"TempExpr"})," being used in a pass, see\n",(0,s.jsx)(n.code,{children:"src/relay/transforms/fold_scale_axis.cc"}),", which uses ",(0,s.jsx)(n.code,{children:"TempExpr"})," nodes\nto store information about scaling parameters as the pass tries to fold\nthese into the weights of a convolution."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.code,{children:"TempExpr"})," for\nits definition and documentation."]})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},21494:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return o}});var a=t(39546);let s={},i=a.createContext(s);function o(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);