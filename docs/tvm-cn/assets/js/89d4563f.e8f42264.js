"use strict";(self.webpackChunktvm_cn=self.webpackChunktvm_cn||[]).push([["74562"],{21994:function(e,n,t){t.r(n),t.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>a,assets:()=>l,toc:()=>c,contentTitle:()=>r});var a=JSON.parse('{"id":"reference/langref/relay_adt","title":"Algebraic Data Types in Relay","description":"Algebraic data types (ADTs) are a staple feature of functional","source":"@site/versioned_docs/version-0.10.0/reference/langref/relay_adt.md","sourceDirName":"reference/langref","slug":"/reference/langref/relay_adt","permalink":"/docs/tvm-cn/docs/0.10.0/reference/langref/relay_adt","draft":false,"unlisted":false,"editUrl":"https://github.com/hyperai/tvm-cn/edit/master/versioned_docs/version-0.10.0/reference/langref/relay_adt.md","tags":[],"version":"0.10.0","lastUpdatedBy":"sparanoid","lastUpdatedAt":1744717810000,"frontMatter":{"title":"Algebraic Data Types in Relay"}}'),s=t("74132"),i=t("21494");let o={title:"Algebraic Data Types in Relay"},r=void 0,l={},c=[{value:"Defining and Matching on an ADT",id:"defining-and-matching-on-an-adt",level:2},{value:"Type-Checking ADTs and Polymorphism",id:"type-checking-adts-and-polymorphism",level:2},{value:"Recursion with ADTs",id:"recursion-with-adts",level:2},{value:"Pattern Matching in Match Expressions",id:"pattern-matching-in-match-expressions",level:2},{value:"Common ADT Uses",id:"common-adt-uses",level:2},{value:"Implementing Neural Nets Using ADTs",id:"implementing-neural-nets-using-adts",level:2}];function d(e){let n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Algebraic data types (ADTs) are a staple feature of functional\nprogramming languages, particularly those derived from ML, because they\nexpress data structures in a manner that is easy to reason about when\nwriting recursive computations. Because recursion is intended to be one\nof the primary mechanisms of control flow in Relay, it is important that\nRelay include ADTs in order to best express loops and other control flow\nstructures that must be implemented using recursion."}),"\n",(0,s.jsx)(n.h2,{id:"defining-and-matching-on-an-adt",children:"Defining and Matching on an ADT"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Note: ADTs are not presently supported in the text format. The syntax\nhere is speculative, based on ADTs in other languages."})}),"\n",(0,s.jsxs)(n.p,{children:["ADTs can be understood as a generalized version of ",(0,s.jsx)(n.code,{children:"enum"})," and ",(0,s.jsx)(n.code,{children:"struct"}),"\ntypes from C-like languages. Like a C ",(0,s.jsx)(n.code,{children:"struct:"}),", an ADT instance is a\ncontainer for fields of specified types, but the type system allows for\nthe same type to encode different possible groupings of fields in a\nsystematic manner, similar to C ",(0,s.jsx)(n.code,{children:"enum"})," types, which are defined using a\nfinite set of possible values named by the user."]}),"\n",(0,s.jsx)(n.p,{children:"Specifically, an ADT is defined as a named group of constructors, each\nof which is a function that takes values of specified types as arguments\nand returns an instance of the named ADT. An ADT instance simply\ncontains the values of the arguments passed to the constructor call used\nto produce it."}),"\n",(0,s.jsxs)(n.p,{children:["An ADT value is opaque until it is ",(0,s.jsx)(n.em,{children:"deconstructed"}),", allowing the\narguments to the constructor to be accessed again and used to compute\nnew values. Because a particular ADT can have multiple constructors with\ndifferent signatures, it is usually necessary to branch on the different\npossible constructors, resulting in the ",(0,s.jsx)(n.em,{children:"match"}),' syntax for ADTs. Hence,\nADTs are sometimes called "tagged unions" because an ADT instance is\ntagged by the name of the constructor used to produce it and can later\nbe inspected based on the tag.']}),"\n",(0,s.jsxs)(n.p,{children:["Because each ADT has a finite set of constructors, it is straightforward\nto determine whether a function processing an ADT instance is handling\nall possible cases. In particular, the type system can ensure that types\nare properly assigned in all cases when deconstructing an ADT instance,\nin contrast to ",(0,s.jsx)(n.code,{children:"union"})," types in C. Hence, it is often easy to reason\nabout ADTs."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Implementation detail: Relay ADT definitions are global and are stored\nin the module, similarly to global function definitions. An ADT name is,\nin fact, a global type variable (just as a global function name is a\nglobal variable). The module keeps a mapping of ADT names (global type\nvariables) to the list of constructors for that ADT."})}),"\n",(0,s.jsx)(n.p,{children:"Below is a simple example of defining an ADT and using it in a function\nvia a match expression:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'# Defines an ADT named "Numbers"\ndata Numbers {\n  Empty : () -> Numbers\n  Single : (Tensor[(), int32]) -> Numbers\n  Pair : (Tensor[(), int32], Tensor[(), int32]) -> Numbers\n}\n# A Numbers value can be produced using an Empty, Single, or Pair\n# constructor, each with a signature given above\n\ndef @sum(%n : Numbers[]) -> Tensor[(), int32] {\n   # The match expression branches on the constructor that was\n   # used to produce %n. The variables in each case are bound\n   # if the constructor matches that used for %n\n   match(%n) {\n     case Empty() { 0 }\n     case Single(x) { x }\n     case Pair(x, y) { x + y }\n   }\n}\n\n@sum(Empty())    # evaluates to 0\n@sum(Single(3))  # evaluates to 3\n@sum(Pair(5, 6)) # evaluates to 11\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note that ADTs are identified by name, meaning that two ADTs with\nstructurally identical constructors will nevertheless be distinct data\ntypes from the point of view of the typechecker."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# structurally identical constructors to Numbers\ndata Numbers2 {\n  Empty2 : () -> Numbers2\n  Single2 : (Tensor[(), int32]) -> Numbers2\n  Pair2 : (Tensor[(), int32], Tensor[(), int32]) -> Numbers2\n}\n\n# the below results in a type error because Numbers2\n# is a distinct type from Numbers\n# fn() { @sum(Empty2()) }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"type-checking-adts-and-polymorphism",children:"Type-Checking ADTs and Polymorphism"}),"\n",(0,s.jsx)(n.p,{children:"This section will go into more specific detail about the typing of ADTs.\nMost of the complexity involved results from the fact that, as with\nfunctions, ADTs can be polymorphic and take type parameters."}),"\n",(0,s.jsx)(n.p,{children:"For example, one of the standard ADTs commonly used in functional\nprogramming languages is the optional type, defined here:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# a is a type parameter\ndata Optional<a> {\n  None : () -> Optional\n  Some : (a) -> Optional\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Optional types are commonly used as the return type for any operation\ninvolving querying into a data structure (returning ",(0,s.jsx)(n.code,{children:"Some(v)"})," if a value\nis found and ",(0,s.jsx)(n.code,{children:"None"})," if it isn't). Taking a type parameter in the\ndefinition allows the same optional type to be used in a wide variety of\nsituations, rather than having to define a unique ADT for each different\ntype that could be contained in it."]}),"\n",(0,s.jsxs)(n.p,{children:["However, it is important to ensure that option types whose contents are\nof different types can still be distinguished by the type system, since\nit would violate type safety if a function expecting an option\ncontaining a ",(0,s.jsx)(n.code,{children:"Tensor[(), int32]"})," instead receives an option containing a\n",(0,s.jsx)(n.code,{children:"Tensor[(3, 4), float32]"}),". As this example may imply, an ADT instance is\nthus given a type that contains the concrete type arguments for that\ninstance, ensuring the information is kept around. Let the below example\nillustrate:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# the signature for option indicates the type argument\ndef @inc_scalar(%opt : Optional[Tensor[(), int32]]) -> Tensor[(), int32] {\n  match(%opt) {\n    case None() { 1 }\n    case Some(%s) { %s + 1 }\n  }\n}\n\ndef @main() {\n  let %one : Optional[Tensor[(), int32]] = Some(1);\n  let %big : Optional[Tensor[(10, 10), float32]]\n    = Some(Constant(1, (10, 10), float32));\n  let %two = inc_scalar(%one);\n  # let %bigger = inc_scalar(%big); # type system rejects\n  # None does not take an argument so it can always implicitly\n  # be given the correct type arguments\n  let %z = inc_scalar(None());\n  ()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The syntax for the annotated type arguments (e.g.,\n",(0,s.jsx)(n.code,{children:"Optional[Tensor[(), int32]]"}),') in the above examples is called a "type\ncall," treating the polymorphic ADT definition as a type-level function\n(taking type params and returning a type, namely the ADT). Any ADT\nappearing in a type annotation or function signature must be annotated\nwith type arguments (a non-polymorphic ADT must be in a type call with\nno arguments).']}),"\n",(0,s.jsxs)(n.p,{children:["Thus, we can say in general that if constructor ",(0,s.jsx)(n.code,{children:"C"})," that takes arguments\nof types ",(0,s.jsx)(n.code,{children:"T1, ..., Tn"})," is a constructor for an ADT ",(0,s.jsx)(n.code,{children:"D"})," that takes type\nparameters ",(0,s.jsx)(n.code,{children:"v1, ..., vn"})," (where ",(0,s.jsx)(n.code,{children:"T1, ..., Tn"})," may contain any of the\n",(0,s.jsx)(n.code,{children:"v1, ..., vn"}),"), then ",(0,s.jsx)(n.code,{children:"C"})," has the type\n",(0,s.jsx)(n.code,{children:"fun<v1, ..., vn>(T1, ..., Tn) -> D[v1, ..., vn]"}),". This means that\nconstructors are typed like ordinary functions and thus appear inside\ncall nodes and can be passed to or returned by other functions. In\nparticular, the ",(0,s.jsx)(n.code,{children:"Some"})," example above has the signature\n",(0,s.jsx)(n.code,{children:"fun<a>(a) -> Optional[a]"}),", while ",(0,s.jsx)(n.code,{children:"None"})," has the signature\n",(0,s.jsx)(n.code,{children:"fun<a>() -> Optional[a]"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"recursion-with-adts",children:"Recursion with ADTs"}),"\n",(0,s.jsxs)(n.p,{children:["ADT definitions are allowed to be recursive, that is, a definition for\nan ADT named ",(0,s.jsx)(n.code,{children:"D"})," can assume the existence of type ",(0,s.jsx)(n.code,{children:"D"})," and use it as an\nargument to constructors. Recursion allows ADTs to represent complex\nstructures such as lists or trees; it is the source of much of ADTs'\npower in functional programming, since an appropriately designed data\nstructure could make it easy to concisely express a computation with a\nrecursive function."]}),"\n",(0,s.jsxs)(n.p,{children:["Many commonly used ADTs involve recursion; some of these are given in\n",(0,s.jsx)(n.a,{href:"#common-adt-uses",children:"Common ADT Uses"}),". As an example here, we will examine\nthe list ADT, ubiquitous in functional languages:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"data List<a> {\n   Nil : () -> List\n   Cons : (a, List[a]) -> List\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["(Notice that the recursive reference to ",(0,s.jsx)(n.code,{children:"List"})," is wrapped in a type call\neven in the constructor.)"]}),"\n",(0,s.jsxs)(n.p,{children:["The above definition means that a list of values of a particular type\ncan be represented by nesting ",(0,s.jsx)(n.code,{children:"Cons"})," constructors until the end of the\nlist is reached, which can be indicated with a ",(0,s.jsx)(n.code,{children:"Nil"})," (representing an\nempty list)."]}),"\n",(0,s.jsx)(n.p,{children:"Lists represented in this manner can easily be recursively processed.\nFor example, the following function sums a list of integers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @list_sum(%l : List[Tensor[(), int32]]) -> Tensor[(), int32] {\n  match(%l) {\n    case Nil() { 0 }\n    # add the head of the list to the sum of the tail\n    case Cons(%h, %t) { %h + @list_sum(%t) }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As it happens, many recursive functions on lists like the one just given\nshare structures that can be factored out into generic, easily usable\nfunctions that will be discussed under ",(0,s.jsx)(n.a,{href:"#common-adt-uses",children:"Common ADT\nUses"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"pattern-matching-in-match-expressions",children:"Pattern Matching in Match Expressions"}),"\n",(0,s.jsx)(n.p,{children:"Match expressions in Relay, as in other functional languages, are\ncapable of more versatile pattern matching than simply having one case\nfor each constructor for the datatype of the value being deconstructed."}),"\n",(0,s.jsx)(n.p,{children:"In particular, the patterns in match cases can be built up recursively:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Constructor patterns match for a particular ADT constructor. If a\nvalue matches the constructor, each argument to the constructor will\nbe matched against a nested pattern."}),"\n",(0,s.jsx)(n.li,{children:"Wildcard patterns will match any value and will not bind to a\nvariable."}),"\n",(0,s.jsx)(n.li,{children:"Variable patterns will match any value and bind it to a local\nvariable, scoped to the match clause."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In the simple case of ",(0,s.jsx)(n.code,{children:"@list_sum"})," above, the first match case has a\n",(0,s.jsx)(n.code,{children:"Nil"})," constructor pattern (with no nested arguments) and the second has\na ",(0,s.jsx)(n.code,{children:"Cons"})," constructor pattern that uses variable patterns for each of the\narguments to ",(0,s.jsx)(n.code,{children:"Cons"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The below example uses a wildcard pattern to ignore one of the arguments\nto ",(0,s.jsx)(n.code,{children:"Cons"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @first<a>(%l : List[a]) -> Optional[a] {\n  match(%l) {\n    case Nil() { None() }\n    case Cons(%h, _) { Some(%h) } # list tail is unused and ignored\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here, a constructor pattern is nested inside another constructor pattern\nto avoid nested match expressions for a list option. A top-level\nwildcard pattern is also used to handle all cases that do not match the\nfirst clause:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @second_opt<a>(%ll : Optional[List[a]]) -> Optional[a] {\n  match(%ll) {\n    # we only need the second member of the list if there is one\n    case Some(Cons(_, Cons(%s, _))) { Some(%s) }\n    case _ { None() }\n  }\n}\n\n# @second_opt(Some(Cons(1, Nil()))) evaluates to None()\n# @second_opt(Some(Cons(1, Cons(2, Nil())))) evaluates to Some(2)\n# @second_opt(Some(Nil())) evaluates to None()\n# @second_opt(None()) evaluates to None()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that a match expression checks its patterns in the order the cases\nare listed: the first clause whose pattern that matches the input value\nis the one that is evaluated. Here, a top-level variable pattern binds\nthe whole input value:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @match_order_beware<a>(%l : List[a]) -> List[a] {\n  match(%l) {\n    case %v { %v }\n    # the above matches everything so neither of these runs\n    case Cons(%h, %t) { Cons(%h, @match_order_beware(%t)) }\n    case Nil() { Nil() }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-adt-uses",children:"Common ADT Uses"}),"\n",(0,s.jsx)(n.p,{children:'In functional programming languages, certain ADTs provide useful\nfacilities for writing common programs. Parametric polymorphism and\nhigher-order functions allow these ADTs to be easily reuseable and for\ngeneric functions to manipulate them in common situations. Relay\nincludes a "Prelude" of certain pre-defined ADTs and functions for\nthem that correspond to the indispensable ADTs of other languages.'}),"\n",(0,s.jsxs)(n.p,{children:["The option type defined under ",(0,s.jsx)(n.a,{href:"#type-checking-adts-and-polymorphism",children:"Type-Checking ADTs and\nPolymorphism"})," is one such ADT,\nused whenever it can make sense for a function to only return a value\nunder certain circumstances. Having the option type allows for the type\nsystem to keep track of which functions always return a value of a\ncertain type versus returning an option of that type, ensuring that any\noptions are always explicitly checked (contrast with returning null\npointers or throwing exceptions as other ways to addressing that\nproblem)."]}),"\n",(0,s.jsxs)(n.p,{children:["Lists (defined in ",(0,s.jsx)(n.a,{href:"#recursion-with-adts",children:"Recursion with ADTs"}),") can be\nmanipulated by generic functions in a manner similar to list\ncomprehensions and certain library functions in Python. Below are very\ncommon functions for iterating through lists, which are included in\nRelay's Prelude. (These have all been extensively characterized in the\nfunctional programming literature, and we do not attempt to reproduce\nthat work in this document.)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# Map: for [h1, h2, ..., hn] returns [f(h1), f(h2), ..., f(hn)]\ndef @map<a, b>(%f : fn(a) -> b, %l : List[a]) -> List[b] {\n  match(%l) {\n    case Nil() { Nil() }\n    case Cons(%h, %t) { Cons(%f(%h), @map(%f, %t)) }\n  }\n}\n\n# Left fold: for [h1, h2, ..., hn] returns f(...(f(f(z, h1), h2)...), hn)\ndef @foldl<a, b>(%f : fn(b, a) -> b, %z : b, %l : List[a]) -> b {\n  match(%l) {\n    case Nil() { %z }\n    case Cons(%h, %t) { @foldl(%f, %f(%z, %h), %t) }\n  }\n}\n\n# Right fold: for [h1, h2, ..., hn] returns f(h1, f(h2, f(..., (f(hn, z)...)\ndef @foldr<a, b>(%f : fn(a, b) -> b, %z : b, %l : List[a] -> b {\n  match(%l) {\n    case Nil() { %z }\n    case Cons(%h, %t) { %f(%h, @foldr(%f, %z, %t)) }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Using these iteration constructs, many common operations over lists can\nbe expressed compactly. For example, the following map doubles all\nmembers of a list:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# directly written\ndef @double(%l : List[Tensor[(), int32]]) -> List[Tensor[(), int32]] {\n  match(%l) {\n    case Nil() { Nil() }\n    case Cons(%h, %t) { Cons(%h * 2, @double(%t)) }\n  }\n}\n\n# map takes care of the recursion\n@map(fn(%i) { %i * 2 }, %l)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following right fold concatenates two lists:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# directly written\ndef @concat<a>(%l1 : List[a], %l2 : List[a]) -> List[a] {\n  match(%l1) {\n    case Nil() { %l2 }\n    case Cons(%h, %t) { Cons(%h, @concat(%t, %l2) }\n  }\n}\n\n# foldr takes care of the recursion\n@foldr(fn(%h, %z) { Cons(%h, %z) }, %l2, %l1)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The following left fold flattens a list of lists (using concatenation):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# directly written\ndef @flatten<a>(%ll : List[List[a]]) -> List[a] {\n  match(%ll) {\n    case Cons(%h, %t) { @concat(%h, @flatten(%t)) }\n    case Nil() { Nil() }\n  }\n\n# foldl takes care of the recursion\n@foldl(@concat, Nil(), %ll)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that these iteration constructs can be implemented directly in\nRelay's source language and more can easily be defined (and for more\ndata types, like trees), rather than being constructs built into the\nlanguage (e.g., ",(0,s.jsx)(n.a,{href:"https://mxnet.apache.org/versions/master/tutorials/control_flow/ControlFlowTutorial.html",children:'"foreach" in\nMXNet'}),").\nADTs and their extensibility allow for a broad range of iterations and\ndata structures to be expressed in Relay and supported by the type\nsystem without having to modify the language implementation."]}),"\n",(0,s.jsx)(n.h2,{id:"implementing-neural-nets-using-adts",children:"Implementing Neural Nets Using ADTs"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.a,{href:"http://colah.github.io/posts/2015-09-NN-Types-FP/",children:"this 2015 blog\npost"}),", Christopher\nOlah notes that many neural networks can be easily expressed using\ncommon functional programming constructs. Relay's ADTs allow those\nexamples to be implemented directly in TVM."]}),"\n",(0,s.jsx)(n.p,{children:"First let us suppose that we have a function corresponding to a trained\nrecurrent neural net (RNN) cell, which takes in a past state and an\ninput value and returns a new state and output value. In Relay, this\nwould have the following signature:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"@cell : fn<state_type, in_type, out_type>(state_type, in_type) -> (state_type, out_type)\n"})}),"\n",(0,s.jsx)(n.p,{children:"We might consider a ReLU cell as a simple concrete example, with a\ntrained version below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @linear(%x, %w, %b) { %w*%x + %b }\n\ndef @relu_cell(%w, # weights\n               %b, # offsets\n               %s, # state\n               %x  # input\n) {\n  let %x2 = @linear(%x, %w.0, %b.0);\n  let %s2 = @linear(%s, %w.1, %b.1);\n  # doesn't change the state\n  (%s, nn.relu(%x2 + %s2))\n}\n\n# this is a higher-order function because it returns a closure\ndef @trained_cell(%w, %b) {\n  fn(%x, %h) { @relu_cell(%w, %b, %x, %h) }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Following Olah's example, we can encode a sequence (list) of inputs\nwith the following left fold:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @encode<state_type, in_type, out_type>(%cell, %input : List[in_type], %init : state_type) -> state_type {\n  # not using the output\n  @foldl(fn(%state, %in) { %cell(%state, %in).0 }, %init, %input)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Using an ",(0,s.jsx)(n.em,{children:"unfold"})," iterator (from Haskell's standard library), the same\ncell could be used to make a generator network (which takes a single\ninput and produces a sequence of outputs):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# included in Relay's Prelude\ndef @unfoldr<a, b>(%f : fn(b) -> Optional[(a, b)], %z : b) -> List[a] {\n  match(%f(%z)) {\n    case Some(%pair) { Cons(%pair.0, @unfoldr(%f, %pair.1)) }\n    case None() { Nil() }\n  }\n}\n\n# we need some way of generating an input to the cell function given only a state\ndef @gen_func<state_type, in_type, out_type>(%state : state_type) : Optional[(out_type, state_type)] {\n  let %in : Optional[in_type] = @generate_input(%state);\n  match(%in) {\n    case Some(%n) {\n      let %cell_out = @cell(%n, %state);\n      Some((%cell_out.1, %cell_out.0)) # pair of output and state\n    }\n    case None() { None() }\n  }\n}\n\ndef @generator<state_type, in_type, out_type>(%cell, %init : state_type) -> List[out_type] {\n  @unfoldr(fn(%state) { @gen_func(%cell, %state) }, %init)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"An accumulating map (a fold that simultaneously updates an accumulator\nvalue and a list of outputs) can be used to write a general RNN (with an\noutput for every input):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"def @map_accumr<a, b, c>(%f : fn(a, b) -> (a, c), %acc : a, %l : List[b]) -> (a, List[c]) {\n  match(%l) {\n    case Nil() { (%acc, Nil()) }\n    case Cons(%b, %t) {\n      let %update = %f(%acc, %b);\n      let %rest = @map_accumr(%f, %update.0, %t));\n      (%rest.0, Cons(%update.1, %rest.1))\n    }\n  }\n}\n\n# can also be implemented as a right fold\n# (this version is included in Relay's Prelude)\ndef @map_accumr_fold(%f, %acc, %l) {\n  @foldr(fn(%b, %p) {\n    let %f_out = %f(%p.0, %b);\n    (%f_out.0, Cons(%f_out.1, %p.1))\n  },\n  (%acc, Nil()), %l)\n}\n\ndef @general_rnn<state_type, in_type, out_type>(%cell, %init : state_type, %input : List[in_type])\n  -> (state_type, List[out_type]) {\n  @map_accumr(%cell, %init, %input)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Olah also gives an example of a bidirectional neural network, in which\ntwo sets of cells (which may have different weights) process the input\nin both directions and produce a single set of outputs. The following is\na Relay implementation of that example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# creates a list of tuples from two lists\n# included in Relay's Prelude\ndef @zip<a, b>(%l : List[a], %m : List[b]) -> List[(a, b)] {\n  match(%l) {\n    case Nil() { Nil() }\n    case Cons(%a, %t1) {\n      match(%m) {\n        case Nil() { Nil() }\n        case Cons(%b, %t2) { Cons((%a, %b), @zip(%t1, %t2)) }\n      }\n    }\n  }\n}\n\n# analogous to map_accumr\n# included in Relay's Prelude\ndef @map_accmul(%f, %acc, %l) {\n  @foldl(fn(%p, %b){\n    let %f_out = %f(%p.0, %b);\n    (%f_out.0, Cons(%f_out.1, %p.1))\n  }, (%acc, Nil()), %l)\n}\n\ndef @bidirectional_rnn<state1_type, state2_type, in_type, out1_type, out2_type>\n  (%cell1, %cell2, %state1 : state1_type, %state2 : state2_type, %input : List[in_type])\n  -> List[(out1_type, out2_type)] {\n  @zip(@map_accumr(%cell1, %state1, %input).1, @map_accuml(%cell2, %state2, %input).1)\n}\n"})})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},21494:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return o}});var a=t(39546);let s={},i=a.createContext(s);function o(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);