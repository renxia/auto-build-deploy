"use strict";(self.webpackChunktvm_cn=self.webpackChunktvm_cn||[]).push([["5609"],{72602:function(e,n,t){t.r(n),t.d(n,{default:()=>p,frontMatter:()=>r,metadata:()=>s,assets:()=>l,toc:()=>c,contentTitle:()=>o});var s=JSON.parse('{"id":"reference/langref/relay_type","title":"Relay\\\\\'s Type System","description":"We briefly introduced types while detailing Relay\\\\\'s expression","source":"@site/docs/reference/langref/relay_type.md","sourceDirName":"reference/langref","slug":"/reference/langref/relay_type","permalink":"/docs/tvm-cn/docs/reference/langref/relay_type","draft":false,"unlisted":false,"editUrl":"https://github.com/hyperai/tvm-cn/edit/master/docs/reference/langref/relay_type.md","tags":[],"version":"current","lastUpdatedBy":"sparanoid","lastUpdatedAt":1744717810000,"frontMatter":{"title":"Relay\\\\\'s Type System"}}'),i=t("74132"),a=t("21494");let r={title:"Relay's Type System"},o=void 0,l={},c=[{value:"Type",id:"type",level:2},{value:"Tensor Type",id:"tensor-type",level:2},{value:"Tuple Type",id:"tuple-type",level:2},{value:"Type Parameter",id:"type-parameter",level:2},{value:"Type Constraint",id:"type-constraint",level:2},{value:"Function Type",id:"function-type",level:2},{value:"Type Relation",id:"type-relation",level:2},{value:"Incomplete Type",id:"incomplete-type",level:2},{value:"Algebraic Data Types",id:"algebraic-data-types",level:2},{value:"Global Type Variable",id:"global-type-variable",level:3},{value:"Definitions (Type Data)",id:"definitions-type-data",level:3},{value:"Type Call",id:"type-call",level:3},{value:"Example: List ADT",id:"example-list-adt",level:3}];function d(e){let n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"We briefly introduced types while detailing Relay's expression\nlanguage, but have not yet described its type system. Relay is a\nstatically typed and type-inferred language, allowing programs to be\nfully typed while requiring just a few explicit type annotations."}),"\n",(0,i.jsxs)(n.p,{children:["Static types are useful when performing compiler optimizations because\nthey communicate properties about the data a program manipulates, such\nas runtime shape, data layout, and storage, without needing to run the\nprogram. Relay's ",(0,i.jsx)(n.a,{href:"#algebraic-data-types",children:"Algebraic Data Types"})," allow\nfor easily and flexibly composing types in order to build data\nstructures that can be reasoned about inductively and used to write\nrecursive functions."]}),"\n",(0,i.jsxs)(n.p,{children:["Relay's type system features a form of ",(0,i.jsx)(n.em,{children:"dependent typing"})," for shapes.\nThat is, its type system keeps track of the shapes of tensors in a Relay\nprogram. Treating tensor shapes as types allows Relay to perform more\npowerful reasoning at compile time; in particular, Relay can statically\nreason about operations whose output shapes vary based on the input\nshapes in complex ways. Casting shape inference as a type inference\nproblem allows Relay to infer the shapes of all tensors at compile time,\nincluding in programs that use branching and function calls."]}),"\n",(0,i.jsxs)(n.p,{children:["Statically reasoning about shapes in this manner allows Relay to be\nahead-of-time compiled and provides much more information about tensors\nfor optimizations further in the compilation pipeline. Such\noptimizations can be implemented as passes, which are Relay-to-Relay AST\ntransformations, and may use the inferred types (e.g., shape\ninformation) for making decisions about program transformations. For\ninstance, ",(0,i.jsx)(n.code,{children:"src/relay/transforms/fuse_ops.cc"})," gives an implementation of\na pass that uses inferred tensor shapes to replace invocations of\noperators in a Relay program with fused operator implementations."]}),"\n",(0,i.jsxs)(n.p,{children:["Reasoning about tensor types in Relay is encoded using ",(0,i.jsx)(n.em,{children:"type relations"}),",\nwhich means that the bulk of type checking in Relay is constraint\nsolving (ensuring that all type relations are satisfied at call sites).\nType relations offer a flexible and relatively simple way of making the\npower of dependent typing available in Relay without greatly increasing\nthe complexity of its type system."]}),"\n",(0,i.jsx)(n.p,{children:"Below we detail the language of types in Relay and how they are assigned\nto Relay expressions."}),"\n",(0,i.jsx)(n.h2,{id:"type",children:"Type"}),"\n",(0,i.jsx)(n.p,{children:"The base type for all Relay types. All Relay types are sub-classes of\nthis base type."}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"Type"})," for its\ndefinition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"tensor-type",children:"Tensor Type"}),"\n",(0,i.jsx)(n.p,{children:"A concrete tensor type in Relay."}),"\n",(0,i.jsxs)(n.p,{children:["Tensors are typed according to data type and shape. At present, these\nuse TVM's data types and shapes, but in the future, Relay may include a\nseparate AST for shapes. In particular, data types include ",(0,i.jsx)(n.code,{children:"bool"}),",\n",(0,i.jsx)(n.code,{children:"float32"}),", ",(0,i.jsx)(n.code,{children:"int8"})," and various other bit widths and numbers of lanes.\nShapes are given as tuples of dimensions (TVM ",(0,i.jsx)(n.code,{children:"IndexExpr"}),"), such as\n",(0,i.jsx)(n.code,{children:"(5, 5)"}),"; scalars are also given tuple types and have a shape of ",(0,i.jsx)(n.code,{children:"()"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Note, though, that TVM shapes can also include variables and arithmetic\nexpressions including variables, so Relay's constraint solving phase\nwill attempt to find assignments to all shape variables to ensure all\nshapes will be concrete before running a program."}),"\n",(0,i.jsx)(n.p,{children:"For example, here is a simple concrete tensor type corresponding to a\n10-by-10 tensor of 32-bit floats:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Tensor[(10, 10), float32]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TensorType"})," for\nits definition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"tuple-type",children:"Tuple Type"}),"\n",(0,i.jsx)(n.p,{children:"A type of a tuple in Relay."}),"\n",(0,i.jsx)(n.p,{children:"Just as a tuple is simply a sequence of values of statically known\nlength, the type of a tuple consists of a sequence of the types\ncorresponding to each member of the tuple."}),"\n",(0,i.jsx)(n.p,{children:"Because a tuple type is of statically known size, the type of a tuple\nprojection is simply the corresponding index into the tuple type."}),"\n",(0,i.jsxs)(n.p,{children:["For example, in the below code, ",(0,i.jsx)(n.code,{children:"%t"})," is of type\n",(0,i.jsx)(n.code,{children:"(Tensor[(), bool], Tensor[(10, 10), float32])"})," and ",(0,i.jsx)(n.code,{children:"%c"})," is of type\n",(0,i.jsx)(n.code,{children:"Tensor[(10, 10), float32]"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"let %t = (False, Constant(1, (10, 10), float32));\nlet %c = %t.1;\n%c\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TupleType"})," for its\ndefinition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"type-parameter",children:"Type Parameter"}),"\n",(0,i.jsxs)(n.p,{children:["Type parameters represent placeholder types used for polymorphism in\nfunctions. Type parameters are specified according to ",(0,i.jsx)(n.em,{children:"kind"}),",\ncorresponding to the types those parameters are allowed to replace:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Type"}),", corresponding to top-level Relay types like tensor types,\ntuple types, and function types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"BaseType"}),", corresponding to the base type of a tensor (e.g.,\n",(0,i.jsx)(n.code,{children:"float32"}),", ",(0,i.jsx)(n.code,{children:"bool"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Shape"}),", corresponding to a tensor shape"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ShapeVar"}),", corresponding to variables within a tensor shape"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Relay's type system enforces that type parameters are only allowed to\nappear where their kind permits them, so if type variable ",(0,i.jsx)(n.code,{children:"t"})," is of kind\n",(0,i.jsx)(n.code,{children:"Type"}),", ",(0,i.jsx)(n.code,{children:"Tensor[t, float32]"})," is not a valid type."]}),"\n",(0,i.jsx)(n.p,{children:"Like normal parameters, concrete arguments must be given for type\nparameters at call sites."}),"\n",(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"s"})," below is a type parameter of kind ",(0,i.jsx)(n.code,{children:"Shape"})," and it will\nbe substituted with ",(0,i.jsx)(n.code,{children:"(10, 10)"})," at the call site below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"def @plus<s : Shape>(%t1 : Tensor[s, float32], %t2 : Tensor[s, float32]) {\n     add(%t1, %t2)\n}\nplus<(10, 10)>(%a, %b)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TypeVar"})," for its\ndefinition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"type-constraint",children:"Type Constraint"}),"\n",(0,i.jsx)(n.p,{children:"This is an abstract class representing a type constraint, to be\nelaborated upon in further releases. Currently, type relations are the\nonly type constraints provided; they are discussed below."}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TypeConstraint"}),"\nfor its definition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"function-type",children:"Function Type"}),"\n",(0,i.jsx)(n.p,{children:"A function type in Relay, see [tvm/relay/type.h] for more\ndetails."}),"\n",(0,i.jsx)(n.p,{children:"This is the type assigned to functions in Relay. A function type\nconsists of a list of type parameters, a set of type constraints, a\nsequence of argument types, and a return type."}),"\n",(0,i.jsxs)(n.p,{children:["We informally write function types as:\n",(0,i.jsx)(n.code,{children:"fn<type_params>(arg_types) -> ret_type where type_constraints"})]}),"\n",(0,i.jsx)(n.p,{children:"A type parameter in the function type may appear in the argument types\nor the return types. Additionally, each of the type constraints must\nhold at every call site of the function. The type constraints typically\ntake the function's argument types and the function's return type as\narguments, but may take a subset instead."}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"FuncType"})," for its\ndefinition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"type-relation",children:"Type Relation"}),"\n",(0,i.jsxs)(n.p,{children:["A type relation is the most complex type system feature in Relay. It\nallows users to extend type inference with new rules. We use type\nrelations to define types for operators that work with tensor shapes in\ncomplex ways, such as broadcasting operators or ",(0,i.jsx)(n.code,{children:"flatten"}),", allowing\nRelay to statically reason about the shapes in these cases."]}),"\n",(0,i.jsxs)(n.p,{children:["A type relation ",(0,i.jsx)(n.code,{children:"R"})," describes a relationship between the input and\noutput types of a Relay function. Namely, ",(0,i.jsx)(n.code,{children:"R"})," is a function on types\nthat outputs [true] if the relationship holds and\n[false] if it fails to hold. Types given to a relation may\nbe incomplete or include shape variables, so type inference must assign\nappropriate values to incomplete types and shape variables for necessary\nrelations to hold, if such values exist."]}),"\n",(0,i.jsx)(n.p,{children:"For example we can define an identity relation to be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"Identity(I, I) :- true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It is usually convenient to type operators in Relay by defining a\nrelation specific to that operator that encodes all the necessary\nconstraints on the argument types and the return type. For example, we\ncan define the relation for ",(0,i.jsx)(n.code,{children:"flatten"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"Flatten(Tensor(sh, bt), O) :-\n  O = Tensor(sh[0], prod(sh[1:]))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we have a relation like ",(0,i.jsx)(n.code,{children:"Broadcast"})," it becomes possible to type\noperators like ",(0,i.jsx)(n.code,{children:"add"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"add : fn<t1 : Type, t2 : Type, t3 : Type>(t1, t2) -> t3\n            where Broadcast\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The inclusion of ",(0,i.jsx)(n.code,{children:"Broadcast"})," above indicates that the argument types and\nthe return type must be tensors where the shape of ",(0,i.jsx)(n.code,{children:"t3"})," is the broadcast\nof the shapes of ",(0,i.jsx)(n.code,{children:"t1"})," and ",(0,i.jsx)(n.code,{children:"t2"}),". The type system will accept any argument\ntypes and return type so long as they fulfill ",(0,i.jsx)(n.code,{children:"Broadcast"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that the above example relations are written in Prolog-like syntax,\nbut currently the relations must be implemented by users in C++ or\nPython. More specifically, Relay's type system uses an ",(0,i.jsx)(n.em,{children:"ad hoc"})," solver\nfor type relations in which type relations are actually implemented as\nC++ or Python functions that check whether the relation holds and\nimperatively update any shape variables or incomplete types. In the\ncurrent implementation, the functions implementing relations should\nreturn ",(0,i.jsx)(n.code,{children:"False"})," if the relation fails to hold and ",(0,i.jsx)(n.code,{children:"True"})," if the relation\nholds or if there is not enough information to determine whether it\nholds or not."]}),"\n",(0,i.jsx)(n.p,{children:"The functions for all the relations are run as needed (if an input is\nupdated) until one of the following conditions holds:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"All relations hold and no incomplete types remain (typechecking\nsucceeds)."}),"\n",(0,i.jsx)(n.li,{children:"A relation fails to hold (a type error)."}),"\n",(0,i.jsx)(n.li,{children:"A fixpoint is reached where shape variables or incomplete types\nremain (either a type error or more type annotations may be needed)."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Presently all of the relations used in Relay are implemented in C++. See\nthe files in ",(0,i.jsx)(n.code,{children:"src/relay/op"})," for examples of relations implemented in\nC++."]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TypeRelation"})," for\nits definition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"incomplete-type",children:"Incomplete Type"}),"\n",(0,i.jsx)(n.p,{children:"An incomplete type is a type or portion of a type that is not yet known.\nThis is only used during type inference. Any omitted type annotation is\nreplaced by an incomplete type, which will be replaced by another type\nat a later point."}),"\n",(0,i.jsx)(n.p,{children:'Incomplete types are known as "type variables" or "type holes" in\nthe programming languages literature. We use the name "incomplete\ntype" in order to more clearly distinguish them from type parameters:\nType parameters must be bound to a function and are replaced with\nconcrete type arguments (instantiated) at call sites, whereas incomplete\ntypes may appear anywhere in the program and are filled in during type\ninference.'}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"IncompleteType"}),"\nfor its definition and documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"algebraic-data-types",children:"Algebraic Data Types"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Note: ADTs are not currently supported in the text format."})}),"\n",(0,i.jsxs)(n.p,{children:["Algebraic data types (ADTs) are described in more detail in\n",(0,i.jsx)(n.code,{children:"their overview <adt-overview>"}),"; this\nsection describes their implementation in the type system."]}),"\n",(0,i.jsx)(n.p,{children:'An ADT is defined by a collection of named constructors, each of which\ntakes arguments of certain types. An instance of an ADT is a container\nthat stores the values of the constructor arguments used to produce it\nas well as the name of the constructor; the values can be retrieved by\ndeconstructing the instance by matching based on its constructor. Hence,\nADTs are sometimes called "tagged unions": like a C-style union, the\ncontents of an instance for a given ADT may have different types in\ncertain cases, but the constructor serves as a tag to indicate how to\ninterpret the contents.'}),"\n",(0,i.jsx)(n.p,{children:"From the type system's perspective, it is most pertinent that ADTs can\ntake type parameters (constructor arguments can be type parameters,\nthough ADT instances with different type parameters must be treated as\ndifferent types) and be recursive (a constructor for an ADT can take an\ninstance of that ADT, thus an ADT like a tree or list can be inductively\nbuilt up). The representation of ADTs in the type system must be able to\naccommodate these facts, as the below sections will detail."}),"\n",(0,i.jsx)(n.h3,{id:"global-type-variable",children:"Global Type Variable"}),"\n",(0,i.jsx)(n.p,{children:"To represent ADTs compactly and easily allow for recursive ADT\ndefinitions, an ADT definition is given a handle in the form of a global\ntype variable that uniquely identifies it. Each ADT definition is given\na fresh global type variable as a handle, so pointer equality can be\nused to distinguish different ADT names."}),"\n",(0,i.jsx)(n.p,{children:"For the purposes of Relay's type system, ADTs are differentiated by\nname; that means that if two ADTs have different handles, they will be\nconsidered different types even if all their constructors are\nstructurally identical."}),"\n",(0,i.jsx)(n.p,{children:"Recursion in an ADT definition thus follows just like recursion for a\nglobal function: the constructor can simply reference the ADT handle\n(global type variable) in its definition."}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"GlobalTypeVar"})," for\nits definition and documentation."]}),"\n",(0,i.jsx)(n.h3,{id:"definitions-type-data",children:"Definitions (Type Data)"}),"\n",(0,i.jsxs)(n.p,{children:["Besides a name, an ADT needs to store the constructors that are used to\ndefine it and any type parameters used within them. These are stored in\nthe module,\n",(0,i.jsx)(n.code,{children:"analogous to global function definitions<module-description>"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"While type-checking uses of ADTs, the type system sometimes must index\ninto the module using the ADT name to look up information about\nconstructors. For example, if a constructor is being pattern-matched in\na match expression clause, the type-checker must check the\nconstructor's signature to ensure that any bound variables are being\nassigned the correct types."}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TypeData"})," for its\ndefinition and documentation."]}),"\n",(0,i.jsx)(n.h3,{id:"type-call",children:"Type Call"}),"\n",(0,i.jsxs)(n.p,{children:["Because an ADT definition can take type parameters, Relay's type system\nconsiders an ADT definition to be a ",(0,i.jsx)(n.em,{children:"type-level function"})," (in that the\ndefinition takes type parameters and returns the type of an ADT instance\nwith those type parameters). Thus, any instance of an ADT is typed using\na type call, which explicitly lists the type parameters given to the ADT\ndefinition."]}),"\n",(0,i.jsxs)(n.p,{children:["It is important to list the type parameters for an ADT instance, as two\nADT instances built using different constructors but the same type\nparameters are of the ",(0,i.jsx)(n.em,{children:"same type"})," while two ADT instances with different\ntype parameters should not be considered the same type (e.g., a list of\nintegers should not have the same type as a list of pairs of floating\npoint tensors)."]}),"\n",(0,i.jsx)(n.p,{children:'The "function" in the type call is the ADT handle and there must be\none argument for each type parameter in the ADT definition. (An ADT\ndefinition with no arguments means that any instance will have no type\narguments passed to the type call).'}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.code,{children:"TypeCall"})," for its\ndefinition and documentation."]}),"\n",(0,i.jsx)(n.h3,{id:"example-list-adt",children:"Example: List ADT"}),"\n",(0,i.jsx)(n.p,{children:"This subsection uses the simple list ADT (included as a default ADT in\nRelay) to illustrate the constructs described in the previous sections.\nIts definition is as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"data List<a> {\n  Nil : () -> List\n  Cons : (a, List[a]) -> List\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Thus, the global type variable ",(0,i.jsx)(n.code,{children:"List"})," is the handle for the ADT. The\ntype data for the list ADT in the module notes that ",(0,i.jsx)(n.code,{children:"List"})," takes one\ntype parameter and has two constructors, ",(0,i.jsx)(n.code,{children:"Nil"})," (with signature\n",(0,i.jsx)(n.code,{children:"fn<a>() -> List[a]"}),") and ",(0,i.jsx)(n.code,{children:"Cons"})," (with signature\n",(0,i.jsx)(n.code,{children:"fn<a>(a, List[a]) -> List[a]"}),"). The recursive reference to ",(0,i.jsx)(n.code,{children:"List"})," in\nthe ",(0,i.jsx)(n.code,{children:"Cons"})," constructor is accomplished by using the global type variable\n",(0,i.jsx)(n.code,{children:"List"})," in the constructor definition."]}),"\n",(0,i.jsx)(n.p,{children:"Below two instances of lists with their types given, using type calls:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Cons(1, Cons(2, Nil())) # List[Tensor[(), int32]]\nCons((1, 1), Cons((2, 2), Nil())) # List[(Tensor[(), int32], Tensor[(), int32])]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"Nil()"})," can be an instance of any list because it does not\ntake any arguments that use a type parameter. (Nevertheless, for any\n",(0,i.jsx)(n.em,{children:"particular"})," instance of ",(0,i.jsx)(n.code,{children:"Nil()"}),", the type parameter must be specified.)"]}),"\n",(0,i.jsx)(n.p,{children:"Here are two lists that are rejected by the type system because the type\nparameters do not match:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# attempting to put an integer on a list of int * int tuples\nCons(1, Cons((1, 1), Nil()))\n# attempting to put a list of ints on a list of lists of int * int tuples\nCons(Cons(1, Cons(2, Nil())), Cons(Cons((1, 1), Cons((2, 2), Nil())), Nil()))\n"})})]})}function p(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},21494:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return r}});var s=t(39546);let i={},a=s.createContext(i);function r(e){let n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);