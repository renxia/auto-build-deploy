{"searchDocs":[{"title":"Elasticsearch 入门","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/getting_started/","content":"Elasticsearch 入门 准备试用 Elasticsearch，并且看看你怎么用 REST API 去存储、搜索和分析数据？ 通过本入门教程，可以： 启动并运行 Elasticsearch 集群索引一些示例文档使用 Elasticsearch 查询语言搜索文档使用桶（bucket）和指标（metrics）聚合来分析结果 需要更多的背景吗？ 查看Elasticsearch 简介 以学习术语，并理解 Elasticsearch运行的基本原理。如果你已熟悉 Elasticsearch，并且想要了解它如何与栈(Elastic Stack)的其他部分一起运行，那你可能希望跳到Elastic Stack 教程 去了解如何使用 Elasticsearch、Kibana、Beats和Logstash 去设置系统监控方案。 注意 最快的入门 Elasticsearch 的方法是在云中免费试用14天 Elasticsearch 服务。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"何去何从","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/getting_started/nextstep","content":"何去何从 现在你部署了一个集群，索引了一些文档以及执行了一些搜索和聚合，你可能还想： 深入 Elastic Stack 教程，安装 Kibana、Logstash 和 Beats，并设置一个基本的系统监控方案。 向 Kibana 加载一个示例数据集，以了解如何将 Elasticsearch 和 Kibana 结合用以可视化数据。 尝试 Elastic 搜索方案之一： 网站搜索应用搜索企业搜索 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"启动并运行 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/getting_started/install","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"在 Elastic Cloud 上运行 Elasticsearch​","type":1,"pageTitle":"启动并运行 Elasticsearch","url":"/docs/elasticsearch-cn/getting_started/install#在-elastic-cloud-上运行-elasticsearch","content":"当你在 Elasticsearch 服务中创建部署时，这个服务提供一个三节点的 Elasticsearch 集群、Kibana 以及 APM。 为了创建部署： 注册一个免费的试用并验证你的电子邮箱地址。为你的账户设置密码。点击创建部署。 一旦你创建了一个部署，你就能索引一些文档。 ","version":"Next","tagName":"h2"},{"title":"在 Linux、macOS 或 Windows 本地运行 Elasticsearch​","type":1,"pageTitle":"启动并运行 Elasticsearch","url":"/docs/elasticsearch-cn/getting_started/install#在-linuxmacos-或-windows-本地运行-elasticsearch","content":"当你在 Elasticsearch 服务中创建一个部署时，将会自动提供一个主节点和两个数据节点。通过用 tar 或者 zip 压缩包安装，你可以在本地启动多个 Elasticsearch 实例，以查看多节点集群的行为。 在本地运行一个三节点 Elasticsearch 集群： 为你的操作系统下载 Elasticsearch 压缩包： Linux: elasticsearch-7.11.1-linux-x86_64.tar.gz curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-linux-x86_64.tar.gz  macOS: elasticsearch-7.11.1-darwin-x86_64.tar.gz curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-darwin-x86_64.tar.gz  Windows: elasticsearch-7.11.1-windows-x86_64.zip 解压文件： Linux: tar -xvf elasticsearch-7.11.1-linux-x86_64.tar.gz  macOS: tar -xvf elasticsearch-7.11.1-darwin-x86_64.tar.gz  Windows PowerShell: Expand-Archive elasticsearch-7.11.1-windows-x86_64.zip  从 bin 目录中启动 Elasticsearch： Linux and macOS: cd elasticsearch-7.11.1/bin ./elasticsearch  Windows: cd elasticsearch-7.11.1\\bin .\\elasticsearch.bat  现在你就运行起了一个单节点 Elasticsearch 集群！ 再启动两个 Elasticsearch 实例，你就能看到典型的多节点集群行为。你需要为每个节点指定唯一的数据和日志路径。 Linux and macOS: ./elasticsearch -Epath.data=data2 -Epath.logs=log2 ./elasticsearch -Epath.data=data3 -Epath.logs=log3  Windows: .\\elasticsearch.bat -E path.data=data2 -E path.logs=log2 .\\elasticsearch.bat -E path.data=data3 -E path.logs=log3  额外的节点将被分配唯一的 ID。由于你在本地运行的所有三节点，他们将自动与第一个节点加入集群。 使用 cat health API 验证你的三节点集群是否正运行。这个 cat API 以比原生 JSON 更易读的格式返回关于集群和索引的信息。 你可以通过 Elasticsearch REST API 提交 HTTP 请求，直接与集群交互。如果你安装和运行了 Kibana，你也可以打开 Kibana，并通过开发控制台（Dev Console）提交请求。 提示 当你准备在自己的应用程序中开始使用 Elasticsearch 时，你可能想查看Elasticsearch 语言客户端。 GET /_cat/health?v=true  响应应该指示 Elasticsearch 集群的状态是绿色，且它有三个节点： epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent 1565052807 00:53:27 elasticsearch green 3 3 6 3 0 0 0 0 - 100.0%  提示 如果仅有一个 Elasticsearch 单实例，集群状态会保持为黄色。一个单节点集群是功能完整的，但数据不能被复制到另一个节点以提供弹性。集群状态为绿色时，副本分片必定可用。如果集群状态为红色，某些数据不可用。 ","version":"Next","tagName":"h2"},{"title":"使用 cURL 命令与 Elasticsearch 交互​","type":1,"pageTitle":"启动并运行 Elasticsearch","url":"/docs/elasticsearch-cn/getting_started/install#使用-curl-命令与-elasticsearch-交互","content":"本指南中的大部分示例，允许你复制合适的 cURL 命令，并从命令行中向本地 Elasticsearch 实例提交请求。 对 Elasticsearch 的请求包含与任何 HTTP 请求相同的部分： curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'  这个示例使用以下变量： &lt;VERB&gt; 合适的 HTTP 方法或操作。例如，GET、POST、PUT、HEAD 或 DELETE。 &lt;PROTOCOL&gt; http 或 https。如果你在 Elasticsearch 之前有 HTTPS 代理，或者你使用的 Elasticsearch 安全特性去加密 HTTP 通信，使用后者。 &lt;HOST&gt; Elasticsearch 集群的任意节点主机名。或者对本地机器上的节点使用 localhost。 &lt;PORT&gt; 运行 Elasticsearch HTTP服务的端口，默认为 9200。 &lt;PATH&gt; API路径，可以包含多部分，比如 _cluster/stats 或 _nodes/stats/jvm。 &lt;QUERY_STRING&gt; 一些可选的查询字符串参数。比如，?pretty 将打印 JSON 响应以使其更易阅读。 &lt;BODY&gt; JSON 编码的请求体（如果必须）。 如果启用了 Elasticsearch 安全特性，你必须提供用于认证运行 API 的有效用户名（以及密码）。例如，使用 -u 或 --u 的 cURL 命令参数。有关运行每个 API 需要的安全权限的详情，参看 REST API。 Elasticsearch 对每个 API 请求响应 HTTP 状态码，如 200 ok。除了 HEAD 请求外，它还会返回一个 JSON 编码的响应体。 ","version":"Next","tagName":"h2"},{"title":"其他安装方式​","type":1,"pageTitle":"启动并运行 Elasticsearch","url":"/docs/elasticsearch-cn/getting_started/install#其他安装方式","content":"从压缩文件安装 Elasticsearch，使你可能轻松地在本地安装和运行多个实例，然后你可以去尝试。为了运行一个单实例，你可以在 Docker 容器中运行 Elasticsearch，可以在 Linux 上通过 DEB 或 RPM 包、在 macOS 上通过 Homebrew，或者在 Windows 上用 MSI 包安装 Elasticsearch。查看安装 Elasticsearch 获取更多信息。 原文链接 ","version":"Next","tagName":"h2"},{"title":"索引一些文档","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/getting_started/esindex","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"批量索引文档​","type":1,"pageTitle":"索引一些文档","url":"/docs/elasticsearch-cn/getting_started/esindex#批量索引文档","content":"如果你有大量文档要索引，你能通过批量 API（bulk API） 来批量提交它们。批量文档操作比单独提交请求显著更快，因为它极简了网络往返。 最佳的批量数量取决于许多因素：文档的大小和复杂度、索引和搜索的负载以及集群可用资源。一种好的方式是批量处理 1,000 到 5,000 个文档，且总负载在 5 MB 到 15 MB。基于这个，你能尝试找到最佳的方式。 向 Elasticsearch 导入一些数据，你就能开始搜索和分析： 下载 accounts.json 示例数据集。这个随机生成的数据集文档表示具体以下信息的用户账户： { &quot;account_number&quot;: 0, &quot;balance&quot;: 16623, &quot;firstname&quot;: &quot;Bradshaw&quot;, &quot;lastname&quot;: &quot;Mckenzie&quot;, &quot;age&quot;: 29, &quot;gender&quot;: &quot;F&quot;, &quot;address&quot;: &quot;244 Columbus Place&quot;, &quot;employer&quot;: &quot;Euron&quot;, &quot;email&quot;: &quot;bradshawmckenzie@euron.com&quot;, &quot;city&quot;: &quot;Hobucken&quot;, &quot;state&quot;: &quot;CO&quot; }  使用以下的 _bulk 请求将账户数据索引到银行（bank） 索引中： curl -H &quot;Content-Type: application/json&quot; -XPOST &quot;localhost:9200/bank/_bulk?pretty&amp;refresh&quot; --data-binary &quot;@accounts.json&quot; curl &quot;localhost:9200/_cat/indices?v=true&quot;  响应表明 1,000 个文档被成功索引： health status index uuid pri rep docs.count docs.deleted store.size pri.store.size yellow open bank l7sSYV2cQXmu6_4rJWVIww 5 1 1000 0 128.6kb 128.6kb  原文链接 ","version":"Next","tagName":"h2"},{"title":"使用聚合分析结果","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/getting_started/aggregations","content":"使用聚合分析结果 Elasticsearch 聚合能让你获取搜索结果的元信息，并回答这些问题，如“德克萨斯州有多少账户所有者？”或“田纳西州的账户平均余额是多少？”。你可以在一个请求中搜索文档、过滤命中以及使用聚合分析结果。 例如，以下的请求使用一个词语聚合分组在银行（bank）索引中按州对所有账户分组，并按降序返回账户最多的十个州： GET /bank/_search { &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;group_by_state&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot; } } } } 响应中的桶（bucket）是州（state）字段的值。doc_count 显示每个州的账户数量。例如，你可以看到 ID（爱达荷州）有 27 个账户。由于这个请求设置 size=0，这个请求只包含聚合结果。 { &quot;took&quot;: 29, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot; : 0, &quot;failed&quot;: 0 }, &quot;hits&quot; : { &quot;total&quot; : { &quot;value&quot;: 1000, &quot;relation&quot;: &quot;eq&quot; }, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] }, &quot;aggregations&quot; : { &quot;group_by_state&quot; : { &quot;doc_count_error_upper_bound&quot;: 20, &quot;sum_other_doc_count&quot;: 770, &quot;buckets&quot; : [ { &quot;key&quot; : &quot;ID&quot;, &quot;doc_count&quot; : 27 }, { &quot;key&quot; : &quot;TX&quot;, &quot;doc_count&quot; : 27 }, { &quot;key&quot; : &quot;AL&quot;, &quot;doc_count&quot; : 25 }, { &quot;key&quot; : &quot;MD&quot;, &quot;doc_count&quot; : 25 }, { &quot;key&quot; : &quot;TN&quot;, &quot;doc_count&quot; : 23 }, { &quot;key&quot; : &quot;MA&quot;, &quot;doc_count&quot; : 21 }, { &quot;key&quot; : &quot;NC&quot;, &quot;doc_count&quot; : 21 }, { &quot;key&quot; : &quot;ND&quot;, &quot;doc_count&quot; : 21 }, { &quot;key&quot; : &quot;ME&quot;, &quot;doc_count&quot; : 20 }, { &quot;key&quot; : &quot;MO&quot;, &quot;doc_count&quot; : 20 } ] } } } 你可以合并聚合来构建更复杂的数据摘要。例如，以下请求在前一个按州分组（group_by_state）聚合嵌套一个 avg 聚合，以计算每个州的平均账户余额。 GET /bank/_search { &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;group_by_state&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot; }, &quot;aggs&quot;: { &quot;average_balance&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;balance&quot; } } } } } } 你可以使用嵌套聚合结果进行排序（通过指定词语聚合顺序），而不是按计数结果进行排序： GET /bank/_search { &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;group_by_state&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;state.keyword&quot;, &quot;order&quot;: { &quot;average_balance&quot;: &quot;desc&quot; } }, &quot;aggs&quot;: { &quot;average_balance&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;balance&quot; } } } } } } 除了这些基本的桶和度量聚合外，Elasticsearch 提供了特定的聚合用于操作多个字段和分析特定类型数据，如日期、IP 地址以及地理数据。你还可以将单个聚合的结果输入管道聚合用于进一步的分析。 聚合提供的核心分析能力支持高级特性，如使用机器学习来检测异常。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"开始搜索","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/getting_started/search","content":"开始搜索 一旦你已将一些数据存入 Elasticsearch 索引，你就能通过向 _search 端点发送请求来搜索它。为了获取所有的搜索能力，你可以在请求体中使用 Elasticsearch 的查询 DSL 指定搜索条件。你可以在请求 URI 中指定你想要搜索的索引名称。 例如，以下请求获取按账号排序的银行（bank）索引中的所有文档： GET /bank/_search { &quot;query&quot;: { &quot;match_all&quot;: {} }, &quot;sort&quot;: [ { &quot;account_number&quot;: &quot;asc&quot; } ] } 默认情况下，响应的命中部分（hits section）包含符合搜索条件的前10个文档： { &quot;took&quot; : 63, &quot;timed_out&quot; : false, &quot;_shards&quot; : { &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 }, &quot;hits&quot; : { &quot;total&quot; : { &quot;value&quot;: 1000, &quot;relation&quot;: &quot;eq&quot; }, &quot;max_score&quot; : null, &quot;hits&quot; : [ { &quot;_index&quot; : &quot;bank&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;0&quot;, &quot;sort&quot;: [0], &quot;_score&quot; : null, &quot;_source&quot; : {&quot;account_number&quot;:0,&quot;balance&quot;:16623,&quot;firstname&quot;:&quot;Bradshaw&quot;,&quot;lastname&quot;:&quot;Mckenzie&quot;,&quot;age&quot;:29,&quot;gender&quot;:&quot;F&quot;,&quot;address&quot;:&quot;244 Columbus Place&quot;,&quot;employer&quot;:&quot;Euron&quot;,&quot;email&quot;:&quot;bradshawmckenzie@euron.com&quot;,&quot;city&quot;:&quot;Hobucken&quot;,&quot;state&quot;:&quot;CO&quot;} }, { &quot;_index&quot; : &quot;bank&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;sort&quot;: [1], &quot;_score&quot; : null, &quot;_source&quot; : {&quot;account_number&quot;:1,&quot;balance&quot;:39225,&quot;firstname&quot;:&quot;Amber&quot;,&quot;lastname&quot;:&quot;Duke&quot;,&quot;age&quot;:32,&quot;gender&quot;:&quot;M&quot;,&quot;address&quot;:&quot;880 Holmes Lane&quot;,&quot;employer&quot;:&quot;Pyrami&quot;,&quot;email&quot;:&quot;amberduke@pyrami.com&quot;,&quot;city&quot;:&quot;Brogan&quot;,&quot;state&quot;:&quot;IL&quot;} }, ... ] } } 这个响应也提供关于搜索请求的以下信息： took —— Elasticsearch 执行查询的耗时（毫秒）timed_out —— 搜索请求是否超时_shards —— 多少分片被搜索，以及成功、失败或跳过的分片详情max_score —— 查找到的最相关的文档分数hits.total.value —— 查找到匹配文档数量hits.sort —— 文档的排序位置（不按相关分数排序时）hits._score —— 文档的相关分数（不适用于使用 match_all） 每个搜索请求都是独立的：Elasticsearch 不在请求间维护任何状态信息。在请求中指定 from 和 size 参数用来分页浏览搜索结果。 例如，以下请求获取 10 到 19 的结果： GET /bank/_search { &quot;query&quot;: { &quot;match_all&quot;: {} }, &quot;sort&quot;: [ { &quot;account_number&quot;: &quot;asc&quot; } ], &quot;from&quot;: 10, &quot;size&quot;: 10 } 现在你已看到如何提交基本查询请求，你可以开始构造比 match_all 更有趣的查询。 为了在字段中搜索指定词语，你可以使用匹配查询。例如，以下的查询搜索地址（address）字段，用以查找地址包含 mill 或 lane的客户： GET /bank/_search { &quot;query&quot;: { &quot;match&quot;: { &quot;address&quot;: &quot;mill lane&quot; } } } 为了执行短语搜索而不是匹配单独的词语，你可以使用 match_phrase 替代 match。例如，以下请求只匹配包含短语 mill lane 的地址： GET /bank/_search { &quot;query&quot;: { &quot;match_phrase&quot;: { &quot;address&quot;: &quot;mill lane&quot; } } } 为了构造更复杂的查询，你可以使用包含多个查询条件的 bool 的查询。你可以按必须的（必须匹配）、可选的（应该匹配）或者不必的（必须不匹配）来指定条件。 例如，以下请求搜索银行（bank）索引中属于 40 岁客户的账号，但排除其中住在爱达荷州（ID）的人： GET /bank/_search { &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;age&quot;: &quot;40&quot; } } ], &quot;must_not&quot;: [ { &quot;match&quot;: { &quot;state&quot;: &quot;ID&quot; } } ] } } } 布尔查询中的每个 must、should 和 must_not 都称为查询子句。文档满足每个 must 或 should 条件子句的程度，有助于文档相关性的分数。分数越高，文档越符合你的搜索条件。默认情况下，Elasticsearch 返回按相关性分数排序的文档。 must_not 子句中的条件被认作过滤器。它影响文档是否包含在结果中，但不影响文档分数。你可以显式地指定任意的过滤器，用来包含或排除基于结构化数据的文档。 例如，以下请求使用范围过滤器用以限定结果中账户余额在 $20,000 和 $30,000（含）之间。 GET /bank/_search { &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: { &quot;match_all&quot;: {} }, &quot;filter&quot;: { &quot;range&quot;: { &quot;balance&quot;: { &quot;gte&quot;: 20000, &quot;lte&quot;: 30000 } } } } } } 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"分析","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/analysis","content":"分析 索引分析模块充当分析器的可配置注册表，它可用于将字符串字段转为独立的词语，这些词语包括： 添加到倒排索引以使文档可搜索由高级查询，如匹配查询(match query)用于生成搜索词 参阅文本分析获取配置详情。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引块","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_blocks","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引块设置​","type":1,"pageTitle":"索引块","url":"/docs/elasticsearch-cn/index_modules/index_blocks#索引块设置","content":"以下的动态（dynamic）索引设置会影响索引上已存在的块： index.blocks.read_only 设置 true 时，索引及索引元数据只读，false 允许写以及元数据变更。 index.blocks.read_only_allow_delete 类似于 index.blocks.read_only，但也允许删除索引以获取更多资源。基于硬盘的分片分配器可以自动添加和移除块。 从索引中删除文档以释放资源——而不是删除索引本身——随着时间推移会增加索引大小。当 index.blocks.read_only_allow_delete 设置为 true 时，删除索引是不允许的。然而，删除索引自身会释放只读索引块，并使资源几乎立即可用。 警告 在磁盘利用率低于高水位线时，Elasticsearch 自动添加和移除只读索引块，由 cluster.routing.allocation.disk.watermark.flood_stage 控制。 index.blocks.read 设置为 true，可禁用对索引的读取操作。 index.blocks.write 设置为 true，可禁用对索引的数据写操作。不像 read_only，这个设置不会影响元数据。例如，你可以用 write（写）块关闭索引，但不能用 read_only(只读)块关闭索引。 index.blocks.metadata 设置为 true，禁用索引元数据读写。 ","version":"Next","tagName":"h2"},{"title":"添加索引块 API​","type":1,"pageTitle":"索引块","url":"/docs/elasticsearch-cn/index_modules/index_blocks#添加索引块-api","content":"为索引添加一个索引块。 PUT /my-index-000001/_block/write  ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"索引块","url":"/docs/elasticsearch-cn/index_modules/index_blocks#请求","content":"PUT /&lt;index&gt;/_block/&lt;block&gt; ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"索引块","url":"/docs/elasticsearch-cn/index_modules/index_blocks#路径参数","content":"&lt;index&gt; （可选，字符串）逗号分隔的列表或通配符表达式的索引名称，用于限定请求。 为所有索引添加块，使用 _all 或 *。为了禁止通过 _all 或通配符表达式添加块，修改集群设置 action.destructive_requires_name 为 true。你可以在文件 elasticsearch.yml 中修改设置，或者通过集群更新设置 API。 &lt;block&gt; （必需，字符串）添加给索引的块类型。 有效值： metadata禁用元数据变更，比如关闭索引。read禁用读操作。read_only禁用写操作和元数据变更。write禁用写操作。然后，允许元数据变更。 ","version":"Next","tagName":"h3"},{"title":"查询参数​","type":1,"pageTitle":"索引块","url":"/docs/elasticsearch-cn/index_modules/index_blocks#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h3"},{"title":"例子​","type":1,"pageTitle":"索引块","url":"/docs/elasticsearch-cn/index_modules/index_blocks#例子","content":"以下例子展示如何添加一个索引块： PUT /my-index-000001/_block/write  API 返回以下响应： { &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;indices&quot; : [ { &quot;name&quot; : &quot;my-index-000001&quot;, &quot;blocked&quot; : true } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"索引模块","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引设置​","type":1,"pageTitle":"索引模块","url":"/docs/elasticsearch-cn/index_modules/#索引设置","content":"可以为每个索引设置索引级的设置。设置如下： 静态设置 只能在索引创建时，或者关闭的索引上设置。 动态设置 可以通过更新索引 API 在活动的索引上修改。 警告 在关闭的索引上修改静态或动态索引设置，可能会导致不正确的设置。如果不删除并重建索引，是无法修正这些设置。 ","version":"Next","tagName":"h2"},{"title":"静态索引设置​","type":1,"pageTitle":"索引模块","url":"/docs/elasticsearch-cn/index_modules/#静态索引设置","content":"以下是与特定索引模块无关的静态索引设置的列表： index.number_of_shards 索引应该具有的主分片数量。默认为 1。此设置只能在创建索引时设置。在关闭的索引上也不能修改。 提示 每个分片数量限定为 1,024。这是一个安全限定，以防止意外创建索引，而这些索引会由于资源分配而破坏集群的稳定性。这个限定可以通过指定 export ES_JAVA_OPTS=&quot;-Des.index.max_number_of_shards=128&quot; 系统属性来修改，这个属性属于集群的每个节点。 index.number_of_routing_shards 用于拆分索引的路由分片数。 例如，number_of_routing_shards 设置为 30（5 x 3 x 2）的 5 分片索引，可以除以因子 2 或 3。换言之，可以按以下方式拆分： 5 → 10 → 30 (除以 2, 再除以 3)5 → 15 → 30 (除以 3, 再除以 2)5 → 30 (除以 6) 这个设置的默认值基于索引的主分片数。默认情况下，允许按 2 的因子拆分最多 1,024 个分片。 提示 在 Elasticsearch 7.0.0 以及更新的版本，这个设置影响文档在分片中的分布方式。使用自定义路由重新索引旧索引时，你必须显式设置 index.number_of_routing_shards 以维持相同的文档分布。参阅相关的碎裂变化。 index.shard.check_on_startup 在打开之前是否应该检查分片是否损坏。当检测到损坏时，它将阻止打开分片，允许的值： - `false` （默认值）当打开分片时不检测损坏。 - `checksum` 检测物理损坏。 - `true` 检测物理和逻辑损坏。这会消耗更高的 CPU 和内存。  警告 仅限专家。在大型索引上检查分片可能花费更多的时间。 index.codecdefault 值使用 LZ4 压缩来压缩存储的数据，但可以设置为 best_compression,即使用 DEFLATE 来获得更高的压缩比，但会降低存储字段的性能。如果要更新压缩类型，合并段后将应用新的压缩类型。段合并可以使用强制合并来强制合并。 index.routing_partition_size 自定义路由值可以转到的分片数。默认为 1，只能在索引创建时设置。此值必须小于 index.number_of_shards，除非 index.number_of_shards 值也是 1。参阅路由到索引分区，获取如何使用此设置的更多信息。 index.soft_deletes.enabled 标示索引是否允许软删除。软删除只能在索引创建时设置，也只能配置在 Elasticsearch 6.5.0 及后续版本创建的索引上。默认为 true。（7.6.0版本就不推荐，不推荐禁用软删除创建索引，并在未来版本移除此设置） index.soft_deletes.retention_lease.period 分片历史保持租约在它被认为过期前的最大周期。分片历史保留租约，确保在 Lucene 索引上进行合并时保留软删除。如果软删除在可以复制到跟随者之前被合并，由于领导者的历史记录不完整，后续过程将失败。默认为 12h。 index.load_fixed_bitset_filters_eagerly 标示是否为嵌套查询预加载缓存过滤器。可能值为 true（默认值）和 false。 index.hidden 标示默认情况下，索引是否应该隐藏。当使用通配符表达式时，隐藏索引默认不会返回。通过 expand_wildcards 参数，每个请求都可以控制此行为。可能的值为 true 和 false（默认值）。 ","version":"Next","tagName":"h2"},{"title":"动态索引设置​","type":1,"pageTitle":"索引模块","url":"/docs/elasticsearch-cn/index_modules/#动态索引设置","content":"以下是与任何特定索引模块无关的所有动态设置列表： index.number_of_replicas 每个主分片的副本数。默认为 1。 index.auto_expand_replicas 根据集群中数据节点的数量，自动扩展副本的数量。设置为以连接符分隔的下限和上限（如，0-5）或者使用 all 作为上限（如，0-all）。默认为 false（即禁用）。请注意自动扩展的副本数量只考虑分配筛选规则，而忽略其他分配规则，如分片分配感知和每个节点分片总数，如果适用规则阻止分配所有副本，则这可能导致集群健康变为 YELLOW（黄色）。 index.search.idle.after 在被认为是搜索空闲之前，分片不能接收搜索或获取请求的时间。（默认值为 30s） index.refresh_interval 执行刷新操作的频率，它可以使最近对索引的修改对搜索可见。默认为 1s。可以设置为 -1 为禁止刷新。如果这个设置未显示设置，则至少在 index.search.idle.after 秒后，未看到搜索流量的分片在收到搜索请求前不会接收后台刷新。此行为旨在在默认情况下，当不执行搜索时自动优化批量索引。为了选择退出此行为，应将显式值 1s 设置为刷新间隔。 index.max_result_window 搜索到此索引的 from + size 的最大值。默认为 10,000。搜索请求占用的堆内存和时间，与 from + size 成比例，这也限制了内存。参阅Scroll或Search After，以获得更有效的替换提高这一点。 index.max_inner_result_window 此索引的内部命中定义和顶级命中聚合的 from + size 的最大值。默认为 100。内部命中和顶级命中聚合占用的堆内存和时间，与 from + size 成比例，这也限制了内存。 index.max_rescore_window 此索引的搜索中 rescore 请求的 window_size 最大值。默认为 index.max_result_window的值（默认为 10,000）。搜索请求占用的堆内存和时间与 max(window_size, from + size) 成比例，这也限制了内存。 index.max_docvalue_fields_search 查询中允许的 docvalue_fields 最大值。默认为 100。文档值字段代价高昂，因为它们可能会导致每个文档查找每个字段。 index.max_script_fields 查询中允许的 script_fields 最大值。 默认为 32。 index.max_ngram_diff NGramTokenizer 和 NGramTokenFilter的 min_gram 和 max_gram 允许差值。默认为 1。 index.max_shingle_diff shingle 标记过滤器在 max_shingle_size 和 min_shingle_size 间允许的最大差异。默认为 3。 index.max_refresh_listeners 索引的每个分片上可用的刷新监听器的最大值。监听器常实现 refresh=wait_for index.analyze.max_token_count 使用 _analyze API 的可以生成的最大标记数。默认为 10,000。 index.highlight.max_analyzed_offset 用于高亮请求的分析的最大字符数。此设置仅用于对文本的高亮请求——此文本被不带偏移量或词语向量索引。默认为 1,000,000。 index.max_terms_count 用于词语查询（Terms Query）的词语最大值。默认为 65,536。 index.max_regex_length 用于正则查询（Regexp Query）的正则最大长度。默认为 1,000。 index.query.default_field （字符串或字符串数组）匹配一个或多个字段的通配符（*）模式。默认情况下，以下查询类型搜索这些匹配字段： 更像这样多重匹配查询字符串简单查询字符串 默认为 * ，它匹配所有符合词语级查询的字段，不包括元数据字段。 index.routing.allocation.enable 控制索引的分片分配。可设置为： all (默认) - 允许所有分片分片分配。 primaries - 允许主分片分片分配。 new_primaries - 允许新创建的主分片分片分配。 none - 不允许分片分配。 index.routing.rebalance.enable 允许索引分片重平衡。可设置为： all（默认） - 允许所有分片分片重平衡。 primaries - 允许主分片分片重平衡。 replicas - 允许副本分片分片重平衡。 none - 不允许分片重平衡。 index.gc_deletes 已删除文档版本号仍可用于进一步版本化操作的时长。默认为 60s。 index.default_pipeline 默认的索引输入节点管道。如果设置了默认管道，管道又不存在，索引请求将失败。可以使用 pipeline 参数覆盖默认值。特定的管道名称 _none 表明不运行输入管道。 index.final_pipeline 最终的索引输入节点管道。如果设置了默认管道，管道又不存在，索引请求将失败。最终管道始终在请求管道（如果指定）和默认管道（如果存在）之后运行。特定的管道名称 _none 表明不运行输入管道。 ","version":"Next","tagName":"h2"},{"title":"其他索引模块中的设置​","type":1,"pageTitle":"索引模块","url":"/docs/elasticsearch-cn/index_modules/#其他索引模块中的设置","content":"索引模块中的其他设置： 分析 设置默认的分析器、分词器、标记过滤器和字符过滤器。 索引分片分配 控制分片分配给节点的位置、时间和方式。 映射 允许或禁用索引的动态映射。 合并 控制如何通过后台合并进程合并分片。 相似性 配置自定义相似性设置以自定义搜索结果的评分方式。 慢日志 控制如何记录慢查询和取出请求（fetch query）日志。 存储 配置用于访问分片数据的文件系统类型。 事务日志 控制事务日志和后台刷新操作。 历史保留 控制索引操作历史的保留。 索引压力 配置索引背压限制。 ","version":"Next","tagName":"h2"},{"title":"X-Pack 索引设置 [X-Pack]​","type":1,"pageTitle":"索引模块","url":"/docs/elasticsearch-cn/index_modules/#x-pack-索引设置-x-pack","content":"索引生命周期管理 指定的索引的生命周期策略和翻转别名。 原文链接 ","version":"Next","tagName":"h2"},{"title":"索引分片分配","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/","content":"索引分片分配 该模块提供每个索引设置，以控制分片分配到节点： 分片分配过滤：控制将哪些分片分配给哪些节点。延迟分配：由于节点离开而导致的未分配分片的延迟分配。每节点的分片总数：对每个节点来自同一索引的分片数的硬限制。数据层分配：控制索引到数据层的分配。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引级数据层分配过滤","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/data_tier_allocation_filtering","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"数据层分配设置​","type":1,"pageTitle":"索引级数据层分配过滤","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/data_tier_allocation_filtering#数据层分配设置","content":"index.routing.allocation.include._tier 分配索引给节点，节点的 node.roles 配置至少有一个逗号分隔的值。 index.routing.allocation.require._tier 分配索引给节点，节点的 node.roles 配置有所有逗号分隔的值。 index.routing.allocation.exclude._tier 分配索引给节点，节点的 node.roles 配置没有任何逗号分隔的值。 index.routing.allocation.include._tier_preference 分配索引给列表中具有可用节点的第一层。如果优先层中没有节点，这会阻止索引保持未分配状态。例如，如果你设置 index.routing.allocation.include._tier_preference 为 data_warm,data_hot，那么如果有节点具有 data_warm 角色，索引会被分配到温（warm）层。如果在温层没有节点，但有节点具有 data_hot 角色，索引分被分配到热（hot）层。 原文链接 ","version":"Next","tagName":"h2"},{"title":"当节点离开时延迟分配","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/delaying_allocation","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"分片迁移取消​","type":1,"pageTitle":"当节点离开时延迟分配","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/delaying_allocation#分片迁移取消","content":"如果延迟分配超时，主节点分配丢失的分片到另一个节点，此节点将开始恢复。如果丢失的节点重加入集群，且它的分片仍然有与主分片相同的同步id，那么分片迁移将取消，并使用同步的分片进行恢复。 同于这个原因，默认的 timeout（超时）只设置为 1 分钟：即使分片迁移开始了，取消恢复而采用同步的分片也是低成本的。 ","version":"Next","tagName":"h2"},{"title":"监控延迟的未分配分片​","type":1,"pageTitle":"当节点离开时延迟分配","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/delaying_allocation#监控延迟的未分配分片","content":"按照超时设置延迟分配的分片数量，可以通过集群健康 API查看： GET _cluster/health  请求会返回 delayed_unassigned_shards 值。 ","version":"Next","tagName":"h2"},{"title":"永久移除节点​","type":1,"pageTitle":"当节点离开时延迟分配","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/delaying_allocation#永久移除节点","content":"如果一个节点不打算返回，且你希望 Elasticsearch 立即分配丢失的分片，只需要将超时设置为 0 ： PUT _all/_settings { &quot;settings&quot;: { &quot;index.unassigned.node_left.delayed_timeout&quot;: &quot;0&quot; } }  一旦丢失的分片开始恢复，就可以重置超时。 原文链接 ","version":"Next","tagName":"h2"},{"title":"索引恢复优先级","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/index_recovery_prioritization","content":"索引恢复优先级 无论何时，尽可能的按优先级顺序恢复未分析的分片。索引按优先级顺序排序，如下： 可选的 index.priority 设置（先高后低）索引创建日期（先高后低）索引名字（先高后低） 这意味着，默认情况下，新索引比旧索引先恢复。 使用每个索引动态可更新的 index.priority 设置用于自定义索引优先级顺序。例如： PUT index_1 PUT index_2 PUT index_3 { &quot;settings&quot;: { &quot;index.priority&quot;: 10 } } PUT index_4 { &quot;settings&quot;: { &quot;index.priority&quot;: 5 } } 在以上例子中： index_3 会首先恢复，因为它有最高的 index.priority。index_4 会接着恢复，因为它有第二高的优先级。index_2 会接着恢复，因为它是最近创建的。index_1 会最后恢复。 这个设置接受一个整数，也可以通过更新索引设置 API 在活动索引中更新。 PUT index_4/_settings { &quot;index.priority&quot;: 1 } 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"映射器","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/mapper","content":"映射器 映射器模块作为在创建索引时或使用更新映射 API 时，添加到索引的类型映射定义的注册表。它还处理对没有显式映射预定义的类型的动态映射支持。获取更多有关映射定义，参阅映射章节。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"每节点分片总数","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/total_shards_per_node","content":"每节点分片总数 集群级分片分配器尝试将单个索引的分片分布在尽可能多的节点上。然而，根据你有多少分片和索引，以及它们有多大，可能并不总是能够均匀地分布分片。 以下的 dynamic（动态）设置允许你对每个节点允许的单索引的分片总数，指定硬限制： index.routing.allocation.total_shards_per_node 将分配给单节点的分片（副本和主分片）最大数量。默认为无界。 你也可以限制节点可以拥有的分片数量，而不用考虑索引： cluster.routing.allocation.total_shards_per_node （动态）分配给每个节点的主分片和副本分片的最大数量。默认值为 -1（无限制）。 Elasticsearch 在分片分配期间检查此设置。例如，一个集群的 cluster.routing.allocation.total_shards_per_node 设置为 100，三个节点具有以下分片分配： 节点 A: 100 分片节点 B: 98 分片节点 C: 1 分片 如果节点 C 失败，Elasticsearch 重分配它的分片到节点 B。重分配分片到节点 A 会超出 A 的分片限制。 警告 这些设置强加了一个硬限制，这可能导致一些分片不被分配。 小心使用。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引级分片分配过滤","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/shard_allocation_filtering","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"启用索引级分片分配过滤​","type":1,"pageTitle":"索引级分片分配过滤","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/shard_allocation_filtering#启用索引级分片分配过滤","content":"为了基于自定义节点属性进行筛选： 在每个节点的 elasticsearch.yml 配置文件中指定具有自定义节点属性过滤器特征。例如，如果你有 small，medium 和 big 节点，你能添加一个基于节点大小过滤的 size 属性。 node.attr.size: medium  当你启动节点时，你也可以设置自定义属性： `./bin/elasticsearch -Enode.attr.size=medium  为索引添加路由分配过滤器。index.routing.allocation 设置支持三种过滤器：include、exclude 和 require。例如，要让 Elasticsearch 将测试索引中的分片分配给 big 或 medium 节点，使用 index.routing.allocation.include： PUT test/_settings { &quot;index.routing.allocation.include.size&quot;: &quot;big,medium&quot; }  如果你指定多个过滤器，则节点必须同时满足以下条件，以便分片重定位到其上： 如果指定了任何 require 类型条件，则所有条件必须满足如果指定了任何 exclude 类型条件，则条件都不用满足如果指定了任何 include 类型条件，则至少有一个条件必须满足 例如，要把测试索引移动到在 rack1 上的 big 节点，你可以指定： PUT test/_settings { &quot;index.routing.allocation.require.size&quot;: &quot;big&quot;, &quot;index.routing.allocation.require.rack&quot;: &quot;rack1&quot; }  ","version":"Next","tagName":"h2"},{"title":"索引分配过滤器设置​","type":1,"pageTitle":"索引级分片分配过滤","url":"/docs/elasticsearch-cn/index_modules/index_shard_allocation/shard_allocation_filtering#索引分配过滤器设置","content":"index.routing.allocation.include.{attribute} 将索引分配给节点，节点的 {attribute} 至少有逗号分隔的一个值。 index.routing.allocation.require.{attribute} 将索引分配给节点，节点 {attribute} 具有逗号分隔的所有值。 index.routing.allocation.exclude.{attribute} 将索引分配给节点，节点 {attribute} 不具有逗号分隔的任何值。 索引分配设置支持以下的内置属性： \t_name\t按节点名字匹配节点 _host_ip\t按主机 IP 地址匹配节点（关联主机名的 IP） _publish_ip\t按发布 IP 地址匹配节点 _ip\t匹配 _host_ip 或 _publish_ip _host\t按主机名匹配节点 _id\t按节点 id 匹配节点 _tier\t按节点数据层角色匹配节点。参阅数据层分配过滤获取更多详情。 当指定属性值时，你可以使用通配符，例如： PUT test/_settings { &quot;index.routing.allocation.include._ip&quot;: &quot;192.168.2.*&quot; }  原文链接 ","version":"Next","tagName":"h2"},{"title":"什么是 Elasticsearch？","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/intro/","content":"什么是 Elasticsearch？ 你懂的，用来搜索（也用来分析） Elasticsearch 是位于 Elastic Stack 中心的分布式搜索和分析引擎。Logstach 和 Beats 促进采集、合计以及充实你的数据并在 Elasticsearch 中存储它们。Kibana 允许你去交互式的探索、可视化和共享对数据的见解，以及监视这个栈（Elastic Stack）。Elasticsearch 是索引、搜索和分析的神奇所在。 Elasticsearch 为各种数据类型提供接近实时的搜索和分析。不论你有结构化或非结构化的文本、数字数据，还是地理空间数据，Elasticsearch 能以支持快速搜索的方式高效地存储和索引它。你可以远超简单数据检索和聚合信息的方式去发现你数据中的趋势和模式。而且，随着你数据和查询量的增长，Elasticsearch 分布式的特性允许你的部署能随着它无缝地增长匹配。 虽然不是每个问题都是搜索问题，但 Elasticsearch 在大量实例中提供了处理数据的速度和灵活性： 为应用或者网站添加搜索框存储和分析日志、度量和安全事件数据使用机器学习，实时自动建模你的数据行为使用 Elasticsearch 作为存储引擎来自动化业务工作流使用 Elasticsearch 作为地理信息系统（GIS）管理、集成和分析空间信息，以及使用 Elasticsearch 作为生物学信息研究工具处理基因数据 我们一直对人们使用搜索的新奇方式感觉惊奇。但是不论你的实例与其中一个相似，还是你正使用 Elasticsearch 来解决一个新的问题，你在 Elasticsearch处理数据、文档和索引的方式是相同的。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"信息输出：搜索和分析","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/intro/inforout","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"搜索你的数据​","type":1,"pageTitle":"信息输出：搜索和分析","url":"/docs/elasticsearch-cn/intro/inforout#搜索你的数据","content":"Elasticsearch REST API 支持结构化查询、全文查询以及结合二者的复杂查询。结构化查询类似于你在 SQL 中构造的查询类型。例如，你可以在职员索引中搜索性别和年龄字段，并按雇佣日期字段对匹配项进行排序。全文查询，查找查询字符串匹配的所有文档，且返回按相关性——他们与搜索词语匹配程度——排序的文档。 除了搜索单个词语，你也可以执行短语搜索、相似性搜索和前缀搜索，并且获得自动完成建议。 有你想搜索的地理空间或者其他数字数据吗？ Elasticsearch 在优化数据结构中索引非文本数据用于支持高性能地理和数字查询。 你可以访问使用 Elasticsearch 全部 JSON 风格的查询语言（查询 DSL）的所有搜索能力。你也可以构造 SQL 风格的查询搜索和聚合在 Elasticsearch 中的内部数据，JDBC 和 ODBC 驱动使得各种第三方应用能通过 SQL 与 Elasticsearch交互。 ","version":"Next","tagName":"h2"},{"title":"分析你的数据​","type":1,"pageTitle":"信息输出：搜索和分析","url":"/docs/elasticsearch-cn/intro/inforout#分析你的数据","content":"Elasticsearch 聚合使你能够构建数据的复杂摘要，并深入了解关键度量、模式和趋势。聚合使你能回答以下类似的问题，而不是仅仅找到众所周知的“大海捞针”： 大海中有多少针？针的平均长度是多少？按制造商分类，针的平均长度是多少？过去六个月，每个月加了多少针？ 你也可以使用聚合去回答更多微妙的问题，比如： 你最受欢迎的针制造商是谁？是否有特别或者异常的针束？ 因为聚合借用了用于搜索的相同数据结构，所以他们也非常快。这使得你能实时分析和可视化数据。你的报告和仪表盘随着你的数据变化而更新，以便你可以基于最新的信息采取行动。 此外，聚合随着搜索请求一起运行。你可以搜索文档、过滤结果以及在单个请求中同时对同样的数据实时地执行分析。由于聚合是在特定搜索的上下文中计算的，你不仅能展示70号针的数量，你还能展示匹配你的用户搜索标准——比如不粘的绣花针——的 70 号针数量。 ","version":"Next","tagName":"h2"},{"title":"但是等等，还有更多​","type":1,"pageTitle":"信息输出：搜索和分析","url":"/docs/elasticsearch-cn/intro/inforout#但是等等还有更多","content":"想自动分析时序数据吗？你可以使用机器学习特性去创建在你数据中的正常行为的准确基线，并识别异常模式。通过机器学习，你能发现： 与值、计数或者频率有关的时间偏差异常统计稀有性群体成员的异常行为 最好的部分呢？你可以这样做，而不必指定算法、模型或其他与科学相关的配置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"数据输入：文档和索引","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/intro/datain","content":"数据输入：文档和索引 Elasticsearch 是一种分布式文档存储。Elasticsearch 不用列数据行存储信息，而是存储已序列化为 JSON 文档的复杂数据结构。当集群中有多个 Elasticsearch 节点时，存储的文档将分布在集群中，且可以从任何节点直接访问。 当一个文档被存储时，它会被索引并且在接近实时的1秒钟内被完全可搜索。Elasticsearch 使用一种称之为倒排索引的数据结构，支持非常快的全文搜索。倒排索引列出任何文档中出现的唯一单词，并标识每个单词出现的所有文档。 索引可被认作一种文档的优化集合，且每个文档都是字段的集合，字段是包含你数据的键值对。默认情况下，Elasticsearch 索引每个字段中的所有数据，且每个被索引的字段有一个专用的优化数据结构。例如，文本字段被存储在倒排索引中，数字和地理字段存储在 BKD 树 中。使用每个字段的数据结构来聚集和返回搜索结果是让 Elasticsearch 如此快的原因。 Elasticsearch 也具有无模式能力，这意味着文档无需明确地指定如何处理可能出现中文档中的每个不同的字段，就可以被索引。当启用动态映射后，Elasticsearch 自动检测和向索引中添加新的字段。这个默认行为使索引和浏览你的数据更容易——只需开始索引文档，Elasticsearch 会自动检测和映射布尔值、浮点值和整数值、日期以及字符串到合适的 Elasticsearch 数据类型。 最终，然而你比 Elasticsearch 更了解你的数据以及你想如何使用它们。你能定义控制动态映射规则，而且明确的定义映射以完全控制字段如何存储和索引。 定义你自己的映射使用你能够： 区分全文字符串字段和精确值字符串字段执行特定语言的文本分析为部分匹配优化字段使用自定义的日期格式使用无法自动检测的数据类型，如 geo_point和 geo_shape 为不同的目的以不同的方式索引相同的字段，通常是有用的。例如，你可能想索引一个字符串字段，既作为全文搜索的文本字段，也作为用于排序和聚合你的数据的关键字段。或者，你可以选择使用多个语言分析器，用来处理包含用户输入的字符串字段的内容。 用于索引期间的全文字段的分析链，也被用于搜索时。当你查询一个全文字段时，在索引中查询词语（term）之前，这个查询文本将经历相同的分析。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"可伸缩性和弹性：集群、节点和分片","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/intro/scalability","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"看具体情况……​","type":1,"pageTitle":"可伸缩性和弹性：集群、节点和分片","url":"/docs/elasticsearch-cn/intro/scalability#看具体情况","content":"对于分片大小和索引主分片数量的配置，有许多性能的考虑和权衡。分片越多，仅维护这些索引的开销就越大。分片越大，在 Elasticsearch 需要重平衡集群时，移动分片的耗时越久。 查询大量的小分片，可以让每个分片的处理更快，但更多的查询也意味着开销，所以查询更少的大分片也可能更快。简而言之……这得看情况。 作为起点： 要保持平均分片大小在几 GB 到几十 GB。对于使用基于时间的数据用例，通常分片处于 20 GB 到 40 GB 的范围。避免大量分片的问题。一个节点能容纳的分片数量与可用堆空间成比例。一般来讲，每 GB 堆空间的分片数量应少于20。 确定你的用例的最优配置的最好方法，是用你自己的数据和查询进行测试。 ","version":"Next","tagName":"h2"},{"title":"容灾​","type":1,"pageTitle":"可伸缩性和弹性：集群、节点和分片","url":"/docs/elasticsearch-cn/intro/scalability#容灾","content":"出于性能的原因，集群中的节点需要在同一网络中。在不同数据中心平衡集群中的分片会花很长时间。但高可用的架构要求你要避免把所有鸡蛋放到一个篮子里。在一个位置发生重大停机的情况下，另一个位置的服务器需要能够无缝的接管。答案是什么呢？跨集群复制（CCR）。 CCR 提供了一种方式自动地从主集群同步索引到作为热备的备份远程集群。如果主集群失效了，备份集群就会接管。你也可以使用 CCR 创建备份集群，以便在地理上靠近用户时，为读请求提供服务。 跨集群备份（CCR）是 主动-被动模式（active-passive）。主集群上的索引是活动的领导者索引，且处理所有写请求。复制到备份集群的索引是只读的追随者。 ","version":"Next","tagName":"h2"},{"title":"维护保养​","type":1,"pageTitle":"可伸缩性和弹性：集群、节点和分片","url":"/docs/elasticsearch-cn/intro/scalability#维护保养","content":"与任何企业系统一样，你需要工具来保护、管理和监控你的 Elasticsearch 集群。集成到 Elasticsearch 中的安全、监控和管理特性使你能使用 Kibana 作为管理集群的控制中心。数据汇总和索引生命周期管理等特性可帮助你随着时间的推移智能地管理数据。 原文链接 ","version":"Next","tagName":"h2"},{"title":"API 约定","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/api_convention/","content":"API 约定 Elasticsearch REST API 通过 HTTP 使用 JSON 暴露。 除非其他约定，本章列出的约定都可以用于 REST API。 多目标语法索引名中的日期数学支持Cron 表达式常用选项基于 URL 的访问控制","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"REST API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/","content":"REST API Elasticsearch 暴露的 REST API，提供给 UI 组件使用，也可以直接被调用来配置及访问 Elasticsearch 特性。 提示 我们致力于在本节中包含更多的 Elasticsearch APIs。一些内容可能可能还没被包含。 API 约定自动缩放 APIcat API集群 API跨集群复制 API数据流 API文档 APIEnrich API图形浏览 API索引 API索引生命周期管理 API摄入 API信息 API授权 API机器学习异常检测 API机器学习数据帧分析 API迁移 API重新加载搜索分析器 API仓库计量 API汇总 API搜索 API可搜索快照 API安全 API快照和还原 API快照生命周期管理 API转换 API使用 API观察者 API","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"Cron 表达式","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"Cron 表达式元素​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#cron-表达式元素","content":"除了 year（年），所有元素都是必需的。有关允许的特殊字符的信息，参阅 Cron 特殊字符。 &lt;seconds&gt;（必需的） 有效值： 0-59 以及特殊字符 , - * /&lt;minutes&gt;（必需的） 有效值： 0-59 以及特殊字符 , - * /&lt;hours&gt;（必需的） 有效值： 0-23 以及特殊字符 , - * /&lt;day_of_month&gt;（必需的） 有效值： 1-31 以及特殊字符 , - * / ? L W&lt;month&gt;（必需的） 有效值： 1-12， JAN-DEC， jan-dec， 以及特殊字符 , - * /&lt;day_of_week&gt;（必需的） 有效值： 1-7， SUN-SAT， sun-sat， 以及特殊字符 , - * / ? L #&lt;year&gt;（可选的） 有效值： 1970-2099 以及特殊字符 , - * / ","version":"Next","tagName":"h2"},{"title":"Cron 特殊字符​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#cron-特殊字符","content":"* 为字段选择所有可能的值。例如，在 hours（小时）字段中 * 表示“每个小时”。 ? 没有特定值。当你不在意值是什么时使用。例如，如果你希望计划在一个月里的特定天触发，但不关心是一周中的哪一天，你可以在 day_of_week 字段中指定 ?。 - 范围值（包含）。用于分隔最小值和最大值。例如，如果你希望计划在上午 9:00 到下午 5:00 之间每个小时触发，你可以在 hours 字段指定 9-17。 , 多个值。用于字段中分隔多个值。例如，如果你希望计划在每周二和每周四触发，你可以在 day_of_week 字段指定 TUE,THU。 / 增量。用于当指定时间增量时分隔值。第一个值表示起点，第二个值表示间隔值。例如，如果你希望计划在一个小时里每 20 分钟触发一次，你可以在 minutes 字段指定 0/20。类似的，在 day_of_month 字段指定 1/5，将从每月的第一天开始每 5 天执行一次。 L 最后。在 day_of_month 字段中使用，意味着这个月的最后一天——1 月时是 31 日，不闰年时 2 月时是 28 日，4 月时是 30 日，等等。在 day_of_week 字段中单独使用以替代 7 或 SAT，或者在一周中的某一特定日期后，选择该类型在月中最后一天。例如，6L 代表一个月的最后一个周五。你可以在 day_of_month 字段指定 LW，用于指定该月的最后一个工作日。当指定值的列表或范围时，避免使用 L 选项，因为结果可能不是你期待的结果。 W 工作日。用于指定靠近指定日期的工作日（星期一到星期五）。例如，如果你在 day_of_month 字段指定 15W，且 15 号是星期六，计划将在 14 号触发。如果 15 号是星期天，计划将在 16 号星期一触发。如果 15 号是星期二，计划会在 15 号星期二触发。然而，如果你为 day_of_month 指定 1W，且 1 号是星期六，计划会在 3 号星期一触发——它不会跳过月的范围。你可以在 day_of_month 字段指定 LW，用于指定一个月的最后一个工作日。当 day_of_month 是单独的一天，你才能使用 W 选项——当指定的是一个范围或列表天数时，它是无效的。 # 一个月里的第XXX天。在 day_of_week 字段用于指定一个月的第XXX天。例如，如果你指定 6#1，计划会在一个月的第一个星期五触发。注意你指定 3#5，且在某一个月里没有 5 个星期二，计划在那个月不会触发。 ","version":"Next","tagName":"h2"},{"title":"例子​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#例子","content":"","version":"Next","tagName":"h2"},{"title":"设置每日触发器​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#设置每日触发器","content":"0 5 9 * * ? 在每天上午 UTC 9:05 触发。 0 5 9 * * ? 2020 在 2020 年的每天上午 UTC 9:05 触发。 ","version":"Next","tagName":"h3"},{"title":"限制触发器为天数或时间范围​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#限制触发器为天数或时间范围","content":"0 5 9 ? * MON-FRI 在星期一到星期五的每天上午 UTC 9：05 触发。 0 0-5 9 * * ? 在每天上午 9:00 UTC 到 9:05 UTC 的每分钟触发。 ","version":"Next","tagName":"h3"},{"title":"设置周期触发器​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#设置周期触发器","content":"0 0/15 9 * * ? 在每天上午 9:00 UTC 到 9:45 UTC 每 15 分钟触发。 0 5 9 1/3 * ? 从一个月的第一天开始，每 3 天在上午 9:05 UTC 触发。 ","version":"Next","tagName":"h3"},{"title":"设置特定日期触发的计划​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#设置特定日期触发的计划","content":"0 1 4 1 4 ? 在 4 月 1 日上午 4:01 UTC 触发。 0 0,30 9 ? 4 WED 在 4 月的每个星期三的上午 9:00 UTC 和 9:30 UTC 触发。 0 5 9 15 * ? 在每个月 15 号的上午 9:05 UTC 触发。 0 5 9 15W * ? 在每个月的 15 号最近的工作日的上午 9:05 UTC 触发。 0 5 9 ? * 6#1 在每个月的第一个星期一的上午 9:05 UTC 触发。 ","version":"Next","tagName":"h3"},{"title":"使用 last（最后）设置触发器​","type":1,"pageTitle":"Cron 表达式","url":"/docs/elasticsearch-cn/rest_apis/api_convention/cron_expressions#使用-last最后设置触发器","content":"0 5 9 L * ? 在每个月的最后一天的上午 9:05 UTC 触发。 0 5 9 ? * 2L 在每个月的最后一个星期一的上午 9：05 UTC 触发。 0 5 9 LW * ? 在每个月的最后一个工作日的上午 9:05 UTC 触发。 原文链接 ","version":"Next","tagName":"h3"},{"title":"多目标语法","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/api_convention/multi_target_syntax","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"隐藏数据流和索引​","type":1,"pageTitle":"多目标语法","url":"/docs/elasticsearch-cn/rest_apis/api_convention/multi_target_syntax#隐藏数据流和索引","content":"对大多数 API，默认通配符表达式不匹配隐藏的数据流和索引。为了使用通配符表达式匹配隐藏数据流和索引，你必须指定 expand_wildcards 查询参数。 你可以通过在数据流匹配索引模板中设置 data_stream.hidden 为 true 来创建隐藏数据流。你可以使用 index.hidden 索引设置来隐藏索引。 数据流的备份索引将自动隐藏。一些特性，如机器学习，信息将存储在隐藏索引中。 匹配所有索引的全局索引模板不会应用于隐藏索引。 ","version":"Next","tagName":"h2"},{"title":"系统索引​","type":1,"pageTitle":"多目标语法","url":"/docs/elasticsearch-cn/rest_apis/api_convention/multi_target_syntax#系统索引","content":"Elasticsearch 模块和插件可以在内部系统索引中存储配置和状态信息。你不应该直接访问或修改系统索引，因为它们包含系统运行所必需的数据。 警告 不推荐直接访问系统索引，并且在下一个主要版本中将不再允许直接访问系统索引。 原文链接 ","version":"Next","tagName":"h2"},{"title":"基于 URL 的访问控制","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/api_convention/url-based_access_control","content":"基于 URL 的访问控制 许多用户使用基于 URL 的访问控制的代理来保护对 Elasticsearch 数据流和索引的访问。对多搜索、多获取和批量请求，用户可以选择在 URL 和带请求体的每个独立请求中指定数据流或索引。这会使基于 URL 的访问控制具有挑战性。 为了阻止用户重写在 URL 中指定的数据流或索引，在 elasticsearch.yml 中设置 rest.action.multi.allow_explicit_index 为 false。 这可以引起 Elasticsearch 拒绝在请求体中显示指定数据流或索引的请求。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引名中的日期数学支持","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/api_convention/date_math_support_in_index_names","content":"索引名中的日期数学支持 日期数学索引名字解析允许你搜索一系列时序索引，而不是搜索所有时序索引并过滤结果或维护别名。限制搜索的索引数可以减少集群上的负载并改进执行性能。例如，如果你在每日日志中搜索错误，你可以使用日期数学名字模板来限制搜索为过去两天。 几乎所有具有 index（索引）参数的 API，都支持 index（索引）参数值中的日期数学。 日期数学索引名字采用以下形式： &lt;static_name{date_math_expr{date_format|time_zone}}&gt; 其中： static_name\t名字的静态文字部分 date_math_expr\t动态计算日期的动态日期数学表达式 date_format\t显示计算日期的可选格式。默认为 yyyy.MM.dd。格式应与 java-time 兼容。https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html time_zone\t可选的时区。默认为 utc。 提示 date_format（日期格式）中使用的大小写字母。例如，mm 表示分钟，MM表示月份。类似的，hh 表示 1-12 范围内的小时，与 AM/PM 组合使用，而 HH 表示 0-23 24小时范围内的小时。 日期数学表达式与区域无关。因此，不以使用格列高利历之外的日历。 必须将日期数学索引名字表达式包在尖括号内，并且所有特殊字符都应进行 URI 编码。例如： # PUT /&lt;my-index-{now/d}&gt; PUT /%3Cmy-index-%7Bnow%2Fd%7D%3E 提示 日期数学字符的百分比编码 日期格式特定字符必须为 URI 编码，如下： &lt;\t%3C &gt;\t%3E /\t%2F {\t%7B }\t%7D |\t%7C +\t%2B :\t%3A ,\t%2C 以下示例显示日期数学索引名字的不同格式，且给定当前时间为 UTC 2024年3月22日中午，它们解析为最终索引名字。 表达式\t解析为&lt;logstash-{now/d}&gt;\tlogstash-2024.03.22 &lt;logstash-{now/M}&gt;\tlogstash-2024.03.01 &lt;logstash-{now/M{yyyy.MM}}&gt;\tlogstash-2024.03 &lt;logstash-{now/M-1M{yyyy.MM}}&gt;\tlogstash-2024.02 &lt;logstash-{now/d{yyyy.MM.dd | +12:00}}&gt;\tlogstash-2024.03.23 为了在索引名字模板的静态部分中使用字符 { 和 }，请使用反斜杠 \\ 转义，例如： &lt;elastic\\{ON\\}-{now/M}&gt; 解析为 elastic{ON}-2024.03.01 以下例子展示了一个搜索请求，该请求搜索过去三天的 Logstash 索引，假设索引使用默认的 Logstash 索引名字格式 logstash-yyyy.MM.dd。 # GET /&lt;logstash-{now/d-2d}&gt;,&lt;logstash-{now/d-1d}&gt;,&lt;logstash-{now/d}&gt;/_search GET /%3Clogstash-%7Bnow%2Fd-2d%7D%3E%2C%3Clogstash-%7Bnow%2Fd-1d%7D%3E%2C%3Clogstash-%7Bnow%2Fd%7D%3E/_search { &quot;query&quot; : { &quot;match&quot;: { &quot;test&quot;: &quot;data&quot; } } } 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"自动伸缩 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"顶级​","type":1,"pageTitle":"自动伸缩 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/#顶级","content":"获取自动伸缩容量创建或更新自动伸缩策略删除自动伸缩策略获取自动伸缩策略 原文链接 ","version":"Next","tagName":"h2"},{"title":"创建或更新自动伸缩策略 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/create_or_update_autoscaling_policy","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建或更新自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/create_or_update_autoscaling_policy#请求","content":"PUT /_autoscaling/policy/&lt;name&gt; { &quot;roles&quot;: [], &quot;deciders&quot;: { &quot;fixed&quot;: { } } }  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"创建或更新自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/create_or_update_autoscaling_policy#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_autoscaling 集群权限来使用此 API。 如果启用了操作员权限特性，则只有操作员用户可以使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"创建或更新自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/create_or_update_autoscaling_policy#描述","content":"此 API 使用提供的名称修改自动伸缩策略。关于可用的决策器，参阅自动伸缩决策器。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"创建或更新自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/create_or_update_autoscaling_policy#示例","content":"此示例使用固定的自动缩放决策器，将名为 my_autoscaling_policy 的自动缩放策略应用于（仅）具有 “data_hot” 角色的节点集。 PUT /_autoscaling/policy/my_autoscaling_policy { &quot;roles&quot; : [ &quot;data_hot&quot; ], &quot;deciders&quot;: { &quot;fixed&quot;: { } } }  此 API 返回以下结果： { &quot;acknowledged&quot;: true }  原文链接 ","version":"Next","tagName":"h2"},{"title":"删除自动伸缩策略 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/delete_autoscaling_policy","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/delete_autoscaling_policy#请求","content":"DELETE /_autoscaling/policy/&lt;name&gt;  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/delete_autoscaling_policy#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_autoscaling 集群权限来使用此 API。 如果启用了操作员权限特性，则只有操作员用户可以使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"删除自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/delete_autoscaling_policy#描述","content":"此 API 使用提供的名称删除一个自动伸缩策略。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"删除自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/delete_autoscaling_policy#示例","content":"此示例删除一个名为 my_autoscaling_policy 的 自动伸缩策略。 DELETE /_autoscaling/policy/my_autoscaling_policy  此 API 返回以下结果： { &quot;acknowledged&quot;: true }  此示例删除所有自动伸缩策略。 DELETE /_autoscaling/policy/*  此 API 返回以下结果： { &quot;acknowledged&quot;: true }  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取自动伸缩策略 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_policy","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_policy#请求","content":"GET /_autoscaling/policy/&lt;name&gt;  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_policy#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_autoscaling 集群权限。更多信息，参阅安全权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"获取自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_policy#描述","content":"此 API 获取指定名字的自动伸缩策略。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取自动伸缩策略 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_policy#示例","content":"此示例获取名为 my_autoscaling_policy 自动伸缩策略。 GET /_autoscaling/policy/my_autoscaling_policy  此 API 返回以下结果： { &quot;roles&quot;: &lt;roles&gt;, &quot;deciders&quot;: &lt;deciders&gt; }  原文链接 ","version":"Next","tagName":"h2"},{"title":"行为分析 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/","content":"行为分析 API 警告 此功能为测试版，可能会有更改。其设计和代码不如 GA 正式功能成熟，因此不提供任何保证。测试版功能不受 GA 正式功能的支持服务级别协议约束。 使用以下 API 管理与行为分析相关的任务和资源： 放入分析集合删除分析集合列出分析集合 使用以下 API 将事件纳入分析集合： 发布分析收集事件 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"删除分析集合","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/delete_analytics_collection","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/delete_analytics_collection#请求","content":"DELETE _application/analytics/&lt;name&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/delete_analytics_collection#前置条件","content":"需要 manage_behavioral_analytics 集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/delete_analytics_collection#路径参数","content":"&lt;name&gt;（必需，字符串） ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"删除分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/delete_analytics_collection#响应码","content":"400name 未提供 404 （缺失资源） 未找到与 name 匹配的分析数据集。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"删除分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/delete_analytics_collection#示例","content":"下面的示例将删除名为 my_analytics_collection 的分析集合。 DELETE _application/analytics/my_analytics_collection/  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取自动伸缩容量 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_capacity","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取自动伸缩容量 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_capacity#请求","content":"GET /_autoscaling/capacity/  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取自动伸缩容量 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_capacity#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_autoscaling 集群权限来使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"获取自动伸缩容量 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_capacity#描述","content":"此 API 根据配置的自动伸缩策略获取当前自动缩放容量。此 API 将返回信息，以根据当前工作负载适当调整集群大小。 required_capacity 计算为针对策略启用的所有单个决策者的 required_capacity 结果的最大值。 操作员应验证 current_nodes 是否与操作员对集群的了解相匹配，以避免根据陈旧或不完整的信息做出自动伸缩决策。 响应包含特定于决策者的信息，你可以使用这些信息诊断自动缩放如何以及为什么确定需要某个容量。此信息仅用于诊断。不要使用此信息进行自动伸缩决策。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"获取自动伸缩容量 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_capacity#响应体","content":"policies （对象）包含策略名称到容量结果的映射 policies 属性 &lt;policy_name&gt;（对象）包含策略的容量信息。 &lt;policy_name&gt; 属性 required_capacity（对象）包含策略所需的容量。 required_capacity 属性 node（对象）包含每个节点所需的最小节点大小，确保单个碎片或机器学习（ML）作业可以装入单个节点。 node 属性 storage（整数）每个节点所需的存储字节数。memory（整数）每个节点所需的内存字节数。 total（对象）包含策略所需的总大小。 total 属性 storage（整数）策略所需的总存储字节数。memory（整数）策略所需的总内存字节数。 current_capacity（对象）包含受策略控制的节点的当前容量，即 Elasticsearch 计算所基于的节点。 current_capacity 属性 node（对象）包含由策略管理的节点的最大大小。 node 属性 storage（整数）节点的最大存储字节数。memory（整数）节点的最大内存字节数。 total（对象）包含受策略控制的节点的当前总存储和内存大小。 total 属性 storage（整数）可用于策略的当前存储字节数。memory（整数）可用于策略的当前内存字节数。 current_nodes（对象数组）用于容量计算的节点列表。 current_nodes 中元素的属性 name（字符串）节点名字。 deciders（对象）容量是由单个决策者得出的结果，允许深入了解外部级别 required_capacity 是如何计算的。 deciders 属性 &lt;decider_name&gt;（对象）为策略启用的特定决策器的容量结果。 &lt;decider_name&gt; 属性 required_capacity（对象）由决策器确定的所需容量。 required_capacity 属性 node（对象）包含每个节点所需的最小节点大小，确保单个分片或机器学习作业可以装入单个节点。 node 属性 storage（整数）每个节点所需的存储字节数。memory（整数）每个节点所需的内存字节数。 total（对象）包含策略所需的总大小。 total 属性 storage（整数）策略所需的总存储字节数。memory（整数）策略所需的总内存字节数。 reason_summary（字符串）描述决策器结果的依据。reason_details（对象）每个决策器的结构，包含决策器结果基础的详细信息。内容不应用于应用目的，也不受向后兼容性保证的约束。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取自动伸缩容量 API","url":"/docs/elasticsearch-cn/rest_apis/autoscaling_apis/get_autoscaling_capacity#示例","content":"此示例获取当前自动伸缩容量。 GET /_autoscaling/capacity  此 API 返回以下结果： { policies: {} }  原文链接 ","version":"Next","tagName":"h2"},{"title":"列出分析集合","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/list_analytics_collections","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"列出分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/list_analytics_collections#请求","content":"GET _application/analytics/&lt;criteria&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"列出分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/list_analytics_collections#前置条件","content":"需要获得 manage_behavioral_analytics 集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"列出分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/list_analytics_collections#路径参数","content":"&lt;criteria&gt;(可选，字符串）标准用于查找匹配的分析集合。可以是集合名称，也可以是匹配多个集合的模式。如果未指定，将返回所有分析集合。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"列出分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/list_analytics_collections#响应码","content":"404标准与任何分析集合不匹配。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"列出分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/list_analytics_collections#示例","content":"下面的示例列出了所有已配置的分析集合： GET _application/analytics/  一个示例响应： { &quot;my_analytics_collection&quot;: { &quot;event_data_stream&quot;: { &quot;name&quot;: &quot;behavioral_analytics-events-my_analytics_collection&quot; } }, &quot;my_analytics_collection2&quot;: { &quot;event_data_stream&quot;: { &quot;name&quot;: &quot;behavioral_analytics-events-my_analytics_collection2&quot; } } }  下面的示例会返回与 my_analytics_collection 匹配的分析集合： GET _application/analytics/my_analytics_collection  一个示例响应： { &quot;my_analytics_collection&quot;: { &quot;event_data_stream&quot;: { &quot;name&quot;: &quot;behavioral_analytics-events-my_analytics_collection&quot; } } }  下面的示例会返回所有以 my 为前缀的分析集合： GET _application/analytics/my*  一个示例响应： { &quot;my_analytics_collection&quot;: { &quot;event_data_stream&quot;: { &quot;name&quot;: &quot;behavioral_analytics-events-my_analytics_collection&quot; } }, &quot;my_analytics_collection2&quot;: { &quot;event_data_stream&quot;: { &quot;name&quot;: &quot;behavioral_analytics-events-my_analytics_collection2&quot; } } }  原文链接 ","version":"Next","tagName":"h2"},{"title":"创建分析集合","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/put-analytics-collection","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/put-analytics-collection#请求","content":"PUT _application/analytics/&lt;name&gt; ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"创建分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/put-analytics-collection#路径参数","content":"&lt;name&gt;(必填，字符串） ","version":"Next","tagName":"h2"},{"title":"前提条件​","type":1,"pageTitle":"创建分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/put-analytics-collection#前提条件","content":"需要 manage_behavioral_analytics 集群权限。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"创建分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/put-analytics-collection#响应码","content":"400分析集合 &lt;name&gt; 存在。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"创建分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/put-analytics-collection#示例","content":"下面的示例创建了一个新的分析集合，名为：my_analytics_collection： PUT _application/analytics/my_analytics_collection  原文链接 ","version":"Next","tagName":"h2"},{"title":"常用选项","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"美观结果​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#美观结果","content":"为任何请求添加 ?pretty=true 时，JSON 会以美观的样式返回（仅在调试模式使用！）另一个选项是设置 ?format=yaml，这可以导致结果以（有时）更可读的 yaml 格式返回。 ","version":"Next","tagName":"h2"},{"title":"可读输出​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#可读输出","content":"统计数据以适合人的格式（如，&quot;exists_time&quot;: &quot;1h&quot; 或 &quot;size&quot;: &quot;1kb&quot;）和计算机的格式（如，&quot;exists_time_in_millis&quot;: 3600000 或 &quot;size_in_bytes&quot;: 1024）返回。人可读的格式可以通过在查询字符串中通过添加 ?human=false 关闭。当统计结果被监控工具使用，而不是供人使用时，这是有意义的。human 标记默认为 false。 ","version":"Next","tagName":"h2"},{"title":"日期数学​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#日期数学","content":"多数接受格式化日期值的参数——比如在范围查询中的 gt 和 lt，或者日期范围聚合中的 from 和 to——都能理解日期数学。 表达式以锚点日期开始，可以是 now（现在），或者以 || 结尾的日期字符串。锚点日期后面可以跟一个或多个数学表达式： +1h：加一个小时-1d：减一天/d：舍入到最近的一天 支持的时间单位不同于支持的周期时间单位。支持的单位有： \ty\t年 M\t月 w\t周 d\t天 h\t小时 H\t小时 m\t分钟 s\t秒 假定 now（现在）是 2001-01-01 12:00:00，一些例子如下： \tnow+1h\t在 now 上以毫秒加一小时。解析为：2001-01-01 13:00:00 now-1h\t在 now 上以毫秒减一小时。解析为：2001-01-01 11:00:00 now-1h/d\t在 now 上以毫秒减一小时，然后舍入为 UTC 00:00。解析为：2001-01-01 00:00:00 2001.02.01\\ | \\ | +1M/d\t在 2001-02-01上加一个月。解析为：2001-03-01 00:00:00 ","version":"Next","tagName":"h2"},{"title":"响应过滤​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#响应过滤","content":"所有的 REST API 都接受 filter_path 参数，它可以用于减少 Elasticsearch 返回的响应。此参数采用逗号分隔的过滤器列表，过滤器用点符号表示： GET /_search?q=kimchy&amp;filter_path=took,hits.hits._id,hits.hits._score  响应： { &quot;took&quot; : 3, &quot;hits&quot; : { &quot;hits&quot; : [ { &quot;_id&quot; : &quot;0&quot;, &quot;_score&quot; : 1.6375021 } ] } }  它也支持 * 通配符用于匹配任何字段或字段名字的一部分： GET /_cluster/state?filter_path=metadata.indices.*.stat*  响应： { &quot;metadata&quot; : { &quot;indices&quot; : { &quot;my-index-000001&quot;: {&quot;state&quot;: &quot;open&quot;} } } }  而且，** 通配符可以用于包含字段而不用知道字段的具体路径。例如，我们可以通过以下请求返回每个段的 Lucene 版本： GET /_cluster/state?filter_path=routing_table.indices.**.state  响应： { &quot;routing_table&quot;: { &quot;indices&quot;: { &quot;my-index-000001&quot;: { &quot;shards&quot;: { &quot;0&quot;: [{&quot;state&quot;: &quot;STARTED&quot;}, {&quot;state&quot;: &quot;UNASSIGNED&quot;}] } } } } }  它也可以通过在过滤器前缀添加字符 - 来排除一个或多个字段： GET /_count?filter_path=-_shards  响应： { &quot;count&quot; : 5 }  为了获得更多的控制，可以在同一个表达式中组合包含过滤器和排除过滤器。在这个例子中，排除过滤器会先生效，然后结果会再次使用包含过滤器筛选： GET /_cluster/state?filter_path=metadata.indices.*.state,-metadata.indices.logstash-*  响应： { &quot;metadata&quot; : { &quot;indices&quot; : { &quot;my-index-000001&quot; : {&quot;state&quot; : &quot;open&quot;}, &quot;my-index-000002&quot; : {&quot;state&quot; : &quot;open&quot;}, &quot;my-index-000003&quot; : {&quot;state&quot; : &quot;open&quot;} } } }  注意 Elasticsearch 有时直接返回字段的原始值，比如 _source 字段。如果你想过滤 _source 字段，你应该考虑使用 filter_path 参数联合已有的 _source 参数（参阅获得 API 获取更多信息）： POST /library/book?refresh {&quot;title&quot;: &quot;Book #1&quot;, &quot;rating&quot;: 200.1} POST /library/book?refresh {&quot;title&quot;: &quot;Book #2&quot;, &quot;rating&quot;: 1.7} POST /library/book?refresh {&quot;title&quot;: &quot;Book #3&quot;, &quot;rating&quot;: 0.1} GET /_search?filter_path=hits.hits._source&amp;_source=title&amp;sort=rating:desc  { &quot;hits&quot; : { &quot;hits&quot; : [ { &quot;_source&quot;:{&quot;title&quot;:&quot;Book #1&quot;} }, { &quot;_source&quot;:{&quot;title&quot;:&quot;Book #2&quot;} }, { &quot;_source&quot;:{&quot;title&quot;:&quot;Book #3&quot;} } ] } }  ","version":"Next","tagName":"h2"},{"title":"扁平设置​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#扁平设置","content":"flat_settings 标志影响设置列表的展示。当 flat_settings 标志为 true 时，设置以扁平格式展示： GET my-index-000001/_settings?flat_settings=true  响应： { &quot;my-index-000001&quot; : { &quot;settings&quot;: { &quot;index.number_of_replicas&quot;: &quot;1&quot;, &quot;index.number_of_shards&quot;: &quot;1&quot;, &quot;index.creation_date&quot;: &quot;1474389951325&quot;, &quot;index.uuid&quot;: &quot;n6gzFZTgS664GUfx0Xrpjw&quot;, &quot;index.version.created&quot;: ..., &quot;index.routing.allocation.include._tier_preference&quot; : &quot;data_content&quot;, &quot;index.provided_name&quot; : &quot;my-index-000001&quot; } } }  当 flat_settings 标志为 false，设置以更符合人类可读的结构格式返回： GET my-index-000001/_settings?flat_settings=false  响应： { &quot;my-index-000001&quot; : { &quot;settings&quot; : { &quot;index&quot; : { &quot;number_of_replicas&quot;: &quot;1&quot;, &quot;number_of_shards&quot;: &quot;1&quot;, &quot;creation_date&quot;: &quot;1474389951325&quot;, &quot;uuid&quot;: &quot;n6gzFZTgS664GUfx0Xrpjw&quot;, &quot;version&quot;: { &quot;created&quot;: ... }, &quot;routing&quot;: { &quot;allocation&quot;: { &quot;include&quot;: { &quot;_tier_preference&quot;: &quot;data_content&quot; } } }, &quot;provided_name&quot; : &quot;my-index-000001&quot; } } } }  默认情况，flat_settings 设置为 false。 ","version":"Next","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#参数","content":"REST 参数（当使用 HTTP，映射到 HTTP URL 参数）遵循下划线大小写的约定。 ","version":"Next","tagName":"h2"},{"title":"布尔值​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#布尔值","content":"所有 REST API 参数（包括请求参数和 JSON 体）支持提供布尔值 “false” 作为值 false，以及布尔值 “true” 作为值 true。其他所有值会报错。 ","version":"Next","tagName":"h2"},{"title":"数值​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#数值","content":"所有 REST API 在原生 JSON 数字类型之上，都支持以字符串形式提交数字参数。 ","version":"Next","tagName":"h2"},{"title":"时间单位​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#时间单位","content":"当需要指定周期时间时，例如 timeout （超时）参数，周期必须指定单位，如 2d 代表 2 天。支持的单位有： \td\t天 h\t小时 m\t分钟 s\t秒 ms\t毫秒 micros\t微秒 nanos\t纳秒 ","version":"Next","tagName":"h2"},{"title":"字节大小单位​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#字节大小单位","content":"当需要指定数据字符大小时，例如当设置一个缓存大小参数，值必须指定单位，如 10kb 代表 10 千字节。注意这些单位是 1024 的幂，因此 1kb 表示 1024 字节。支持的单位有： \tb\t字节 kb\t千字节 mb\t兆字节 gb\t千兆字节 tb\t兆兆字节 pb\t拍字节 ","version":"Next","tagName":"h2"},{"title":"无单位数量​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#无单位数量","content":"无单位数量表示没有像“字节”或“赫兹”或“米”或“长吨”这种单位。 如果一个数量很大，我们输出它，类似 10m 代表 10,000,000，7k 代表 7,000。然而，87 的话，我们还是会输出 87。这些是支持的倍数： \tk\t千（103） m\t兆（百万 106） g\t千兆（十亿 109） t\t兆兆（万亿 1012） p\t拍（亿亿 1015） ","version":"Next","tagName":"h2"},{"title":"距离单位​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#距离单位","content":"当需要指定距离时，比如在 Geo-距离中的 distance 参数，如果没有指定，默认单位为米。距离可以被指定为其他单位，比如 1km 或 2mi（2 英里）。 单位的完整列表如下： \tMile（英里）\tmi 或 miles Yard（码）\tyd 或 yards Feet（英尺）\tft 或 feet Inch（英寸）\tin 或 inch Kilometer（千米）\tkm 或 kilometers Meter（米）\tm 或 meters Centimeter（厘米）\tcm 或 centimeters Millimeter（毫米）\tmm 或 millimeters Nautical mile（海里）\tNM， nmi 或 nauticalmiles ","version":"Next","tagName":"h2"},{"title":"模糊性​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#模糊性","content":"一些查询和 API 支持参数通过 fuzziness 参数以允许不精确的模糊匹配。 当查询 text 或 keyword 字段时，fuzziness 被解释为Levenshtein编辑距离——需要对一个字符串进行更改以使其与另一个字符串相同的字符数。 fuzziness 参数可以被指定为： \t0，1，2\t允许的最大Levenshtein编辑距离（或编辑数） AUTO\t根据词语的长度生成编辑距离。可以选择提供低和高距离参数 AUTO:[low],[high]。如果未指定，默认值为 3 和 6，相当于 AUTO:3,6，这表示长度： 0..2 必须完全匹配 3..5 允许一次编辑 &gt;5 允许两次编辑 AUTO 应该是 fuzziness 首选值。 ","version":"Next","tagName":"h2"},{"title":"允许堆栈跟踪​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#允许堆栈跟踪","content":"默认情况下，当请求返回错误时 Elasticsearch 不会包含错误的堆栈跟踪。你可以通过设置 url 参数 error_trace 为 true 来允许这个行为。例如，默认情况当你向 _search API 发送一个无效的 size 参数： POST /my-index-000001/_search?size=surprise_me  响应如下： { &quot;error&quot; : { &quot;root_cause&quot; : [ { &quot;type&quot; : &quot;illegal_argument_exception&quot;, &quot;reason&quot; : &quot;Failed to parse int parameter [size] with value [surprise_me]&quot; } ], &quot;type&quot; : &quot;illegal_argument_exception&quot;, &quot;reason&quot; : &quot;Failed to parse int parameter [size] with value [surprise_me]&quot;, &quot;caused_by&quot; : { &quot;type&quot; : &quot;number_format_exception&quot;, &quot;reason&quot; : &quot;For input string: \\&quot;surprise_me\\&quot;&quot; } }, &quot;status&quot; : 400 }  但是如果你设置 error_trace=true： POST /my-index-000001/_search?size=surprise_me&amp;error_trace=true  响应如下： { &quot;error&quot;: { &quot;root_cause&quot;: [ { &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;Failed to parse int parameter [size] with value [surprise_me]&quot;, &quot;stack_trace&quot;: &quot;Failed to parse int parameter [size] with value [surprise_me]]; nested: IllegalArgumentException...&quot; } ], &quot;type&quot;: &quot;illegal_argument_exception&quot;, &quot;reason&quot;: &quot;Failed to parse int parameter [size] with value [surprise_me]&quot;, &quot;stack_trace&quot;: &quot;java.lang.IllegalArgumentException: Failed to parse int parameter [size] with value [surprise_me]\\n at org.elasticsearch.rest.RestRequest.paramAsInt(RestRequest.java:175)...&quot;, &quot;caused_by&quot;: { &quot;type&quot;: &quot;number_format_exception&quot;, &quot;reason&quot;: &quot;For input string: \\&quot;surprise_me\\&quot;&quot;, &quot;stack_trace&quot;: &quot;java.lang.NumberFormatException: For input string: \\&quot;surprise_me\\&quot;\\n at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)...&quot; } }, &quot;status&quot;: 400 }  ","version":"Next","tagName":"h2"},{"title":"查询字符串中的请求体​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#查询字符串中的请求体","content":"对不接受非 POST 请求的请求体的库，你可以 source 查询字符串参数替代传递请求体。当使用这个方法时，source_content_type 参数也要表明源格式的媒体类型值，如 application/json。 ","version":"Next","tagName":"h2"},{"title":"内容类型要求​","type":1,"pageTitle":"常用选项","url":"/docs/elasticsearch-cn/rest_apis/api_convention/common_options#内容类型要求","content":"请求体中发送的内容类型，必须通过 Content-Type 头指定。头的值必须映射为 API 支持的格式。大多数 API 支持 JSON、YAML、CBOR 和 SMILE。批量（bulk）和多搜索（multi-search） API 支持 NDJSON、JSON 和 SMILE；其他类型会导致错误响应。 另外，当使用 source 查询字符串参数时，内容类型必须通过 source_content_type 查询字符串参数指定。 原文链接 ","version":"Next","tagName":"h2"},{"title":"集群 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"节点规范​","type":1,"pageTitle":"集群 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/#节点规范","content":"某些集群级 API 可在节点子集上运行，这些节点子集可通过节点过滤器指定。例如，任务管理、节点统计 和 节点信息 API 都可以报告经过筛选的节点集而非全部节点的结果。 节点过滤器是以逗号分隔的单个过滤器列表形式编写的，每个过滤器都可从所选子集中添加或删除节点。每个过滤器可以是以下其中之一： _all，将所有节点添加到子集中。_local，将本地节点添加到子集中。_master，将当前选中的主节点加入子集。节点 ID 或名称，将该节点添加到子集中。IP 地址或主机名，将所有匹配的节点添加到子集中。模式，使用 * 通配符，将名称、地址或主机名与该模式匹配的所有节点添加到子集中。master:true，data:true，ingest:true，voting_only:true，ml:true 或 coordinating_only:true，分别将所有符合主节点资格的节点、所有数据节点、所有摄取节点、所有仅投票节点、所有机器学习节点和所有仅协调节点添加到子集中。master:false，data:false，ingest:false，voting_only:false，ml:false 或 coordinating_only:false，分别从子集中移除所有符合主节点资格的节点、所有数据节点、所有摄取节点、所有仅投票节点、所有机器学习节点和所有仅协调节点。模式对，使用 * 通配符，其形式为 attrname:attrvalue，用于将名称和值符合相应模式的自定义节点属性添加到子集中。自定义节点属性是通过在配置文件中设置形式为 node.attr.attrname:attrvalue 的属性来配置的。 提示 节点过滤器的运行顺序，这一点在使用从节点集中移除节点的过滤器时非常重要。例如，_all,master:false 表示除符合主节点条件的节点外的所有节点，但 master:false,_all 的意思与 _all 相同，因为 _all 过滤器在 master:false 过滤器之后运行。 提示 如果没有给出筛选条件，默认情况下会选择所有节点。但是，如果给定了任何筛选器，它们就会从一个空的所选子集开始运行。这意味着，master:false 等从所选子集中移除节点的筛选器只有在其他筛选器之后才有用。单独使用时，master:false 不会选择任何节点。 下面是节点过滤器与节点信息 API 配合使用的一些示例。 # If no filters are given, the default is to select all nodes GET /_nodes # Explicitly select all nodes GET /_nodes/_all # Select just the local node GET /_nodes/_local # Select the elected master node GET /_nodes/_master # Select nodes by name, which can include wildcards GET /_nodes/node_name_goes_here GET /_nodes/node_name_goes_* # Select nodes by address, which can include wildcards GET /_nodes/10.0.0.3,10.0.0.4 GET /_nodes/10.0.0.* # Select nodes by role GET /_nodes/_all,master:false GET /_nodes/data:true,ingest:true GET /_nodes/coordinating_only:true GET /_nodes/master:true,voting_only:false # Select nodes by custom attribute (e.g. with something like `node.attr.rack: 2` in the configuration file) GET /_nodes/rack:2 GET /_nodes/ra*:2 GET /_nodes/ra*:2*  原文链接 ","version":"Next","tagName":"h2"},{"title":"将事件发布到分析集合","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"将事件发布到分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event#请求","content":"POST _application/analytics/&lt;collection_name&gt;/event/&lt;event_type&gt; ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"将事件发布到分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event#路径参数","content":"&lt;collection_name&gt;(必填，字符串）您要在其中摄取事件的分析集合名称。 &lt;event_type&gt;(必填，字符串）分析事件类型。可以是 page_view、search、search_click 中的一种。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"将事件发布到分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event#请求体","content":"完整的请求体参数可在此找到：事件参考。 ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"将事件发布到分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event#前置条件","content":"需要获得 manage_behavioral_analytics 集群权限。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"将事件发布到分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event#响应码","content":"202事件已被接受并将被输入。 404分析集合 &lt;collection_name&gt; 不存在。 400事件类型未知或事件有效负载包含无效数据时出现。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"将事件发布到分析集合","url":"/docs/elasticsearch-cn/rest_apis/behavioral_analytics_apis/post_analytics_collection_event#示例","content":"下面的示例将 search_click 事件发送到名为 my_analytics_collection 的分析集合。 POST _application/analytics/my_analytics_collection/event/search_click { &quot;session&quot;: { &quot;id&quot;: &quot;1797ca95-91c9-4e2e-b1bd-9c38e6f386a9&quot; }, &quot;user&quot;: { &quot;id&quot;: &quot;5f26f01a-bbee-4202-9298-81261067abbd&quot; }, &quot;search&quot;:{ &quot;query&quot;: &quot;search term&quot;, &quot;results&quot;: { &quot;items&quot;: [ { &quot;document&quot;: { &quot;id&quot;: &quot;123&quot;, &quot;index&quot;: &quot;products&quot; } } ], &quot;total_results&quot;: 10 }, &quot;sort&quot;: { &quot;name&quot;: &quot;relevance&quot; }, &quot;search_application&quot;: &quot;website&quot; }, &quot;document&quot;:{ &quot;id&quot;: &quot;123&quot;, &quot;index&quot;: &quot;products&quot; } }  原文链接 ","version":"Next","tagName":"h2"},{"title":"集群获取设置 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_get_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"集群获取设置 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_get_settings#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 monitor 或 manage 的集群权限以使用此 API。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"集群获取设置 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_get_settings#请求","content":"GET /_cluster/settings  ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"集群获取设置 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_get_settings#描述","content":"默认情况下，该 API 调用只返回已明确定义的设置，但也可以通过调用 include_defaults 参数来包含默认设置。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"集群获取设置 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_get_settings#查询参数","content":"flat_settings（可选，布尔值） 如果为 true，则以平面格式返回设置。默认为 false。 include_defaults（可选，布尔） 如果为 true，则返回本地节点的默认集群设置。默认为 false。 master_timeout（可选，时间单位）等待主节点的时间。如果在超时前主节点不可用，则请求失败并返回错误。默认为 30s。也可以设置为 -1，表示请求永不超时。 原文链接 ","version":"Next","tagName":"h2"},{"title":"集群重路由 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"集群重路由 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute#请求","content":"POST /_cluster/reroute?metric=none  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"集群重路由 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage 的集群权限以使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"集群重路由 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute#描述","content":"重路由命令允许手动更改集群中各个分片的分配。例如，可以显式地将分片从一个节点移动到另一个节点，可以取消分配，并且可以将未分配的分片显式分配给特定节点。 需要注意的是，在处理任何重新路由命令后，Elasticsearch 将正常执行重新平衡（尊重 cluster.routing.rebalance.enable 等设置的值），以保持平衡状态。例如，如果请求的分配包括将分片从 node1 移动到 node2，则这可能会导致分片从 node2 移回 node1 以平衡情况。 可以使用 cluster.routing.allocation.enable 设置将集群设置为禁用分配。如果禁用了分配，则将执行的唯一分配是使用重路由命令给出的显式分配，以及由于重新平衡而产生的随之而来的分配。 可以通过使用 ?dry_run URI 查询参数或在请求正文中传递 &quot;dry_run&quot;:true 在“试运行”模式下运行 reroute 命令。这将计算将命令应用于当前集群状态的结果，并在应用命令（和重新平衡）后返回生成的集群状态，但实际上不会执行请求的更改。 如果包含 ?explain URI 查询参数，则响应中将包含命令可以执行或无法执行的原因的详细说明。 集群将尝试连续分配分片最多 index.allocation.max_retries 次数（默认为 5），然后放弃并让分片未分配。这种情况可能是由结构问题引起的，例如分析器引用并非所有节点上都存在的停用词文件。 问题得到纠正后，可以通过使用 ?retry_failed URI 查询参数调用重新路由 API 来手动重试分配，这将尝试对这些分片进行单轮重试。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"集群重路由 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute#查询参数","content":"dry_run （可选，布尔值）如果为 true，则请求仅模拟作并返回结果状态。 explain （可选，布尔值）如果为 true，则响应包含命令可以执行或不能执行的原因的说明。 metric （可选，字符串）将返回的信息限制为指定的指标。除 none 之外的所有选项均已弃用，应避免用于此参数。默认为除元数据之外的所有数据。以下选项可用： metric 选项 _all 展示所有指标。 blocks 展示响应的块部分。 master_node 展示响应的当选 master_node 部分。 metadata 展示响应的 metadata 部分。如果提供逗号分隔的索引列表，则返回的输出将仅包含这些索引的元数据。 nodes 展示响应的 nodes 部分。 none 从响应中排除整个 state 字段。 routing_table 展示响应的 routing_table 部分。 version 展示集群状态版本。 retry_failed （可选，布尔值）如果为 true，则重试分配由于后续分配失败过多而被阻止的分片。 master_timeout （可选，时间单位）等待主节点的时间段。如果主节点在超时到期之前不可用，则请求将失败并返回错误。默认为 30s。也可以设置为 -1 以指示请求永远不会超时。 timeout （可选，时间单位）更新集群元数据后等待集群中所有相关节点响应的时间段。如果在超时到期之前未收到响应，则集群元数据更新仍适用，但响应将指示未完全确认。默认为 30s。也可以设置为 -1 以指示请求永远不会超时。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"集群重路由 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute#请求体","content":"commands （必需，对象数组）定义要执行的命令。支持的命令包括： commands 属性 move 将已启动的分片从一个节点移动到另一个节点。接受 index 和 shard 的索引名称和分片编号，节点的 from_node，以及将分片移动到的节点的 to_node。 cancel 取消分片（或恢复）的分配。接受索引名称和分片编号的 index 和 shard，以及要取消分片分配的节点的 node。这可用于通过取消现有副本并允许通过标准恢复过程重新初始化它们来强制从主分片重新同步现有副本。默认情况下，只能取消副本分片分配。如果需要取消主分片的分配，则请求中还必须包含 allow_primary 标志。 allocate_replica 将未分配的副本分片分配给节点。接受索引名称和分片编号的index 和 shard，以及要将分片分配给的 node。把分配决策器纳入考虑。 还有两个命令可用于将主分片分配给节点。但是，应格外小心使用这些命令，因为主分片分配通常由 Elasticsearch 完全自动处理。无法自动分配主分片的原因包括： 创建了新索引，但没有满足分配决策器的节点。在集群中的当前数据节点上找不到数据的最新分片副本。为防止数据丢失，系统不会自动将过时的分片副本提升为主副本。 以下两个命令很危险，可能会导致数据丢失。它们旨在用于无法恢复原始数据且集群管理员接受丢失的情况。如果您遇到可以修复的临时问题，请参阅上述 retry_failed 标志。需要强调的是：如果执行这些命令，然后节点加入保存受影响分片副本的集群，则新加入的节点上的副本将被删除或覆盖。 allocate_stale_primary 将主分片分配给保存过时副本的节点。接受索引名称和分片编号的索引和分片，以及要将分片分配给的节点。使用此命令可能会导致提供的分片 ID 的数据丢失。如果具有良好数据副本的节点稍后重新加入集群，则该数据将被删除或覆盖为使用此命令强制分配的过时副本的数据。为了确保这些含义得到充分理解，此命令要求将标志 accept_data_loss 显式设置为 true。 allocate_empty_primary 将空主分片分配给节点。接受索引名称和分片编号的索引和分片，以及要将分片分配给的节点。使用此命令会导致完全丢失索引到此分片中的所有数据（如果之前已启动）。如果具有数据副本的节点稍后重新加入集群，则该数据将被删除。为了确保这些含义得到充分理解，此命令要求将标志 accept_data_loss 显式设置为 true。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"集群重路由 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_reroute#示例","content":"这是一个简单的重新路由 API 调用的简短示例： POST /_cluster/reroute?metric=none { &quot;commands&quot;: [ { &quot;move&quot;: { &quot;index&quot;: &quot;test&quot;, &quot;shard&quot;: 0, &quot;from_node&quot;: &quot;node1&quot;, &quot;to_node&quot;: &quot;node2&quot; } }, { &quot;allocate_replica&quot;: { &quot;index&quot;: &quot;test&quot;, &quot;shard&quot;: 1, &quot;node&quot;: &quot;node3&quot; } } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"集群健康 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#请求","content":"GET /_cluster/health/&lt;target&gt;  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 monitor 或 manage 的集群权限以使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#描述","content":"集群健康 API 返回集群健康的简单状态。你还可以使用 API 仅获取指定数据流和索引的健康状况。对于数据流，API 会检索流的后备索引的健康状况。 集群健康状况分为：green（绿色）、yellow（黄色）或 red（红色）。在分片级别，red（红色）状态表示特定分片未在集群中分配，yellow（黄色）表示主分片已分配但副本未分配，green（绿色）表示所有分片均已分配。索引级状态由最差分区状态控制。集群状态由最差索引状态控制。 此 API 的主要优点之一是可以等待集群达到一定的高水位健康水平。例如，以下内容将等待 50 秒，等待集群达到黄色级别（如果在 50 秒后达到 green（绿色）或yellow（黄色）状态，则会在此时返回）： GET /_cluster/health?wait_for_status=yellow&amp;timeout=50s  ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#路径参数","content":"&lt;target&gt; （可选，字符串） 用于限制请求的数据流、索引和索引别名的逗号分隔列表。支持通配符表达式 (*)。 要以集群中的所有数据流和索引为目标，请省略此参数或使用 _all 或 *。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#查询参数","content":"level （可选，字符串） 可以是 cluster（集群）、indices（索引）或 shards（分片）之一。控制返回的健康信息的详细信息级别。默认为 cluster（集群）。 local （可选，布尔值） 如果为 true，则请求只从本地节点检索信息。默认为 false，表示从主节点获取信息。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时前主节点不可用，则请求失败并返回错误信息。默认值为 30s。也可以设置为 -1，表示请求永不超时。 timeout （可选，时间单位）更新集群元数据后等待集群中所有相关节点响应的时间。如果在超时前未收到任何响应，群集元数据更新仍将适用，但响应将显示未完全确认。默认为 30s。也可以设置为 -1，表示请求永不超时。 wait_for_active_shards （可选，字符串）一个数字，表示要等待多少个激活的分片，all 表示等待集群中所有分片都激活，0 表示不等待。默认为 0。 wait_for_events （可选，字符串）可以是 immediate、 urgent、 high、 normal、 low、 languid中的一个。等待当前队列中所有具有给定优先级的事件被处理完毕。 wait_for_no_initializing_shards （可选，布尔值）一个布尔值，用于控制是否等待（直到提供的超时时间）集群没有分片初始化。默认值为 false，即不等待分片初始化。 wait_for_no_relocating_shards （可选，布尔值）一个布尔值，用于控制是否等待（直到提供的超时时间）集群没有分片重定位。默认值为 false，即不等待分片重定位。 wait_for_nodes （可选，字符串）请求等待指定数量的 N 节点可用。它也接受 &gt;=N、&lt;=N、&gt;N 和 &lt;N。也可以使用 ge(N)、le(N)、gt(N)和 lt(N) 符号。 wait_for_status （可选，字符串）green（绿色）、yellow（黄色）或 red（红色）之一。将等待（直到超时）群集的状态变为所提供的状态或更好的状态，即 green（绿色）&gt; yellow（黄色） &gt; red`（红色。默认情况下，不会等待任何状态。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#响应体","content":"cluster_name （字符串）集群的名称。 status （字符串）群集的健康状态，基于其主分片和副本分片的状态。状态包括： green:所有分区都已分配。yellow: 所有主分片都已分配，但一个或多个副本分片未分配。如果集群中的一个节点发生故障，在该节点修复之前，一些数据可能无法使用。red: 一个或多个主分区未分配，因此某些数据不可用。这种情况可能在群集启动期间主分区分配时短暂出现。 timed_out （布尔值）如果为 false，则在超时参数指定的时间内（默认为 30s）返回响应。 number_of_nodes （整数）集群内的节点数。 number_of_data_nodes （整数）专用数据节点的数量。 active_primary_shards（整数）活动主分区的数量。 active_shards （整数）活动主分片和副本分片的总数。 relocating_shards（整数）正在重新定位的分片数量。 initializing_shards（整数） 正在初始化的分片数量。 unassigned_shards（整数）未分配的分区数量。 unassigned_primary_shards （整数）主要但未分配的分片数量。注意：如果集群中包含运行低于 8.16 版本的节点，则该数字可能低于真实值。要在这种情况下获得更准确的计数，请使用集群健康 API。 delayed_unassigned_shards （整数）因超时设置而延迟分配的分片数量。 number_of_pending_tasks（整数）尚未执行的群集级更改的数量。 number_of_in_flight_fetch （整数）未完成的获取次数。 task_max_waiting_in_queue_millis （整数）最早启动的任务等待执行的时间，以毫秒为单位。 active_shards_percent_as_number （浮点数）集群中活动分片的比例，以百分比表示。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"集群健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_health#示例","content":"GET _cluster/health  如果单节点集群中只有一个索引，且只有一个分片和一个副本，API 会返回以下响应： { &quot;cluster_name&quot;: &quot;testcluster&quot;, &quot;status&quot;: &quot;yellow&quot;, &quot;timed_out&quot;: false, &quot;number_of_nodes&quot;: 1, &quot;number_of_data_nodes&quot;: 1, &quot;active_primary_shards&quot;: 1, &quot;active_shards&quot;: 1, &quot;relocating_shards&quot;: 0, &quot;initializing_shards&quot;: 0, &quot;unassigned_shards&quot;: 1, &quot;unassigned_primary_shards&quot;: 0, &quot;delayed_unassigned_shards&quot;: 0, &quot;number_of_pending_tasks&quot;: 0, &quot;number_of_in_flight_fetch&quot;: 0, &quot;task_max_waiting_in_queue_millis&quot;: 0, &quot;active_shards_percent_as_number&quot;: 50.0 }  下面是一个在 shards（分片）级别获取集群健康状况的示例： GET /_cluster/health/my-index-000001?level=shards  原文链接 ","version":"Next","tagName":"h2"},{"title":"创建数据流","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/create_data_stream","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建数据流","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/create_data_stream#请求","content":"PUT /_data_stream/&lt;data-stream&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"创建数据流","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/create_data_stream#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 create_index 或 manage 的索引权限。已启用数据流的匹配索引模板。参阅设置数据流。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"创建数据流","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/create_data_stream#路径参数","content":"&lt;data-stream&gt; (必须，字符串） 要创建的数据流的名称。数据流名称必须符合以下条件： 只能是小写不能包含 \\，/，*，?，&quot;，&lt;，&gt;，|，,，#，: 或空格符不能以这些开头：-，_，+，或 .ds-长度不能超过 255 字节。多字节字符的计算速度更快。 原文链接 ","version":"Next","tagName":"h2"},{"title":"数据流 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/","content":"数据流 API 以下 API 可用于管理数据流： 创建数据流删除数据流获取数据流迁移到数据流数据流统计推广数据流修改数据流 以下 API 可用于管理数据流的内置生命周期： 警告 此功能为技术预览版，可能会在未来版本中更改或删除。Elastic 将努力修复任何问题，但技术预览版中的功能不受官方 GA 功能的支持服务级别协议约束。 更新数据流生命周期 [预览版］获取数据流生命周期 [预览版］删除数据流生命周期 [预览版］解释数据流生命周期 [预览版］获取数据流生命周期统计数据[预览版］ 以下 API 可用于时序数据流： 下采样 有关概念和教程，参阅数据流。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"删除数据流 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream#请求","content":"DELETE /_data_stream/&lt;data-stream&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 delete_index 或 manage 的索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream#路径参数","content":"&lt;data-stream&gt; （必需，字符串）要删除的数据流的逗号分隔列表。支持通配符 （*） 表达式。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream#查询参数","content":"expand_wildcards （可选，字符串）通配符模式可以匹配的数据流类型。支持逗号分隔值，例如 open,hidden。有效值为： all，hidden 匹配任何数据流或索引，包括隐藏的。 open，closed 匹配任何非隐藏的数据流。无法关闭 Data Streams。 none 不接受通配符模式。 默认为 open。 原文链接 ","version":"Next","tagName":"h2"},{"title":"健康 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#请求","content":"GET /_health_report  GET /_health_report/&lt;indicator&gt;  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 monitor 或 manage 的集群权限以使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#描述","content":"健康 API 返回包含 Elasticsearch 集群健康状况的报告。该报告包含组成 Elasticsearch 功能的指标列表。 每个指示器的运行状况为：green（绿色）、unknown（未知）、yellow（黄色）或 red（红色）。该指标将提供解释和元数据，描述其当前健康状态的原因。 集群的状态由最差的指标状态控制。 如果指标的状态为非绿色，则指标结果中可能会出现影响列表，其中详细说明了受健康问题负面影响的功能。每个影响都带有一个严重性级别、受影响的系统区域以及对系统影响的简单描述。 一些健康指标可以确定健康问题的根本原因，并规定一组可以执行的步骤，以改善系统的健康状况。根本原因和修正步骤封装在 diagnosis（诊断）中。诊断包含详细说明根本原因分析的原因、包含解决问题的步骤的简要说明、受影响资源的列表（如果适用）以及用于修复已诊断问题的详细分步故障排除指南的作。 提示 运行状况指示器对非绿色运行状况状态执行根本原因分析。频繁调用时，这可能会造成计算成本。设置运行状况 API 的自动轮询时，请将 verbose 设置为 false 以禁用更昂贵的分析逻辑。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#路径参数","content":"&lt;indicator&gt; （可选，字符串）将返回的信息限制为特定指标。支持的指标包括： master_is_stable 报告有关节点稳定性的运行状况问题，该节点被处理运行状况请求的节点视为主节点。如果在短时间内观察到足够多的主变化，该指标将旨在诊断并报告有关其检测到的集群形成问题的有用信息。 shards_availability 报告有关分片分配的运行状况问题。 disk 报告因磁盘空间不足而导致的运行状况问题。 ilm 报告与索引生命周期管理相关的运行状况问题。 repository_integrity 跟踪存储库完整性并报告存储库损坏、未知或无效时出现的运行状况问题。 slm 报告与快照生命周期管理相关的运行状况问题。 shards_capacity 报告与群集分片容量相关的运行状况问题。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#查询参数","content":"verbose （可选，布尔值）如果为 true，则响应将包含有助于解释每个非绿色指示器的状态的其他详细信息。这些详细信息包括其他故障排除指标，有时还包括运行状况的根本原因分析。默认为 true。 size （可选，整数）要返回的受影响资源的最大数量。由于诊断可以返回多种类型的受影响资源，因此此参数会将每种类型返回的资源数量限制为配置值（例如，诊断可以返回 1000 个受影响的索引和 1000 个受影响的节点）。默认为 1000。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#响应体","content":"cluster_name （字符串）集群的名称。 status （可选，字符串）集群的运行状况，基于集群中所有指标的聚合状态。如果请求特定指标的运行状况，则将省略此顶级状态。状态为： green集群状态健康unknown无法检测集群的健康yellow集群的功能处于降级状态，可能需要修正以避免运行状况变为红色。red集群正在发生中断或某些功能无法使用。 indicators （对象）有关集群指示器运行状况的信息。 indicators 属性 &lt;indicator&gt; （对象）包含指标的运行状况结果。 &lt;indicator&gt; 属性 status（字符串）指标的运行状况。状态为： green集群状态健康unknown无法检测集群的健康yellow集群的功能处于降级状态，可能需要修正以避免运行状况变为红色。red集群正在发生中断或某些功能无法使用。 symptom （字符串）提供有关当前运行状况的信息的消息。 details （可选，对象）一个对象，其中包含有关导致当前运行状况结果的集群的其他信息。此数据是非结构化的，每个指示器返回一组唯一的详细信息。如果 verbose 属性设置为 false，则不会计算详细信息。 impacts （可选，数组）如果返回非正常状态，则指示器可能包括此运行状况状态将对集群产生的影响列表。 impacts 属性 severity （整数）这种影响对集群的功能有多重要。值 1 表示最高严重性，值越大表示严重性越低。 description （字符串）对集群的影响的描述。 impact_areas （字符串数组）此影响影响的集群功能领域。可能的值包括： searchingestbackupdeployment_management diagnosis （可选，数组）如果返回非正常状态，指示器可能包括封装运行状况问题原因的诊断列表以及为修正问题而要采取的作。如果 verbose 属性为 false，则不会计算诊断。 diagnosis 属性 cause（字符串）描述此健康问题的根本原因。action（字符串）简要说明为修正问题应采取的步骤。help_url 字段提供了修复问题的更详细的分步指南affected_resources（可选，对象）一个对象，其中键表示资源类型（例如索引、分片），值是受问题影响的特定资源的列表。help_url（字符串）指向解决健康问题的故障排除指南的链接。 ","version":"Next","tagName":"h2"},{"title":"指标详情​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#指标详情","content":"健康 API 中的每个运行状况指示器都会返回一组详细信息，这些详细信息进一步解释了系统的状态。详细信息具有每个指标唯一的内容和结构。 ","version":"Next","tagName":"h2"},{"title":"master_is_stable​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#master_is_stable","content":"current_master （对象）有关当前当选的主节点的信息。 current_master 属性 node_id（字符串）当前选择的主节点的节点 ID，如果未选择主节点，则为 null。name（字符串）当前选择的主节点的节点名称，如果未选择主节点，则为 null recent_masters （可选，数组）在最近一段时间内被选为或替换为主节点的节点列表。如果主站变化得足够快以导致问题，则此字段存在，当指示灯为绿色时，也作为附加信息出现。此数组仅包括当选的主节点，并且不包括没有当选主节点的空条目。 recent_masters 属性 node_id（字符串）最近活动的主节点的节点 ID。name（字符串）最近活动的主节点的节点名称。 exception_fetching_history （可选，对象）如果被查询的节点发现当选的主节点已反复降级，则会从最近当选的主节点请求主历史记录以进行诊断。如果获取此远程历史记录失败，则在此详细信息字段中返回异常信息。 exception_fetching_history 属性 message（字符串）失败的历史记录获取作的异常消息。stack_trace（字符串）失败的历史记录获取作的堆栈跟踪。 cluster_formation （可选，数组）如果最近没有选定的主节点，则被查询的节点会尝试收集有关集群无法形成的原因的信息，或者为什么被查询的节点无法加入集群（如果已形成）。此数组可以包含每个符合主条件的节点的集群形成视图的任何条目。 cluster_formation 属性 node_id（字符串）符合主节点条件的节点 IDname（可选，字符串）符合主节点条件的节点名称cluster_formation_message（字符串）详细说明，解释集群形成出了什么问题，或者为什么此节点在集群形成时无法加入集群。 ","version":"Next","tagName":"h3"},{"title":"shards_availability​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#shards_availability","content":"unassigned_primaries（整数）由于初始化或重定位以外的原因而未分配的主分片数。initializing_primaries（整数）正在初始化或恢复的主分片数。creating_primaries（整数）由于最近创建的主分片而未分配的主分片数。creating_replicas（整数）由于最近创建的副本分片而未分配的副本分片数。restarting_primaries（整数）由于节点关闭作而重新定位的主分片数。started_primaries（整数）由于节点关闭作而重新定位的主分片数。unassigned_replicas（整数）由于初始化或重定位以外的原因而未分配的副本分片数。initializing_replicas（整数）正在初始化或恢复的副本分片数。restarting_replicas（整数）由于节点关闭作而重新定位的副本分片数。started_replicas（整数）系统上处于活动状态且可用的副本分片数。 ","version":"Next","tagName":"h3"},{"title":"disk​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#disk","content":"indices_with_readonly_block（整数）由于集群空间不足，系统强制执行只读索引块 （index.blocks.read_only_allow_delete） 的索引数。nodes_with_enough_disk_space（整数）具有足够可用磁盘空间来运行的节点数。nodes_over_high_watermark（整数）磁盘不足且空间可能不足的节点数。他们的磁盘使用率已超过高水位线阈值。nodes_over_flood_stage_watermark（整数）磁盘不足的节点数。他们的磁盘使用率已超过洪水阶段水印阈值。unknown_nodes（整数）无法确定其磁盘运行状况的节点数。 ","version":"Next","tagName":"h3"},{"title":"repository_integrity​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#repository_integrity","content":"total_repositories（可选，整数）系统上当前配置的仓库数。如果未配置仓库，则省略此详细信息。corrupted_repositories（可选，整数）系统上已确定为已损坏的仓库数。如果未检测到损坏的仓库，则省略此详细信息。corrupted（可选，字符串数组）如果在系统中检测到损坏的仓库，则此字段中最多会显示 10 个存储库的名称。如果未找到损坏的存储库，则省略此详细信息。unknown_repositories（可选，整数）已被至少一个节点确定为未知的存储库数。如果未检测到未知存储库，则省略此详细信息。invalid_repositories（可选，整数）已被至少一个节点确定为无效的存储库数。如果未检测到无效存储库，则省略此详细信息。 ","version":"Next","tagName":"h3"},{"title":"ilm​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#ilm","content":"ilm_status（字符串）索引生命周期管理功能的当前状态。STOPPED、STOPPING 或 RUNNING。 policies（整数）系统正在管理的索引生命周期策略的数量。 stagnating_indices（整数）索引生命周期管理管理的停滞时间超过预期的索引数量。 stagnating_indices_per_action（可选，Map）按作分组的指数数量摘要，这些指数的停滞时间超过预期。 stagnating_indices_per_action 属性 downsample（整数）下采样动作中停滞指数的数量。allocate（整数）分配作中停滞的索引数。shrink（整数）收缩作中停滞的索引数。searchable_snapshot（整数）searchable_snapshot 作中停滞的指数数量。rollover（整数）滚轮动作中停滞索引的数量。forcemerge（整数）forcemerge 作中停滞的索引数。delete（整数）删除作中停滞索引的数量。migrate（整数）迁移作中停滞的索引数。 ","version":"Next","tagName":"h3"},{"title":"slm​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#slm","content":"slm_status（字符串）快照生命周期管理功能的当前状态。STOPPED、STOPPING 或 RUNNING。policies（整数）系统正在管理的快照策略数。unhealthy_policies（映射）由于多次连续调用失败而被视为不正常的策略的详细视图。计数键表示不正常策略的数量 （整数）。invocations_since_last_success 键将报告一个映射，其中不正常的策略名称是键，其相应的失败调用数是值。 ","version":"Next","tagName":"h3"},{"title":"shards_capacity​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#shards_capacity","content":"data（映射）该视图包含有关不属于冻结层的数据节点的分片的当前容量的信息。 data 属性 max_shards_in_cluster（整数）表示集群可以容纳的最大分片数。current_used_shards（可选，整数）集群持有的分片总数。仅在指标状态为红色或黄色的情况下显示。 frozen （映射）包含有关属于冻结层的数据节点的分片当前容量信息的视图。 frozen 属性 max_shards_in_cluster（整数）指示集群可以为部分挂载的索引保留的最大分片数。current_used_shards（可选，整数）部分挂载索引在集群中的分片总数。仅在指标状态为红色或黄色的情况下显示。 ","version":"Next","tagName":"h3"},{"title":"示例​","type":1,"pageTitle":"健康 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/health#示例","content":"GET _health_report  无论当前状态如何，API 都会返回包含所有指标的响应。 GET _health_report/shards_availability  API 仅返回分片可用性指示器的响应。 GET _health_report?verbose=false  API 返回包含所有运行状况指标的响应，但不会计算响应的详细信息或根本原因分析。如果要监视运行状况 API，并且不希望每次调用计算其他故障排除详细信息的开销，这将非常有用。 原文链接 ","version":"Next","tagName":"h2"},{"title":"删除数据流生命周期","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"删除数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_data_stream_lifecycle 的索引权限。更多信息，参阅安全权限。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"删除数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle#请求","content":"DELETE _data_stream/&lt;data-stream&gt;/_lifecycle ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"删除数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle#描述","content":"从指定的数据流中删除生命周期。如果提供了多个数据流，但其中只要有一个不存在，那么删除所有数据流中的生命周期都将失败，API 将以 404 响应。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle#路径参数","content":"&lt;data-stream&gt; （必需，字符串）要删除的数据流的逗号分隔列表。支持通配符 （*） 表达式。要针对所有数据流，请使用 * 或 _all。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle#查询参数","content":"expand_wildcards （可选，字符串）通配符模式可以匹配的数据流类型。支持逗号分隔值，例如 open,hidden。有效值为： all，hidden 匹配任何数据流或索引，包括隐藏的。 open，closed 匹配任何非隐藏的数据流。无法关闭 Data Streams。 none 不接受通配符模式。 默认为 open。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"删除数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/delete_data_stream_lifecycle#示例","content":"下面的示例删除了 my-data-stream 的生命周期： DELETE _data_stream/my-data-stream/_lifecycle  从所有选定数据流中成功删除策略后，会收到以下结果： { &quot;acknowledged&quot;: true }  原文链接 ","version":"Next","tagName":"h2"},{"title":"数据流统计 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"数据流统计 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 monitor 或 manage 的索引权限。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"数据流统计 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats#请求","content":"GET /_data_stream/&lt;data-stream&gt;/_stats ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"数据流统计 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats#路径参数","content":"&lt;data-stream&gt; (可选，字符串） 用于限制请求的数据流的逗号分隔列表。支持通配符表达式 (*)。 要以集群中的所有数据流为目标，请省略此参数或使用 *。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"数据流统计 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats#查询参数","content":"expand_wildcards （可选，字符串）通配符模式可以匹配的数据流类型。支持逗号分隔值，例如 open,hidden。有效值为： all，hidden 匹配任何数据流或索引，包括隐藏的。 open，closed 匹配任何非隐藏的数据流。无法关闭 Data Streams。 none 不接受通配符模式。 默认为 open。 human (可选，布尔值） 如果为 true，则响应会包含以人类可读字节值表示的统计数据。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"数据流统计 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats#响应体","content":"_shards (对象）包含试图执行请求的分片的信息。 _shards 属性 total (整数）尝试执行请求的分片总数。 successful (整数）成功执行请求的分片数。 failed (整数）未能执行请求的分片数量。 data_stream_count (整数）所选数据流的总数。 backing_indices (整数）所选数据流的备份索引总数。 total_store_size (字节值）所选数据流的所有分块的总大小。只有当 human 查询参数为 true 时，才会包含此属性。 total_store_size_bytes (整数）所选数据流所有分块的总大小（字节）。 data_streams (对象数组） 包含所选数据流的统计数据。 data_streams 对象属性 data_stream (字符串） 数据流的名称。 backing_indices (整数）数据流的当前后备索引数。 store_size (字节值）数据流后备索引所有分片的总大小。只有当 human 查询参数为 true 时，才会返回该参数。 store_size_bytes (整数）数据流后备索引所有分片的总大小（以字节为单位）。 maximum_timestamp (整数) 数据流的最高 @timestamp 值，转换为 Unix epoch以来的毫秒数。 提示 如果满足以下一个或多个条件，数据流中的 @timestamp 值可能高于此值： 数据流包含已关闭的后备索引。生成时间较短的备份索引包含较高的 @timestamp 值。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"数据流统计 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/data_stream_stats#示例","content":"GET /_data_stream/my-data-stream*/_stats?human=true  API 返回以下响应。 { &quot;_shards&quot;: { &quot;total&quot;: 10, &quot;successful&quot;: 5, &quot;failed&quot;: 0 }, &quot;data_stream_count&quot;: 2, &quot;backing_indices&quot;: 5, &quot;total_store_size&quot;: &quot;7kb&quot;, &quot;total_store_size_bytes&quot;: 7268, &quot;data_streams&quot;: [ { &quot;data_stream&quot;: &quot;my-data-stream&quot;, &quot;backing_indices&quot;: 3, &quot;store_size&quot;: &quot;3.7kb&quot;, &quot;store_size_bytes&quot;: 3772, &quot;maximum_timestamp&quot;: 1607512028000 }, { &quot;data_stream&quot;: &quot;my-data-stream-two&quot;, &quot;backing_indices&quot;: 2, &quot;store_size&quot;: &quot;3.4kb&quot;, &quot;store_size_bytes&quot;: 3496, &quot;maximum_timestamp&quot;: 1607425567000 } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"解释数据流生命周期","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"解释数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_data_stream_lifecycle 的索引权限或 view_index_metadata 索引权限来使用此 API。更多信息，参阅安全权限。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"解释数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle#请求","content":"GET &lt;target&gt;/_lifecycle/explain ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"解释数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle#描述","content":"读取有关索引或数据流当前数据流生命周期状态的信息，如创建索引以来的时间、翻转以来的时间、管理索引的生命周期配置，或 Elasticsearch 在生命周期执行期间可能遇到的任何错误。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"解释数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle#路径参数","content":"&lt;target&gt; (必需，字符串） 用逗号分隔的索引或数据流列表。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"解释数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle#查询参数","content":"include_defaults (可选，布尔值）包含与目标生命周期相关的默认配置。默认为 false。 master_timeout (可选，时间单位）等待主节点的时间。如果在超时前主节点不可用，则请求失败并返回错误。默认为 30s。也可以设置为 -1，表示请求永不超时。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"解释数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/explain_data_stream_lifecycle#示例","content":"如果要检索数据流中所有后备索引的生命周期状态，可以使用数据流名称。为简单起见，以下示例检索了一个后备索引 .ds-metrics-2023.03.22-000001 的生命周期状态： GET .ds-metrics-2023.03.22-000001/_lifecycle/explain  如果该索引由数据流生命周期管理，则解释将显示 managed_by_lifecycle 字段设置为 true，响应的其余部分将包含有关该索引生命周期执行状态的信息： { &quot;indices&quot;: { &quot;.ds-metrics-2023.03.22-000001&quot;: { &quot;index&quot; : &quot;.ds-metrics-2023.03.22-000001&quot;, &quot;managed_by_lifecycle&quot; : true, &quot;index_creation_date_millis&quot; : 1679475563571, &quot;time_since_index_creation&quot; : &quot;843ms&quot;, &quot;rollover_date_millis&quot; : 1679475564293, &quot;time_since_rollover&quot; : &quot;121ms&quot;, &quot;lifecycle&quot; : { }, &quot;generation_time&quot; : &quot;121ms&quot; } }  &quot;managed_by_lifecycle&quot; : true：显示索引是否由数据流生命周期管理。如果索引不是由数据流生命周期管理，则不会显示其他字段&quot;index_creation_date_millis&quot; : 1679475563571：创建索引的时间，该时间戳用于确定何时翻转&quot;time_since_index_creation&quot; : &quot;843ms&quot;：索引创建后的时间（用于通过 max_age 计算何时翻转索引）&quot;rollover_date_millis&quot; : 1679475564293：索引翻转的时间。如果索引没有滚动，则不会显示。&quot;time_since_rollover&quot; : &quot;121ms&quot;：翻转后的时间。如果索引没有滚动，则不会显示。&quot;lifecycle&quot; : { }：适用于该索引的生命周期配置（在父数据流中进行了配置）&quot;generation_time&quot; : &quot;121ms&quot;：索引的生成时间表示索引开始进入生命周期中用户可配置/业务特定部分（如保留）的时间。如果存在 generation_time，则从该日期开始计算生成时间；如果存在翻转日期，则从该日期开始计算生成时间；如果其他两个日期都不存在，则从创建日期开始计算生成时间。如果该索引是写入索引，则不会报告 generation_time，因为它不符合保留或生命周期其他部分的条件。 explain 还会报告与目标索引生命周期执行相关的任何错误： { &quot;indices&quot;: { &quot;.ds-metrics-2023.03.22-000001&quot;: { &quot;index&quot; : &quot;.ds-metrics-2023.03.22-000001&quot;, &quot;managed_by_lifecycle&quot; : true, &quot;index_creation_date_millis&quot; : 1679475563571, &quot;time_since_index_creation&quot; : &quot;843ms&quot;, &quot;lifecycle&quot; : { &quot;enabled&quot;: true }, &quot;error&quot;: &quot;{\\&quot;type\\&quot;:\\&quot;validation_exception\\&quot;,\\&quot;reason\\&quot;:\\&quot;Validation Failed: 1: this action would add [2] shards, but this cluster currently has [4]/[3] maximum normal shards open;\\&quot;}&quot; } }  &quot;error&quot;:：由于集群中允许的分片数量限制，无法翻转目标索引。 原文链接 ","version":"Next","tagName":"h2"},{"title":"下采样索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/downsample","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"下采样索引 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/downsample#请求","content":"POST /&lt;source-index&gt;/_downsample/&lt;output-downsampled-index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"下采样索引 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/downsample#前置条件","content":"仅支持时序数据流中的索引。如果启用了 Elasticsearch 安全功能，则必须拥有数据流的 all 或 manage 索引权限。源索引上不能定义字段或文档级安全性。源索引必须是只读的（index.blocks.write: true）。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"下采样索引 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/downsample#路径参数","content":"&lt;source-index&gt; (可选，字符串）要进行下采样的时间序列索引名称。 &lt;output-downsampled_index&gt; (必须，字符串） 要创建的索引的名称。 只能是小写字符不能包含字符：\\、/、*、?、&quot;、&lt;、&gt;、|、 (空格)、,、#7.0 之前索引可以包含冒号（:），但在 7.0 之后不推荐。不能以 -、_、+ 开头不能是 . 或 ..长度不能超过 255 字节（注意是字节，所以多字节字符会更快达到 255 的限制）名字以 . 开头不推荐，除非由插件管理的隐藏索引和内部索引 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"下采样索引 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/downsample#查询参数","content":"fixed_interval (必填，时间单位）汇总原始时间序列索引的时间间隔。例如，60m 为每个 60 分钟（每小时）间隔生成一个文档。这遵循 Elasticsearch 中其他地方使用的标准时间格式语法。 提示 更小、更细的区间所占空间也更大。 原文链接 ","version":"Next","tagName":"h2"},{"title":"集群分配解释 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#请求","content":"GET _cluster/allocation/explain POST _cluster/allocation/explain ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 monitor 或 manage 的集群权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#描述","content":"集群分配解释 API 的目的是为集群中的分片分配提供解释。对于未分配的分片，解释 API 会解释分片未分配的原因。对于已分配的分片，解释 API 会解释分片为何仍留在当前节点上，而没有移动或重新平衡到其他节点。在尝试诊断分片未被分配的原因或碎片为何继续留在当前节点上时，这个 API 可能会非常有用。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#查询参数","content":"include_disk_info （可选，布尔值）如果为 true，则返回有关磁盘使用情况和分片大小的信息。默认为 false。 include_yes_decisions （可选，布尔值） 如果为 true，则在解释中返回 YES 的决定。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#请求体","content":"current_node（可选，字符串） 指定当前持有要解释的分区的节点 ID 或名称。要解释未指定的分区，请省略此参数。 index（可选，字符串） 指定需要解释的索引名称。 primary（可选，布尔值） 如果为 true，则返回给定分区 ID 的主分区解释。 shard（可选，整数） 指定要解释的分区 ID。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#示例","content":"","version":"Next","tagName":"h2"},{"title":"未指定的主分区​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#未指定的主分区","content":"冲突的设置​ 下面的请求会得到一个未指定主分区的分配解释。 GET _cluster/allocation/explain { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;shard&quot;: 0, &quot;primary&quot;: true }  API 响应显示分区只能分配给一个不存在的节点。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : true, &quot;current_state&quot; : &quot;unassigned&quot;, &quot;unassigned_info&quot; : { &quot;reason&quot; : &quot;INDEX_CREATED&quot;, &quot;at&quot; : &quot;2017-01-04T18:08:16.600Z&quot;, &quot;last_allocation_status&quot; : &quot;no&quot; }, &quot;can_allocate&quot; : &quot;no&quot;, &quot;allocate_explanation&quot; : &quot;Elasticsearch isn't allowed to allocate this shard to any of the nodes in the cluster. Choose a node to which you expect this shard to be allocated, find this node in the node-by-node explanation, and address the reasons which prevent Elasticsearch from allocating this shard there.&quot;, &quot;node_allocation_decisions&quot; : [ { &quot;node_id&quot; : &quot;8qt2rY-pT6KNZB3-hGfLnw&quot;, &quot;node_name&quot; : &quot;node-0&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9401&quot;, &quot;roles&quot; : [&quot;data&quot;, &quot;data_cold&quot;, &quot;data_content&quot;, &quot;data_frozen&quot;, &quot;data_hot&quot;, &quot;data_warm&quot;, &quot;ingest&quot;, &quot;master&quot;, &quot;ml&quot;, &quot;remote_cluster_client&quot;, &quot;transform&quot;], &quot;node_attributes&quot; : {}, &quot;node_decision&quot; : &quot;no&quot;, &quot;weight_ranking&quot; : 1, &quot;deciders&quot; : [ { &quot;decider&quot; : &quot;filter&quot;, &quot;decision&quot; : &quot;NO&quot;, &quot;explanation&quot; : &quot;node does not match index setting [index.routing.allocation.include] filters [_name:\\&quot;nonexistent_node\\&quot;]&quot; } ] } ] }  &quot;current_state&quot; : &quot;unassigned&quot;, ：分块的当前状态。&quot;reason&quot; : &quot;INDEX_CREATED&quot;,：分区最初成为未指定分区的原因。&quot;can_allocate&quot; : &quot;no&quot;, ：是否分配分区。&quot;node_decision&quot; : &quot;no&quot;, ：是否将分区分配给特定节点。&quot;decider&quot; : &quot;filter&quot;,：导致不决定该节点的决定因素。&quot;explanation&quot; : &quot;node does not match index setting [index.routing.allocation.include] filters [_name:\\&quot;nonexistent_node\\&quot;]&quot; ：解释判定器为何返回 &quot;否 &quot;判定，并提供指向导致该判定的设置的有用提示。在这个示例中，一个新创建的索引的索引设置要求只能分配给一个名为 nonexistent_node 的节点，而这个节点并不存在，因此索引无法分配。 参阅此视频，了解如何排除节点和索引设置不匹配的故障。 超过最大重试次数​ 以下响应包含对已达到最大分配重试次数的未分配主分区的分配解释。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : true, &quot;current_state&quot; : &quot;unassigned&quot;, &quot;unassigned_info&quot; : { &quot;at&quot; : &quot;2017-01-04T18:03:28.464Z&quot;, &quot;failed shard on node [mEKjwwzLT1yJVb8UxT6anw]: failed recovery, failure RecoveryFailedException&quot;, &quot;reason&quot;: &quot;ALLOCATION_FAILED&quot;, &quot;failed_allocation_attempts&quot;: 5, &quot;last_allocation_status&quot;: &quot;no&quot;, }, &quot;can_allocate&quot;: &quot;no&quot;, &quot;allocate_explanation&quot;: &quot;cannot allocate because allocation is not permitted to any of the nodes&quot;, &quot;node_allocation_decisions&quot; : [ { &quot;node_id&quot; : &quot;3sULLVJrRneSg0EfBB-2Ew&quot;, &quot;node_name&quot; : &quot;node_t0&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9400&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;node_decision&quot; : &quot;no&quot;, &quot;store&quot; : { &quot;matching_size&quot; : &quot;4.2kb&quot;, &quot;matching_size_in_bytes&quot; : 4325 }, &quot;deciders&quot; : [ { &quot;decider&quot;: &quot;max_retry&quot;, &quot;decision&quot; : &quot;NO&quot;, &quot;explanation&quot;: &quot;shard has exceeded the maximum number of retries [5] on failed allocation attempts - manually call [POST /_cluster/reroute?retry_failed&amp;metric=none] to retry, [unassigned_info[[reason=ALLOCATION_FAILED], at[2024-07-30T21:04:12.166Z], failed_attempts[5], failed_nodes[[mEKjwwzLT1yJVb8UxT6anw]], delayed=false, details[failed shard on node [mEKjwwzLT1yJVb8UxT6anw]: failed recovery, failure RecoveryFailedException], allocation_status[deciders_no]]]&quot; } ] } ] }  当 Elasticsearch 无法分配分区时，它会尝试重试分配，但最多不超过允许的最大重试次数。之后，Elasticsearch 将停止尝试分配分区，以防止出现可能影响集群性能的无限重试。运行集群重路由 API 重试分配，如果阻止分配的问题已经解决，则会分配分区。 没有有效的分区副本​ 以下响应包含对之前分配的未分配主分区的分配解释。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : true, &quot;current_state&quot; : &quot;unassigned&quot;, &quot;unassigned_info&quot; : { &quot;reason&quot; : &quot;NODE_LEFT&quot;, &quot;at&quot; : &quot;2017-01-04T18:03:28.464Z&quot;, &quot;details&quot; : &quot;node_left[OIWe8UhhThCK0V5XfmdrmQ]&quot;, &quot;last_allocation_status&quot; : &quot;no_valid_shard_copy&quot; }, &quot;can_allocate&quot; : &quot;no_valid_shard_copy&quot;, &quot;allocate_explanation&quot; : &quot;Elasticsearch can't allocate this shard because there are no copies of its data in the cluster. Elasticsearch will allocate this shard when a node holding a good copy of its data joins the cluster. If no such node is available, restore this index from a recent snapshot.&quot; }  如果分区未分配且分配状态为 no_valid_shard_copy，则应确保所有节点都在集群中。如果包含分片同步副本的所有节点都丢失了，则可以恢复分片数据。 有关 no_valid_shard_copy 故障排除的视频，参阅此视频。 ","version":"Next","tagName":"h3"},{"title":"未指定副本分片​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#未指定副本分片","content":"分配延迟​ 以下响应包含因延迟分配而未分配副本的分配解释。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : false, &quot;current_state&quot; : &quot;unassigned&quot;, &quot;unassigned_info&quot; : { &quot;reason&quot; : &quot;NODE_LEFT&quot;, &quot;at&quot; : &quot;2017-01-04T18:53:59.498Z&quot;, &quot;details&quot; : &quot;node_left[G92ZwuuaRY-9n8_tc-IzEg]&quot;, &quot;last_allocation_status&quot; : &quot;no_attempt&quot; }, &quot;can_allocate&quot; : &quot;allocation_delayed&quot;, &quot;allocate_explanation&quot; : &quot;The node containing this shard copy recently left the cluster. Elasticsearch is waiting for it to return. If the node does not return within [%s] then Elasticsearch will allocate this shard to another node. Please wait.&quot;, &quot;configured_delay&quot; : &quot;1m&quot;, &quot;configured_delay_in_millis&quot; : 60000, &quot;remaining_delay&quot; : &quot;59.8s&quot;, &quot;remaining_delay_in_millis&quot; : 59824, &quot;node_allocation_decisions&quot; : [ { &quot;node_id&quot; : &quot;pmnHu_ooQWCPEFobZGbpWw&quot;, &quot;node_name&quot; : &quot;node_t2&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9402&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;node_decision&quot; : &quot;yes&quot; }, { &quot;node_id&quot; : &quot;3sULLVJrRneSg0EfBB-2Ew&quot;, &quot;node_name&quot; : &quot;node_t0&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9400&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;node_decision&quot; : &quot;no&quot;, &quot;store&quot; : { &quot;matching_size&quot; : &quot;4.2kb&quot;, &quot;matching_size_in_bytes&quot; : 4325 }, &quot;deciders&quot; : [ { &quot;decider&quot; : &quot;same_shard&quot;, &quot;decision&quot; : &quot;NO&quot;, &quot;explanation&quot; : &quot;a copy of this shard is already allocated to this node [[my-index-000001][0], node[3sULLVJrRneSg0EfBB-2Ew], [P], s[STARTED], a[id=eV9P8BN1QPqRc3B4PLx6cg]]&quot; } ] } ] }  &quot;configured_delay&quot; : &quot;1m&quot;：由于持有副本分片的节点离开集群，在分配不存在的副本分片之前配置的延迟。&quot;remaining_delay&quot; : &quot;59.8s&quot;：分配副本分片前的剩余延迟。&quot;store&quot; : { ：节点上发现的分片数据信息。 分配节流​ 下面的响应包含一个副本的分配解释，该副本已排队分配，但目前正在等待其他排队的分片。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : false, &quot;current_state&quot; : &quot;unassigned&quot;, &quot;unassigned_info&quot; : { &quot;reason&quot; : &quot;NODE_LEFT&quot;, &quot;at&quot; : &quot;2017-01-04T18:53:59.498Z&quot;, &quot;details&quot; : &quot;node_left[G92ZwuuaRY-9n8_tc-IzEg]&quot;, &quot;last_allocation_status&quot; : &quot;no_attempt&quot; }, &quot;can_allocate&quot;: &quot;throttled&quot;, &quot;allocate_explanation&quot;: &quot;Elasticsearch is currently busy with other activities. It expects to be able to allocate this shard when those activities finish. Please wait.&quot;, &quot;node_allocation_decisions&quot; : [ { &quot;node_id&quot; : &quot;3sULLVJrRneSg0EfBB-2Ew&quot;, &quot;node_name&quot; : &quot;node_t0&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9400&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;node_decision&quot; : &quot;no&quot;, &quot;deciders&quot; : [ { &quot;decider&quot;: &quot;throttling&quot;, &quot;decision&quot;: &quot;THROTTLE&quot;, &quot;explanation&quot;: &quot;reached the limit of incoming shard recoveries [2], cluster setting [cluster.routing.allocation.node_concurrent_incoming_recoveries=2] (can also be set via [cluster.routing.allocation.node_concurrent_recoveries])&quot; } ] } ] }  这是一条瞬时消息，在分配大量分片时可能会出现。 ","version":"Next","tagName":"h3"},{"title":"已分配分区​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#已分配分区","content":"无法保留在当前节点上​ 以下响应包含对已分配分区的分配解释。该响应表明分区不允许保留在当前节点上，必须重新分配。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : true, &quot;current_state&quot; : &quot;started&quot;, &quot;current_node&quot; : { &quot;id&quot; : &quot;8lWJeJ7tSoui0bxrwuNhTA&quot;, &quot;name&quot; : &quot;node_t1&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9401&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;] }, &quot;can_remain_on_current_node&quot; : &quot;no&quot;, &quot;can_remain_decisions&quot; : [ { &quot;decider&quot; : &quot;filter&quot;, &quot;decision&quot; : &quot;NO&quot;, &quot;explanation&quot; : &quot;node does not match index setting [index.routing.allocation.include] filters [_name:\\&quot;nonexistent_node\\&quot;]&quot; } ], &quot;can_move_to_other_node&quot; : &quot;no&quot;, &quot;move_explanation&quot; : &quot;This shard may not remain on its current node, but Elasticsearch isn't allowed to move it to another node. Choose a node to which you expect this shard to be allocated, find this node in the node-by-node explanation, and address the reasons which prevent Elasticsearch from allocating this shard there.&quot;, &quot;node_allocation_decisions&quot; : [ { &quot;node_id&quot; : &quot;_P8olZS8Twax9u6ioN-GGA&quot;, &quot;node_name&quot; : &quot;node_t0&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9400&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;node_decision&quot; : &quot;no&quot;, &quot;weight_ranking&quot; : 1, &quot;deciders&quot; : [ { &quot;decider&quot; : &quot;filter&quot;, &quot;decision&quot; : &quot;NO&quot;, &quot;explanation&quot; : &quot;node does not match index setting [index.routing.allocation.include] filters [_name:\\&quot;nonexistent_node\\&quot;]&quot; } ] } ] }  &quot;can_remain_on_current_node&quot; : &quot;no&quot;：是否允许分片留在当前节点上。&quot;can_remain_decisions&quot;：决定不允许分块留在当前节点上的决定因素。&quot;can_move_to_other_node&quot; : &quot;no&quot;：是否允许将分片分配到其他节点。 必须保留在当前节点上​ 以下回复包含必须保留在当前节点上的分区的分配解释。将分区移动到其他节点不会改善集群平衡。 { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;shard&quot; : 0, &quot;primary&quot; : true, &quot;current_state&quot; : &quot;started&quot;, &quot;current_node&quot; : { &quot;id&quot; : &quot;wLzJm4N4RymDkBYxwWoJsg&quot;, &quot;name&quot; : &quot;node_t0&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9400&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;weight_ranking&quot; : 1 }, &quot;can_remain_on_current_node&quot; : &quot;yes&quot;, &quot;can_rebalance_cluster&quot; : &quot;yes&quot;, &quot;can_rebalance_to_other_node&quot; : &quot;no&quot;, &quot;rebalance_explanation&quot; : &quot;Elasticsearch cannot rebalance this shard to another node since there is no node to which allocation is permitted which would improve the cluster balance. If you expect this shard to be rebalanced to another node, find this node in the node-by-node explanation and address the reasons which prevent Elasticsearch from rebalancing this shard there.&quot;, &quot;node_allocation_decisions&quot; : [ { &quot;node_id&quot; : &quot;oE3EGFc8QN-Tdi5FFEprIA&quot;, &quot;node_name&quot; : &quot;node_t1&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9401&quot;, &quot;roles&quot; : [&quot;data_content&quot;, &quot;data_hot&quot;], &quot;node_decision&quot; : &quot;worse_balance&quot;, &quot;weight_ranking&quot; : 1 } ] }  &quot;can_rebalance_cluster&quot; : &quot;yes&quot;：是否允许在集群上重新平衡。&quot;can_rebalance_to_other_node&quot; : &quot;no&quot;：是否可以将分片重新平衡到另一个节点。&quot;node_decision&quot; : &quot;worse_balance&quot;：分块不能重新平衡到节点的原因，在这种情况下，表示它不能提供比当前节点更好的平衡。 ","version":"Next","tagName":"h3"},{"title":"无争论​","type":1,"pageTitle":"集群分配解释 API","url":"/docs/elasticsearch-cn/rest_apis/cluster_apis/cluster_allocation_explain#无争论","content":"如果不带参数调用 API，Elasticsearch 会检索任意未分配的主分区或副本分区的分配解释，并首先返回任何未分配的主分区。 GET _cluster/allocation/explain  原文链接 ","version":"Next","tagName":"h3"},{"title":"获取数据流的生命周期","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage 索引权限 或 manage_data_stream_lifecycle 索引权限或 view_index_metadata 索引权限。更多信息，参阅安全权限。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#请求","content":"GET _data_stream/&lt;data-stream&gt;/_lifecycle ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#描述","content":"获取指定数据流的生命周期。如果请求多个数据流，但其中至少有一个不存在，那么 API 将以 404 响应，因为至少有一个请求的资源无法检索。如果请求的数据流没有配置生命周期，它们仍将包含在 API 响应中，但 lifecycle 关键字将丢失。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#路径参数","content":"&lt;data-stream&gt; (必需，字符串) 用于限制请求的数据流的逗号分隔列表。支持通配符 (*)。要针对所有数据流，请使用 * 或 _all。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#查询参数","content":"expand_wildcards （可选，字符串）通配符模式可以匹配的数据流类型。支持逗号分隔值，例如 open,hidden。有效值为： all，hidden 匹配任何数据流或索引，包括隐藏的。 open，closed 匹配任何非隐藏的数据流。无法关闭 Data Streams。 none 不接受通配符模式。 默认为 open。 include_defaults (可选，布尔值） 如果为 true，则在响应中返回所有默认设置。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#响应体","content":"data_streams (对象数组）包含有关检索到的数据流生命周期的信息。 data_streams 对象属性 name (字符串） 数据流的名称。 lifecycle （可选，对象） lifecycle 属性 data_retention (可选，字符串） 如果已定义，则表示数据流所有者为该数据流要求的保留时间。 effective_retention (可选，字符串）如果定义，则添加到此数据流中的每个文档都将至少在此时间段内保存。在此期限之后的任何时间，文档都可能被删除。如果为空，该数据流中的每份文档都将无限期存储。为空时，该数据流中的每份文档都将无限期保存。有效保留时间的计算方法如教程所述。 retention_determined_by (可选，字符串） 保留的来源，可以是三种值之一：data_stream_configuration、default_retention 或 max_retention。 rollover (可选，对象）由集群设置 cluster.lifecycle.default.rollover 配置的触发后备索引翻转的条件。该属性是一个实现细节，只有当查询参数 include_defaults 设置为 true 时才能检索到。此字段的内容可能会更改。 global_retention (对象）包含全局最大保留和默认保留。如果未配置全局保留，则该对象为空。 global_retention 属性 max_retention (可选，字符串） 数据流生命周期管理的数据流的有效保留时间不能超过此值。 default_retention (可选，字符串） 这将是数据流生命周期管理的、未指定 data_retention 的数据流的有效保留时间。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取数据流的生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle#示例","content":"让我们检索生命周期： GET _data_stream/my-data-stream*/_lifecycle  响应如下： { &quot;data_streams&quot;: [ { &quot;name&quot;: &quot;my-data-stream-1&quot;, &quot;lifecycle&quot;: { &quot;enabled&quot;: true, &quot;data_retention&quot;: &quot;7d&quot;, &quot;effective_retention&quot;: &quot;7d&quot;, &quot;retention_determined_by&quot;: &quot;data_stream_configuration&quot; } }, { &quot;name&quot;: &quot;my-data-stream-2&quot;, &quot;lifecycle&quot;: { &quot;enabled&quot;: true, &quot;data_retention&quot;: &quot;7d&quot;, &quot;effective_retention&quot;: &quot;7d&quot;, &quot;retention_determined_by&quot;: &quot;data_stream_configuration&quot; } } ], &quot;global_retention&quot;: {} }  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取数据流生命周期统计信息","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle_state","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"获取数据流生命周期统计信息","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle_state#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 monitor 或 manage 集群权限来使用此 API。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"获取数据流生命周期统计信息","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle_state#请求","content":"GET _lifecycle/stats ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"获取数据流生命周期统计信息","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle_state#描述","content":"获取有关数据流生命周期执行情况的统计信息。数据流级别的统计信息只包括数据流生命周期管理的数据流的统计信息。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"获取数据流生命周期统计信息","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle_state#响应体","content":"last_run_duration_in_millis (可选，长整数）最后一次执行数据流生命周期的持续时间。 time_between_starts_in_millis (可选，长整数）最后两次数据流生命周期执行开始之间的时间间隔。该值应近似于 data_streams.lifecycle.poll_interval。 data_stream_count (整数） 当前由数据流生命周期管理的数据流的计数。 data_streams (对象数组）包含检索到的数据流生命周期的相关信息。 data_streams 中的对象属性 name (字符串） 数据流的名称。 backing_indices_in_total (整数）由数据流生命周期管理的该数据流后备索引的计数。 backing_indices_in_error (整数）由数据流生命周期管理并已遇到错误的数据流后备索引的计数。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取数据流生命周期统计信息","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream_lifecycle_state#示例","content":"让我们检索已执行过一次以上生命周期的群集的数据流生命周期统计信息： GET _lifecycle/stats?human&amp;pretty  回复内容如下 { &quot;last_run_duration_in_millis&quot;: 2, &quot;last_run_duration&quot;: &quot;2ms&quot;, &quot;time_between_starts_in_millis&quot;: 9998, &quot;time_between_starts&quot;: &quot;9.99s&quot;, &quot;data_streams_count&quot;: 2, &quot;data_streams&quot;: [ { &quot;name&quot;: &quot;my-data-stream&quot;, &quot;backing_indices_in_total&quot;: 2, &quot;backing_indices_in_error&quot;: 0 }, { &quot;name&quot;: &quot;my-other-stream&quot;, &quot;backing_indices_in_total&quot;: 2, &quot;backing_indices_in_error&quot;: 1 } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取数据流 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream#请求","content":"GET /_data_stream/&lt;data-stream&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 view_index_metadata 或 manage 的索引权限： ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream#路径参数","content":"&lt;data-stream&gt; (可选，字符串） 用逗号分隔的数据流名称列表，用于限制请求。支持通配符 (*) 表达式。如果省略，将返回所有数据流。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream#查询参数","content":"expand_wildcards （可选，字符串）通配符模式可以匹配的数据流类型。支持逗号分隔值，例如 open,hidden。有效值为： all，hidden 匹配任何数据流或索引，包括隐藏的。 open，closed 匹配任何非隐藏的数据流。无法关闭 Data Streams。 none 不接受通配符模式。 默认为 open。 include_defaults (可选，布尔值） [预览] 中的功能。如果为 true，则在响应中返回所有默认设置。默认为 false。 verbose (可选，布尔值）。如果为 true，则返回与数据流中文档的 @timestamp 字段相对应的 maximum_timestamp。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"获取数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream#响应体","content":"data_streams data_streams 中对象的属性 name (字符串） 数据流的名称。 timestamp_field (对象）包含数据流 @timestamp 字段的相关信息。 timestamp_field 属性 name (字符串）数据流时间戳字段的名称，必须是 @timestamp。@timestamp 字段必须包含在数据流索引的每个文档中。 indices (对象数组）包含数据流备份索引信息的对象数组。 数组中的最后一项包含数据流的当前写索引信息。 indices 对象属性 index_name (字符串） 备份索引的名称。有关命名规则，参阅生成。 index_uuid (字符串）索引的通用唯一标识符（UUID）。 prefer_ilm (布尔）[预览]中的功能。表示当索引生命周期管理和数据流生命周期都配置为管理此索引时，此索引是否配置为首选索引生命周期管理。 managed_by (字符串）[预览]中的功能。表示管理此索引的系统。 generation (整数）数据流的生成生成数。这个数字是数据流翻转的累积计数，从 1 开始。 _meta (对象）流的自定义元数据，从流的匹配索引模板的 _meta 对象中复制。如果为空，响应将省略此属性。 status (字符串） 数据流的健康状态。 该健康状态基于数据流备份索引的主分片和副本分片的状态。 status 的值 GREEN 所有分片都已分配。 YELLOW 所有主分片都已分配，但一个或多个副本分区未分配。 RED 一个或多个主分片未分配，因此某些数据不可用。 template (字符串)用于创建数据流后备索引的索引模板名称。 该模板的索引模式必须与该数据流的名称相匹配。参阅创建索引模板。 ilm_policy (字符串)流的匹配索引模板中当前 ILM 生命周期策略的名称。此生命周期策略在 index.lifecycle.name 设置中设置。 如果模板不包含生命周期策略，则响应中不包含此属性。 提示 数据流的后备索引可以分配不同的生命周期策略。要检索单个后备索引的生命周期策略，请使用获取索引设置 API。 next_generation_managed_by (字符串）[预览]中的功能。表示将管理下一代索引（即下一个数据流写入索引）的系统。 prefer_ilm (布尔）[预览]中的功能。表示当索引生命周期管理和数据流生命周期都配置为管理此索引时，用于创建数据流后备索引的索引模板是否配置为首选索引生命周期管理。 hidden (布尔值） 如果为 true，则隐藏数据流。 system (布尔值）如果为 true，则数据流由弹性堆栈组件创建和管理，不能通过正常的用户交互进行修改。 allow_custom_routing (布尔值）如果为 true，则该数据流允许在写入请求时自定义路由。 replicated (布尔值）如果为 true，则数据流由跨群集复制创建和管理，本地群集不能写入该数据流或更改其映射。 lifecycle (对象）[预览]中的功能。包含此数据流的数据流生命周期管理配置。 lifecycle 对象的属性 data_retention (字符串）如果定义，则添加到此数据流中的每个文档都将至少在此时间段内保存。在此期限之后的任何时间，文档都可能被删除。如果为空，则该数据流中的每份文档都将无限期存储。 rollover (对象）由群集设置 cluster.lifecycle.default.rollover 配置的触发后备索引翻转的条件。该属性是一个实现细节，只有当查询参数 include_defaults 设置为 true 时才能检索到。此字段的内容可能会更改。 rollover_on_write (布尔值）如果为 true，下一次写入该数据流时将首先触发一次翻转，然后在新的后备索引中对文档进行索引。如果翻转失败，索引请求也将失败。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/get_data_stream#示例","content":"GET _data_stream/my-data-stream*  API 返回以下响应： { &quot;data_streams&quot;: [ { &quot;name&quot;: &quot;my-data-stream&quot;, &quot;timestamp_field&quot;: { &quot;name&quot;: &quot;@timestamp&quot; }, &quot;indices&quot;: [ { &quot;index_name&quot;: &quot;.ds-my-data-stream-2099.03.07-000001&quot;, &quot;index_uuid&quot;: &quot;xCEhwsp8Tey0-FLNFYVwSg&quot;, &quot;prefer_ilm&quot;: true, &quot;ilm_policy&quot;: &quot;my-lifecycle-policy&quot;, &quot;managed_by&quot;: &quot;Index Lifecycle Management&quot; }, { &quot;index_name&quot;: &quot;.ds-my-data-stream-2099.03.08-000002&quot;, &quot;index_uuid&quot;: &quot;PA_JquKGSiKcAKBA8DJ5gw&quot;, &quot;prefer_ilm&quot;: true, &quot;ilm_policy&quot;: &quot;my-lifecycle-policy&quot;, &quot;managed_by&quot;: &quot;Index Lifecycle Management&quot; } ], &quot;generation&quot;: 2, &quot;_meta&quot;: { &quot;my-meta-field&quot;: &quot;foo&quot; }, &quot;status&quot;: &quot;GREEN&quot;, &quot;next_generation_managed_by&quot;: &quot;Index Lifecycle Management&quot;, &quot;prefer_ilm&quot;: true, &quot;template&quot;: &quot;my-index-template&quot;, &quot;ilm_policy&quot;: &quot;my-lifecycle-policy&quot;, &quot;hidden&quot;: false, &quot;system&quot;: false, &quot;allow_custom_routing&quot;: false, &quot;replicated&quot;: false, &quot;rollover_on_write&quot;: false }, { &quot;name&quot;: &quot;my-data-stream-two&quot;, &quot;timestamp_field&quot;: { &quot;name&quot;: &quot;@timestamp&quot; }, &quot;indices&quot;: [ { &quot;index_name&quot;: &quot;.ds-my-data-stream-two-2099.03.08-000001&quot;, &quot;index_uuid&quot;: &quot;3liBu2SYS5axasRt6fUIpA&quot;, &quot;prefer_ilm&quot;: true, &quot;ilm_policy&quot;: &quot;my-lifecycle-policy&quot;, &quot;managed_by&quot;: &quot;Index Lifecycle Management&quot; } ], &quot;generation&quot;: 1, &quot;_meta&quot;: { &quot;my-meta-field&quot;: &quot;foo&quot; }, &quot;status&quot;: &quot;YELLOW&quot;, &quot;next_generation_managed_by&quot;: &quot;Index Lifecycle Management&quot;, &quot;prefer_ilm&quot;: true, &quot;template&quot;: &quot;my-index-template&quot;, &quot;ilm_policy&quot;: &quot;my-lifecycle-policy&quot;, &quot;hidden&quot;: false, &quot;system&quot;: false, &quot;allow_custom_routing&quot;: false, &quot;replicated&quot;: false, &quot;rollover_on_write&quot;: false } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"修改数据流 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/modify_data_stream","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"修改数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/modify_data_stream#请求","content":"POST /_data_stream/_modify ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"修改数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/modify_data_stream#请求体","content":"actions (必填，对象数组）要执行的操作。 actions 对象属性 &lt;action&gt; (必填，对象）键是操作类型。至少需要一个操作。 有效的 &lt;action&gt; 键 add_backing_index 添加现有索引作为数据流的后备索引。作为该操作的一部分，索引将被隐藏。 警告 使用 add_backing_index 操作添加索引可能会导致不当的数据流行为。这应该被视为专家级 API。 remove_backing_index 从数据流中删除一个后备索引。作为该操作的一部分，索引将被取消隐藏。不能删除数据流的写索引。 &lt;action&gt; 属性（对象主体包含的操作选项） data_stream (必需*，字符串） 操作所针对的数据流。 index (必需*，字符串）操作索引。 原文链接 ","version":"Next","tagName":"h2"},{"title":"迁移数据流 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/migrate_to_data_stream","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"迁移数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/migrate_to_data_stream#请求","content":"POST /_data_stream/_migrate/&lt;alias&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"迁移数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/migrate_to_data_stream#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage 的索引权限。已启用数据流的匹配索引模板。参阅设置数据流。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"迁移数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/migrate_to_data_stream#路径参数","content":"&lt;alias&gt; (必需，字符串）要转换为数据流的索引别名的名称。别名必须符合以下条件： 别名必须有一个写索引。 别名的所有索引都有一个 date 或 date_nanos 字段类型的 @timestamp 字段映射。 别名必须没有任何过滤器。 别名不得使用自定义路由。 如果请求成功，则会删除别名并创建同名数据流。别名的索引将成为数据流的隐藏备份索引。别名的写索引将成为数据流的写索引。 原文链接 ","version":"Next","tagName":"h2"},{"title":"文档 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"单文档 API​","type":1,"pageTitle":"文档 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/#单文档-api","content":"索引获取删除更新 ","version":"Next","tagName":"h2"},{"title":"多文档 API​","type":1,"pageTitle":"文档 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/#多文档-api","content":"多重获取批量按查询删除按查询更新重索引 原文链接 ","version":"Next","tagName":"h2"},{"title":"推广数据流 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/promote_data_stream","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"推广数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/promote_data_stream#请求","content":"POST /_data_stream/_promote/&lt;data-stream&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"推广数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/promote_data_stream#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage_follow_index 的集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"推广数据流 API","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/promote_data_stream#路径参数","content":"&lt;data-stream&gt; (必填，字符串） 要推广的数据流名称。 原文链接 ","version":"Next","tagName":"h2"},{"title":"删除 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#请求","content":"DELETE /&lt;index&gt;/_doc/&lt;_id&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有目标索引或索引别名的 delete 或 write 索引权限。 ","version":"Next","tagName":"h2"},{"title":"说明​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#说明","content":"你可以用 DELETE 从索引中删除文档。您必须指定索引名称和文档 ID。 注意 不能直接向数据流发送删除请求。要删除数据流中的文档，必须以包含该文档的备用索引为目标。参阅更新或删除备用索引中的文档。 ","version":"Next","tagName":"h2"},{"title":"乐观并发控制​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#乐观并发控制","content":"删除操作可以是有条件的，只有在文档的最后一次修改被分配给 if_seq_no 和 if_primary_term 参数指定的序列号和主要术语时才会执行。如果检测到不匹配，操作将导致 VersionConflictException 和状态代码 409。有关详细信息，参阅乐观并发控制。 ","version":"Next","tagName":"h3"},{"title":"版本控制​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#版本控制","content":"索引中的每个文档都有版本。删除文档时，可以指定版本，以确保我们要删除的相关文档确实正在被删除，而且在此期间没有发生变化。对文档执行的每次写操作（包括删除）都会导致其版本递增。删除文档后，其版本号会在短时间内保持可用，以便对并发操作进行控制。已删除文档的版本保持可用的时间长度由 index.gc_deletes 索引设置决定，默认为 60 秒。 ","version":"Next","tagName":"h3"},{"title":"路由​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#路由","content":"如果在编制索引时使用了路由，那么删除文档时也需要指定路由值。 如果 _routing 映射设置为 required 且未指定路由值，删除 API 将抛出 RoutingMissingException 并拒绝请求。 示例： DELETE /my-index-000001/_doc/1?routing=shard-1  该请求会删除 id 为 1 的文档，但会根据用户进行路由。如果未指定正确的路由，则不会删除文档。 ","version":"Next","tagName":"h3"},{"title":"自动创建索引​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#自动创建索引","content":"如果使用了外部版本控制变量，删除操作会自动创建指定的索引（如果该索引不存在）。有关手动创建索引的信息，参阅创建索引 API。 ","version":"Next","tagName":"h3"},{"title":"分布式​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#分布式","content":"删除操作会被散列到一个特定的分片 id 中。然后，它会被重定向到该 id 组中的主分区，并复制（如需要）到该 id 组中的分区副本。 ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#等待活动分片","content":"在提出删除请求时，可以设置 wait_for_active_shards 参数，要求在开始处理删除请求之前，至少有多少分片副本处于活动状态。详情和使用示例参阅此处。 ","version":"Next","tagName":"h3"},{"title":"刷新​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#刷新","content":"控制搜索何时可以看到该请求所做的更改。参阅刷新。 ","version":"Next","tagName":"h3"},{"title":"超时​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#超时","content":"当执行删除操作时，指定执行删除操作的主分区可能不可用。造成这种情况的原因可能是主分区目前正在从存储中恢复或正在进行搬迁。默认情况下，删除操作最多会等待主分区可用 1 分钟，然后才会失败并响应错误。timeout 参数可用于明确指定等待时间。下面是一个将其设置为 5 分钟的示例： DELETE /my-index-000001/_doc/1?timeout=5m  ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#路径参数","content":"&lt;index&gt;（必需，字符串）目标索引的名称。&lt;_id&gt;（必需，字符串）文档的唯一标识符。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#查询参数","content":"if_seq_no(可选，整数） 只有当文档具有此序列号时才执行操作。参阅乐观并发控制。 if_primary_term(可选，整数） 只有当文档具有此序列号时才执行操作。参阅乐观并发控制。 refresh(可选，枚举）如果为 true，Elasticsearch 会刷新受影响的分片，使该操作在搜索中可见；如果为 wait_for，则等待刷新，使该操作在搜索中可见；如果为 false，则不刷新。有效值：true、false、wait_for。默认值：false。 routing(可选，字符串） 用于将操作路由到特定分区的自定义值。 timeout(可选，时间单位）等待活动分片的时间。默认为 1m（一分钟）。 version(可选，整数）用于并发控制的明确版本号。指定的版本必须与文档的当前版本一致，请求才能成功。 version_type(可选，枚举） 特定版本类型：external、external_gte。 wait_for_active_shards(可选，字符串） 进行操作前必须激活的分片副本数量。设置为全部或任何正整数，最多不超过索引中的分片总数（number_of_replicas+1）。默认值：1，主分区。 参阅活动分片 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete#示例","content":"从 my-index-000001 索引中删除 JSON 文档 1： DELETE /my-index-000001/_doc/1  API 返回以下结果： { &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;failed&quot;: 0, &quot;successful&quot;: 2 }, &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 2, &quot;_primary_term&quot;: 1, &quot;_seq_no&quot;: 5, &quot;result&quot;: &quot;deleted&quot; }  原文链接 ","version":"Next","tagName":"h2"},{"title":"设置数据流生命周期","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_data_stream_lifecycle 或更高的索引权限。更多信息，参阅安全权限。 ","version":"Next","tagName":"h2"},{"title":"请求​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#请求","content":"PUT _data_stream/&lt;data-stream&gt;/_lifecycle ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#描述","content":"为目标数据流配置数据流生命周期。如果提供了多个数据流，但其中有一个以上不存在，那么生命周期的更新将对所有数据流都失败，API 将响应 404。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#路径参数","content":"&lt;data-stream&gt; (必需，字符串) 用于限制请求的数据流的逗号分隔列表。支持通配符 (*)。要针对所有数据流，请使用 * 或 _all。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#查询参数","content":"expand_wildcards （可选，字符串）通配符模式可以匹配的数据流类型。支持逗号分隔值，例如 open,hidden。有效值为： all，hidden 匹配任何数据流或索引，包括隐藏的。 open，closed 匹配任何非隐藏的数据流。无法关闭 Data Streams。 none 不接受通配符模式。 默认为 open。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#请求体","content":"lifecycle （必需，对象） lifecycle 的属性 data_retention (可选，字符串）如果定义，则添加到此数据流中的每个文档都将至少在此时间段内保存。在此期限之后的任何时间，文档都可能被删除。如果为空，则该数据流中的每份文档都将无限期存储。 enabled (可选，布尔值）如果定义，则打开/关闭（true/false）该数据流的数据流生命周期。禁用（enabled: false）的数据流生命周期对数据流没有任何影响。默认为 true。 downsampling (可选，数组）一个可选的下采样配置对象数组，每个对象都定义了一个后间隔（after）和一个固定间隔（fixed_interval），后间隔代表何时要对后备索引进行下采样（时间范围从索引滚动开始计算，即生成时间），fixed_interval 代表下采样间隔（fixed_interval 最小值为 5m）。最多可配置 10 轮向下采样。参阅下面的配置示例。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"设置数据流生命周期","url":"/docs/elasticsearch-cn/rest_apis/data_stream_apis/put_data_stream_lifecycle#示例","content":"下面的示例设置了 my-data-stream 的生命周期： PUT _data_stream/my-data-stream/_lifecycle { &quot;data_retention&quot;: &quot;7d&quot; }  当生命周期在所有数据流中更新成功后，你会收到以下结果： { &quot;acknowledged&quot;: true }  下面的示例配置了两轮下采样，第一轮在后备索引滚动一天后开始（或更晚，如果索引仍在其写入接受时间范围内），间隔为 10m，第二轮在滚动 7 天后开始，间隔为 1d： PUT _data_stream/my-weather-sensor-data-stream/_lifecycle { &quot;downsampling&quot;: [ { &quot;after&quot;: &quot;1d&quot;, &quot;fixed_interval&quot;: &quot;10m&quot; }, { &quot;after&quot;: &quot;7d&quot;, &quot;fixed_interval&quot;: &quot;1d&quot; } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#请求","content":"GET &lt;index&gt;/_doc/&lt;_id&gt; HEAD &lt;index&gt;/_doc/&lt;_id&gt; GET &lt;index&gt;/_source/&lt;_id&gt; HEAD &lt;index&gt;/_source/&lt;_id&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#前置条件","content":"开启 Elasticsearch 安全功能后，您必须拥有目标索引或索引别名的 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#描述","content":"使用 GET 可从特定索引中检索文档及其源字段或存储字段。使用 HEAD 可验证文档是否存在。您可以使用 _source 资源检索文档源或验证其是否存在。 ","version":"Next","tagName":"h2"},{"title":"实时​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#实时","content":"编辑 默认情况下，get API 是实时的，不受索引刷新率的影响（数据何时可见以供搜索）。如果请求的是存储字段（参见 stored_fields 参数），且文档已更新但尚未刷新，则 get API 必须解析和分析源以提取存储字段。要禁用实时 GET，可将 realtime 参数设置为 false。 ","version":"Next","tagName":"h3"},{"title":"源过滤​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#源过滤","content":"默认情况下，除非使用了 stored_fields 参数或禁用了 _source 字段，否则 get 操作将返回 _source 字段的内容。您可以使用 _source 参数关闭 _source 检索： GET my-index-000001/_doc/0?_source=false  如果只需要 _source 中的一个或两个字段，可以使用 _source_includes 或 _source_excludes 参数来包含或过滤掉特定字段。这对大型文档尤其有用，因为部分检索可以节省网络开销。这两个参数都使用逗号分隔的字段列表或通配符表达式。例如： GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities  如果只想指定包含内容，可以使用更短的符号： GET my-index-000001/_doc/0?_source=*.id  ","version":"Next","tagName":"h3"},{"title":"路由（Routing）​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#路由routing","content":"如果在索引编制过程中使用了路由，则在检索文档时也需要指定路由值。例如： GET my-index-000001/_doc/2?routing=user1  该请求获取 id 为 2 的文档，但其路由基于用户。如果未指定正确的路由，则不会获取文档。 ","version":"Next","tagName":"h3"},{"title":"偏好（Preference）​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#偏好preference","content":"控制在哪个分片副本上执行获取请求的偏好。默认情况下，操作会在分片副本之间随机进行。 preference 可设置为： _local如果可能，操作将优先在本地分配的分块上执行。 ","version":"Next","tagName":"h3"},{"title":"自定义（字符串）值​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#自定义字符串值","content":"自定义值将用于保证相同的分区将用于相同的自定义值。这有助于解决在不同刷新状态下访问不同分区时出现的“跳值”问题。示例值可以是网络会话 ID 或用户名。 ","version":"Next","tagName":"h3"},{"title":"刷新（Refreshe）​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#刷新refreshe","content":"可以将 refresh 参数设置为 true，以便在获取操作之前刷新相关分片，使其可以被搜索。将该参数设置为 true 之前，应仔细考虑并验证这样做不会给系统带来沉重负担（降低索引速度）。 ","version":"Next","tagName":"h3"},{"title":"分布式​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#分布式","content":"获取操作会被散列到一个特定的分片 ID 中。然后，它会被重定向到该分区 id 中的一个副本，并返回结果。副本是指主分区及其在该分区 ID 组内的副本。这意味着，我们拥有的副本越多，GET 扩展性就越好。 ","version":"Next","tagName":"h3"},{"title":"版本支持​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#版本支持","content":"只有当文档的当前版本等于指定版本时，才能使用 version 参数检索文档。 在内部，Elasticsearch 已将旧文档标记为已删除，并添加了一个全新的文档。旧版本的文档不会立即消失，不过你将无法访问它。当你继续索引更多数据时，Elasticsearch 会在后台清理已删除的文档。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#路径参数","content":"&lt;index&gt;(必填，字符串）包含文档的索引的名称。&lt;_id&gt;(必填，字符串）文档的唯一标识符。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#查询参数","content":"preference(可选，字符串） 指定应在哪个节点或分片上执行操作。默认为随机。 realtime(可选，布尔） 如果为 true，则表示请求是实时的，而不是近实时的。默认为 true。参阅实时。 refresh(可选，布尔） 如果为 true，请求会在检索文档前刷新相关分区。默认为 false。 routing(可选，字符串） 用于将操作路由到特定分区的自定义值。 stored_fields(可选，布尔） 如果为 true，则检索存储在索引中的文档字段，而不是文档 _source。默认为 false。 _source(可选，字符串）返回 _source 字段与否的真或假，或者要返回的字段列表。 _source_excludes(可选，字符串）以逗号分隔的源字段列表，用于从响应中排除。 也可以使用该参数从 _source_includes 查询参数指定的子集中排除字段。 如果 _source 参数为 false，该参数将被忽略。 _source_includes(可选，字符串）以逗号分隔的源字段列表，包含在响应中。 如果指定了该参数，则只返回这些源字段。你可以使用 _source_excludes 查询参数从该子集中排除字段。 如果 _source 参数为 false，该参数将被忽略。 version(可选，整数）用于并发控制的明确版本号。指定的版本必须与文档的当前版本一致，请求才能成功。 version_type(可选，枚举） 特定版本类型：external、external_gte。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#响应体","content":"_index文档所属索引的名称。_id文档的唯一标识符。_version文档版本。文档每次更新时都会递增。_seq_no为索引操作分配给文档的序列号。序列号用于确保文档的旧版本不会覆盖新版本。参阅乐观并发控制。_primary_term为索引操作分配给文档的主要术语。参阅乐观并发控制。found表示文档是否存在：true 或 false。_routing显式路由（如果已设置）。_source如果 found 为 true，则包含 JSON 格式的文档数据。如果 _source 参数设置为 false 或 stored_fields 参数设置为 true，则排除在外。_fields如果 stored_fields 参数设置为 true 且 found 为 true，则包含存储在索引中的文档字段。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#示例","content":"从 my-index-000001 索引中读取 _id 为 0 的 JSON 文档： GET my-index-000001/_doc/0  API 返回以下结果： { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;0&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: { &quot;@timestamp&quot;: &quot;2099-11-15T14:12:12&quot;, &quot;http&quot;: { &quot;request&quot;: { &quot;method&quot;: &quot;get&quot; }, &quot;response&quot;: { &quot;status_code&quot;: 200, &quot;bytes&quot;: 1070000 }, &quot;version&quot;: &quot;1.1&quot; }, &quot;source&quot;: { &quot;ip&quot;: &quot;127.0.0.1&quot; }, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } } }  检查是否存在 _id 为 0 的文档： HEAD my-index-000001/_doc/0  如果文档存在，Elasticsearch 返回状态代码 200 - OK；如果不存在，则返回 404 - Not Found。 ","version":"Next","tagName":"h2"},{"title":"仅获取源字段​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#仅获取源字段","content":"使用 &lt;index&gt;/_source/&lt;id&gt; 资源只获取文档的 _source 字段。例如： GET my-index-000001/_source/1  您可以使用源过滤参数来控制 _source 的哪些部分会被返回： GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities  您可以使用 HEAD 和 _source 端点来有效地测试文档 _source 是否存在。如果在映射中禁用了文档源，则文档源不可用。 HEAD my-index-000001/_source/1  ","version":"Next","tagName":"h3"},{"title":"获取存储字段​","type":1,"pageTitle":"获取 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/get#获取存储字段","content":"使用 stored_fields 参数指定要检索的存储字段集。任何未存储的请求字段都将被忽略。例如，请考虑以下映射： PUT my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;counter&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;store&quot;: false }, &quot;tags&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;store&quot;: true } } } }  现在我们可以添加一个文件： PUT my-index-000001/_doc/1 { &quot;counter&quot;: 1, &quot;tags&quot;: [ &quot;production&quot; ] }  然后再试着找回它： GET my-index-000001/_doc/1?stored_fields=tags,counter  API 返回以下结果： { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot; : 22, &quot;_primary_term&quot; : 1, &quot;found&quot;: true, &quot;fields&quot;: { &quot;tags&quot;: [ &quot;production&quot; ] } }  从文档本身获取的字段值总是以数组形式返回。由于 counter 字段没有存储，因此获取请求会忽略它。 您还可以检索 _routing 字段等元数据字段： PUT my-index-000001/_doc/2?routing=user1 { &quot;counter&quot; : 1, &quot;tags&quot; : [&quot;env2&quot;] }  GET my-index-000001/_doc/2?routing=user1&amp;stored_fields=tags,counter  API 返回以下结果： { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot; : 13, &quot;_primary_term&quot; : 1, &quot;_routing&quot;: &quot;user1&quot;, &quot;found&quot;: true, &quot;fields&quot;: { &quot;tags&quot;: [ &quot;env2&quot; ] } }  使用 stored_field 选项只能检索叶字段。如果指定了对象字段，则请求失败。 原文链接 ","version":"Next","tagName":"h3"},{"title":"按查询删除 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#请求","content":"POST /&lt;target&gt;/_delete_by_query ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须对目标数据流、索引或别名拥有以下索引权限： readdelete 或 write ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#描述","content":"您可以使用与搜索 API 相同的语法，在请求 URI 或请求正文中指定查询条件。 提交查询删除请求时，Elasticsearch 会在开始处理请求时获取数据流或索引的快照，并使用 internal 版本控制删除匹配的文档。如果文档在快照获取和删除操作处理之间发生变化，则会导致版本冲突，删除操作会失败。 注意 版本等于 0 的文档不能使用查询删除，因为内部版本管理不支持将 0 作为有效的版本号。 在处理查询删除请求时，Elasticsearch 会按顺序执行多个搜索请求，以找到要删除的所有匹配文档。每批匹配文档都会执行一次批量删除请求。如果搜索或批量请求被拒绝，请求最多会重试 10 次，重试次数以指数形式递减。如果达到最大重试限制，处理就会停止，所有失败的请求都会在响应中返回。任何已成功完成的删除请求仍会保留，不会回滚。 你可以选择计算版本冲突，而不是通过将 conflicts 设置为 proceed 来停止和返回。请注意，如果您选择计算版本冲突，操作可能会尝试从源中删除比 max_docs 更多的文档，直到成功删除 max_docs 文档，或完成源查询中的所有文档。 ","version":"Next","tagName":"h2"},{"title":"刷新分片​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#刷新分片","content":"一旦请求完成，指定 refresh 参数就会刷新所有参与查询删除的分片。这与删除 API 的刷新参数不同，后者只会刷新接收到删除请求的分片。与删除 API 不同，它不支持 wait_for。 ","version":"Next","tagName":"h3"},{"title":"异步运行按查询删除​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#异步运行按查询删除","content":"如果请求中包含 wait_for_completion=false，Elasticsearch 会执行一些预检，启动请求，并返回一个 task，你可以用它来取消或获取任务的状态。Elasticsearch 会在 .tasks/task/${taskId} 文件中创建该任务的记录。完成任务后，应删除任务文档，以便 Elasticsearch 可以回收空间。 ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#等待活动分片","content":"wait_for_active_shards 控制在继续处理请求之前，分片必须有多少副本处于活动状态。参阅活动分片。timeout 控制每个写入请求等待不可用分区变为可用的时间。两者的工作方式与批量 API 中的工作方式完全相同。按查询删除使用滚动搜索，因此也可以指定 scroll 参数来控制搜索上下文的有效时间，例如：?scroll=10m。默认值为 5 分钟。 ","version":"Next","tagName":"h3"},{"title":"限制删除请求​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#限制删除请求","content":"要控制通过查询删除成批删除操作的速度，可以将 requests_per_second 设置为任意正数小数。这将为每个批次添加等待时间，以节流速度。如果将 requests_per_second 设置为 -1，则禁用节流。 节流会在批次之间使用等待时间，这样内部滚动请求的超时时间就会考虑到请求填充时间。填充时间是批次大小除以每秒请求数与写入时间之差。默认情况下，批次大小为 1000，因此如果将 requests_per_second 设置为 500，则批次大小为 1000： target_time = 1000 / 500 per second = 2 seconds wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds  由于批处理是作为单个 _bulk 请求发出的，因此大容量批处理会导致 Elasticsearch 创建许多请求，并在开始下一组请求之前等待。这就是“突发（bursty）”，而不是“平稳（smooth）”。 ","version":"Next","tagName":"h3"},{"title":"切片​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#切片","content":"通过查询删除支持切片滚动以并行化删除过程。这可以提高效率，并为将请求分解成更小的部分提供方便。 将 slices 设置为 auto，可为大多数数据流和索引选择合理的数量。如果要手动切片或以其他方式调整自动切片，请记住以下几点： 当 slices 数等于索引或后备索引中的分片数时，查询性能最为高效。如果这个数字很大（例如 500），请选择一个较小的数字，因为过多的 slices 会降低性能。设置高于分片数量的 slices 通常不会提高效率，反而会增加开销。删除性能与可用资源的分片数呈线性关系。 在运行时间内，查询还是删除性能占主导地位取决于重新索引的文档和集群资源。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#路径参数","content":"&lt;target&gt;(可选，字符串） 用逗号分隔的要搜索的数据流、索引和别名列表。支持通配符 (*)。要搜索所有数据流或索引，请省略此参数或使用 * 或 _all。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#查询参数","content":"allow_no_indices(可选，布尔值）如果为 false，则如果任何通配符表达式、索引别名或 _all 值仅针对丢失或关闭的索引，请求将返回错误。即使请求以其他开放索引为目标，该行为也适用。例如，如果某个索引以 foo 开头，但没有以 bar 开头的索引，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 analyzer(可选，字符串） 用于查询字符串的分析器。 该参数只能在指定 q 查询字符串参数时使用。 analyze_wildcard(可选，布尔） 如果为 true，则分析通配符和前缀查询。默认为 false。 该参数只能在指定 q 查询字符串参数时使用。 conflicts(可选，字符串） 如果通过查询删除遇到版本冲突，将如何处理：终止或继续。默认为终止。 default_operator(可选，字符串）查询字符串的默认运算符：AND 或 OR。默认为 OR。 该参数只能在指定 q 查询字符串参数时使用。 df(可选，字符串）查询字符串中未给出字段前缀时作为默认字段使用的字段。 该参数只能在指定 q 查询字符串参数时使用。 expand_wildcards(可选，字符串） 通配符模式可匹配的索引类型。如果请求以数据流为目标，该参数将决定通配符表达式是否匹配隐藏的数据流。支持逗号分隔值，如 open,hidden。有效值为 all匹配任何数据流或索引，包括隐藏的。 open匹配打开的非隐藏索引。也可匹配任何非隐藏数据流。 closed匹配封闭的非隐藏索引。也匹配任何非隐藏数据流。数据流不能关闭。 hidden匹配隐藏数据流和隐藏索引。必须与打开、关闭或两者结合使用。 none不接受通配符模式。 默认为 open。 ignore_unavailable(可选，布尔）如果为 false，则如果请求的目标索引丢失或关闭，则返回错误。默认为 false。 lenient(可选，布尔）如果为 &quot;true&quot;，查询字符串中基于格式的查询失败（例如为数字字段提供文本）将被忽略。默认为 false。 该参数只能在指定 q 查询字符串参数时使用。 max_docs(可选，整数）要处理的最大文件数。默认为所有文档。当设置的值小于或等于 scroll_size 时，将不会使用滚动来检索操作结果。 preference(可选，字符串） 指定应在哪个节点或分片上执行操作。默认为随机。 q(可选，字符串） Lucene 查询字符串语法中的查询。 request_cache(可选，布尔） 如果为 &quot;true&quot;，则该请求将使用请求缓存。默认为索引级设置。 refresh(可选，布尔）如果为 true，Elasticsearch 会在请求完成后刷新查询中涉及删除的所有分片。默认为 false。 requests_per_second(可选，整数）该请求的节流阀，单位为每秒子请求数。默认为 -1（无节流）。 routing(可选，字符串） 用于将操作路由到特定分区的自定义值。 scroll(可选，时间单位）在滚动时保留搜索上下文的时间段。参阅滚动搜索结果。 scroll_size(可选，整数）支持操作的滚动请求大小。默认为 1000。 search_type(可选，字符串） 搜索操作的类型。可用选项： query_then_fetchdfs_query_then_fetch search_timeout(可选，时间单位）每次搜索请求的明确超时。默认为无超时。 slices(可选，整数）该任务应划分的子任务数。默认为 1，表示任务不被分割成子任务。 sort(可选，字符串）以逗号分隔的 &lt;field&gt;:&lt;direction&gt; 对列表。 stats(可选，字符串）请求的特定 tag，用于记录和统计。 terminate_after(可选，整数）每个分片要收集的最大文档数。如果查询达到此限制，Elasticsearch 会提前终止查询。Elasticsearch 会在排序前收集文档。 重要 谨慎使用。Elasticsearch 会将此参数应用于处理请求的每个分片。在可能的情况下，让 Elasticsearch 自动执行提前终止。如果请求的目标数据流带有跨多个数据层的备份索引，则应避免指定此参数。 timeout(可选，时间单位） 每个删除请求等待活动分片的时间。默认为 1m（一分钟）。 version(可选，布尔值） 如果为 true，则返回作为命中一部分的文档版本。 wait_for_active_shards(可选，字符串） 进行操作前必须激活的分片副本数量。设置为全部或任何正整数，最多不超过索引中的分片总数（number_of_replicas+1）。默认值：1，主分区。 参阅活动分片。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#请求体","content":"query(可选，查询对象）使用Query DSL 指定要删除的文档。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#响应体","content":"JSON 响应如下： { &quot;took&quot; : 147, &quot;timed_out&quot;: false, &quot;total&quot;: 119, &quot;deleted&quot;: 119, &quot;batches&quot;: 1, &quot;version_conflicts&quot;: 0, &quot;noops&quot;: 0, &quot;retries&quot;: { &quot;bulk&quot;: 0, &quot;search&quot;: 0 }, &quot;throttled_millis&quot;: 0, &quot;requests_per_second&quot;: -1.0, &quot;throttled_until_millis&quot;: 0, &quot;failures&quot; : [ ] }  took整个操作从开始到结束的毫秒数。 timed_out如果在执行查询删除过程中执行的任何请求超时，该标志将被设置为 true。 total成功处理的文件数量。 deleted成功删除的文件数量。 batches通过查询删除拉回的滚动回复的数量。 version_conflicts通过查询删除所遇到的版本冲突的数量。 noops对于通过查询删除，该字段始终等于零。它的存在只是为了让通过查询删除、通过查询更新和重新索引 API 返回具有相同结构的响应。 retries批量操作重试次数，搜索操作重试次数。 throttled_millis请求符合 requests_per_second 要求所需的毫秒数。 requests_per_second查询删除过程中每秒有效执行的请求数。 throttled_until_millis在 _delete_by_query 响应中，该字段应始终等于零。它只有在使用任务 API 时才有意义，因为它表示下一次再次执行节流请求的时间（以毫秒为单位，自纪元开始），以符合 requests_per_second 的要求。 failures失败数组（如果在处理过程中出现无法恢复的错误）。如果该数组非空，则请求会因为这些故障而中止。通过查询删除是使用批次实现的，任何失败都会导致整个过程中止，但当前批次中的所有失败都会被收集到数组中。可以使用冲突选项来防止重新索引在版本冲突时中止。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#示例","content":"删除 my-index-000001 数据流或索引中的所有文件： POST my-index-000001/_delete_by_query?conflicts=proceed { &quot;query&quot;: { &quot;match_all&quot;: {} } }  从多个数据流或索引中删除文件： POST /my-index-000001,my-index-000002/_delete_by_query { &quot;query&quot;: { &quot;match_all&quot;: {} } }  将查询删除操作限制在特定路由值的分区上： POST my-index-000001/_delete_by_query?routing=1 { &quot;query&quot;: { &quot;range&quot; : { &quot;age&quot; : { &quot;gte&quot; : 10 } } } }  默认情况下，_delete_by_query 使用的滚动批次为 1000。您可以使用 scroll_size URL 参数更改批次大小： POST my-index-000001/_delete_by_query?scroll_size=5000 { &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } } }  使用唯一属性删除文档： POST my-index-000001/_delete_by_query { &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } }, &quot;max_docs&quot;: 1 }  ","version":"Next","tagName":"h2"},{"title":"手动切片​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#手动切片","content":"通过提供切片 ID 和切片总数，手动按查询对删除进行切片： POST my-index-000001/_delete_by_query { &quot;slice&quot;: { &quot;id&quot;: 0, &quot;max&quot;: 2 }, &quot;query&quot;: { &quot;range&quot;: { &quot;http.response.bytes&quot;: { &quot;lt&quot;: 2000000 } } } } POST my-index-000001/_delete_by_query { &quot;slice&quot;: { &quot;id&quot;: 1, &quot;max&quot;: 2 }, &quot;query&quot;: { &quot;range&quot;: { &quot;http.response.bytes&quot;: { &quot;lt&quot;: 2000000 } } } }  您可以验证它是否有效： GET _refresh POST my-index-000001/_search?size=0&amp;filter_path=hits.total { &quot;query&quot;: { &quot;range&quot;: { &quot;http.response.bytes&quot;: { &quot;lt&quot;: 2000000 } } } }  这就产生了一个合理的 total，如下： { &quot;hits&quot;: { &quot;total&quot; : { &quot;value&quot;: 0, &quot;relation&quot;: &quot;eq&quot; } } }  ","version":"Next","tagName":"h3"},{"title":"使用自动切片​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#使用自动切片","content":"你也可以让逐个查询删除自动并行化，使用切片滚动对 _id 进行分片。使用 slices 指定要使用的切片数量： POST my-index-000001/_delete_by_query?refresh&amp;slices=5 { &quot;query&quot;: { &quot;range&quot;: { &quot;http.response.bytes&quot;: { &quot;lt&quot;: 2000000 } } } }  您也可以验证它是否有效： POST my-index-000001/_search?size=0&amp;filter_path=hits.total { &quot;query&quot;: { &quot;range&quot;: { &quot;http.response.bytes&quot;: { &quot;lt&quot;: 2000000 } } } }  这就产生一个合理的 total，如下： { &quot;hits&quot;: { &quot;total&quot; : { &quot;value&quot;: 0, &quot;relation&quot;: &quot;eq&quot; } } }  将 slices 设置为 auto，Elasticsearch 就可以选择要使用的切片数量。此设置将在一定限制内对每个分片使用一个切片。如果有多个源数据流或索引，它会根据分片数量最少的索引或后备索引来选择切片数量。 在 _delete_by_query 中添加 slices 只是将上一节中使用的手动过程自动化，创建子请求，这意味着它有一些怪异之处： 您可以在任务 API 中看到这些请求。这些子请求是带 slices 请求任务的“子”任务。获取带 slices 请求的任务状态只包含已完成切片的状态。这些子任务可单独处理，如取消和重加速。重新加速 slices 请求会按比例重新加速未完成的子请求。取消带 slices 的请求将取消每个子请求。由于 slices 的特性，每个子请求不会得到完全平均的文件。所有文件都会被处理，但有些切片可能比其他分片大。预计较大的切片分布会更均匀。带 slices 的请求的参数，如 requests_per_second 和 max_docs 等参数会按比例分配给每个子请求。结合上文关于分布不均的观点，你应该会得出结论：使用 max_docs 和 slices 可能不会导致删除的文件数正好达到 max_docs 文档。每个子请求获得的源数据流或索引快照都略有不同，尽管这些快照都是在大致相同的时间获取的。 ","version":"Next","tagName":"h3"},{"title":"更改请求的节流​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#更改请求的节流","content":"可使用 _rethrottle API 在运行中的删除查询中更改 requests_per_second 的值。加快查询速度的节流措施会立即生效，但降低查询速度的节流措施会在完成当前批次后生效，以防止滚动超时。 POST _delete_by_query/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1  使用任务 API 获取任务 ID。将 requests_per_second 设置为任意正十进制值，或设置为 -1 以禁用节流。 ","version":"Next","tagName":"h3"},{"title":"通过查询获取删除操作的状态​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#通过查询获取删除操作的状态","content":"使用任务 API 获取查询删除操作的状态： GET _tasks?detailed=true&amp;actions=*/delete/byquery  响应如下： { &quot;nodes&quot; : { &quot;r1A2WoRbTwKZ516z6NEs5A&quot; : { &quot;name&quot; : &quot;r1A2WoR&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9300&quot;, &quot;host&quot; : &quot;127.0.0.1&quot;, &quot;ip&quot; : &quot;127.0.0.1:9300&quot;, &quot;attributes&quot; : { &quot;testattr&quot; : &quot;test&quot;, &quot;portsfile&quot; : &quot;true&quot; }, &quot;tasks&quot; : { &quot;r1A2WoRbTwKZ516z6NEs5A:36619&quot; : { &quot;node&quot; : &quot;r1A2WoRbTwKZ516z6NEs5A&quot;, &quot;id&quot; : 36619, &quot;type&quot; : &quot;transport&quot;, &quot;action&quot; : &quot;indices:data/write/delete/byquery&quot;, &quot;status&quot; : { &quot;total&quot; : 6154, &quot;updated&quot; : 0, &quot;created&quot; : 0, &quot;deleted&quot; : 3500, &quot;batches&quot; : 36, &quot;version_conflicts&quot; : 0, &quot;noops&quot; : 0, &quot;retries&quot;: 0, &quot;throttled_millis&quot;: 0 }, &quot;description&quot; : &quot;&quot; } } } } }  &quot;status&quot;：该对象包含实际状态。total 是重索引预计执行的操作总数。您可以通过添加 updated、 created 和 deleted 字段来估算进度。当它们的总和等于 total 字段时，请求将完成。 有了任务 ID，就可以直接查找任务： GET /_tasks/r1A2WoRbTwKZ516z6NEs5A:36619  此 API 的优势在于它与 wait_for_completion=false 集成，可以透明地返回已完成任务的状态。如果任务已完成，且对其设置了 wait_for_completion=false，那么它将返回结果或错误字段。此功能的代价是，wait_for_completion=false 会在 .tasks/task/${taskId} 创建一个文档。您可以自行删除该文档。 ","version":"Next","tagName":"h3"},{"title":"取消查询删除操作​","type":1,"pageTitle":"按查询删除 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/delete_by_query#取消查询删除操作","content":"可以使用任务取消 API 取消任何查询删除操作： POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel  任务 ID 可通过任务 API 找到。 取消任务的过程应该很快，但可能需要几秒钟。上述任务状态 API 将继续列出通过查询删除的任务，直到该任务检查到它已被取消并自行终止。 原文链接 ","version":"Next","tagName":"h3"},{"title":"多重获取（mget） API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#请求","content":"GET /_mget GET /&lt;index&gt;/_mget ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有目标索引或索引别名的 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#描述","content":"使用 mget 可以从一个或多个索引中检索多个文档。如果在请求 URI 中指定了索引，则只需在请求正文中指定文档 ID。 ","version":"Next","tagName":"h2"},{"title":"安全​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#安全","content":"参阅基于 URL 的访问控制。 ","version":"Next","tagName":"h3"},{"title":"部分响应​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#部分响应","content":"为确保快速响应，如果一个或多个分片出现故障，多重获取 API 会响应部分结果。更多信息，参阅分片失败。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#路径参数","content":"&lt;index&gt;(可选，字符串） 当指定 ids 时或 docs 数组中的文档未指定索引时，用于检索文档的索引名称。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#查询参数","content":"preference(可选，字符串） 指定应在哪个节点或分片上执行操作。默认为随机。 realtime(可选，布尔） 如果为 true，则表示请求是实时的，而不是近实时的。默认为 true。参阅实时。 refresh(可选，布尔） 如果为 true，请求会在检索文档前刷新相关分区。默认为 false。 routing(可选，字符串） 用于将操作路由到特定分区的自定义值。 stored_fields(可选，布尔） 如果为 true，则检索存储在索引中的文档字段，而不是文档 _source。默认为 false。 _source(可选，字符串）返回 _source 字段与否的真或假，或者要返回的字段列表。 _source_excludes(可选，字符串）以逗号分隔的源字段列表，用于从响应中排除。 也可以使用该参数从 _source_includes 查询参数指定的子集中排除字段。 如果 _source 参数为 false，该参数将被忽略。 _source_includes(可选，字符串）以逗号分隔的源字段列表，包含在响应中。 如果指定了该参数，则只返回这些源字段。你可以使用 _source_excludes 查询参数从该子集中排除字段。 如果 _source 参数为 false，该参数将被忽略。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#请求体","content":"docs(可选，数组）要检索的文档。如果请求 URI 中未指明索引，则为必填项。您可以为每个文档指定以下属性： _id(必填，字符串）唯一的文档 ID。_index(可选，字符串）包含文档的索引。如果请求 URI 中未指明索引，则为必填项。routing(可选，字符串） 文档所在主分区的密钥。如果在索引过程中使用路由，则为必填项。_source(可选，布尔） 如果为 false，则排除所有 _source 字段。默认为 true。 source_include(可选，数组）从 _source 字段中提取并返回的字段。source_exclude(可选，数组）要从返回的 _source 字段中排除的字段。 _stored_fields(可选，数组）要检索的存储字段。 ids(可选，数组）要检索的文档的 ID。在请求 URI 中指定索引时允许使用。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#响应体","content":"响应包括一个 docs 数组，其中包含按请求中指定的顺序排列的文档。返回的文档结构与 获取 API 返回的结构类似。如果获取某个文档失败，错误信息将代替该文档。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#示例","content":"","version":"Next","tagName":"h2"},{"title":"按 ID 获取文档​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#按-id-获取文档","content":"如果在请求 URI 中指定了索引，则请求正文中只需要文档 ID： GET /my-index-000001/_mget { &quot;docs&quot;: [ { &quot;_id&quot;: &quot;1&quot; }, { &quot;_id&quot;: &quot;2&quot; } ] }  你可以使用 ids 元素来简化请求： GET /my-index-000001/_mget { &quot;ids&quot; : [&quot;1&quot;, &quot;2&quot;] }  ","version":"Next","tagName":"h3"},{"title":"过滤源字段​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#过滤源字段","content":"默认情况下，每个文档（如果已存储）都会返回 _source 字段。使用 _source 和 _source_include 或 source_exclude 属性可过滤为特定文档返回的字段。你可以在请求 URI 中包含 _source、_source_includes 和 _source_excludes 查询参数，以指定在没有每个文档说明时使用的默认值。 例如，下面的请求将文档 1 的 _source 设置为 false，以完全排除源，从文档 2 中检索 field3 和 field4，从文档 3 中检索 user 字段，但过滤掉 user.location 字段。 GET /_mget { &quot;docs&quot;: [ { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_source&quot;: false }, { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_source&quot;: [ &quot;field3&quot;, &quot;field4&quot; ] }, { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_source&quot;: { &quot;include&quot;: [ &quot;user&quot; ], &quot;exclude&quot;: [ &quot;user.location&quot; ] } } ] }  ","version":"Next","tagName":"h3"},{"title":"获取存储字段​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#获取存储字段","content":"使用 stored_fields 属性指定要检索的存储字段集。任何未存储的请求字段都将被忽略。可以在请求 URI 中包含 stored_fields 查询参数，以指定在没有每个文档说明时使用的默认值。 例如，以下请求从文档 1 检索 field1 和 field2，从文档 2 检索 field3 和 field4： GET /_mget { &quot;docs&quot;: [ { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;stored_fields&quot;: [ &quot;field1&quot;, &quot;field2&quot; ] }, { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;stored_fields&quot;: [ &quot;field3&quot;, &quot;field4&quot; ] } ] }  以下请求默认从所有文档中检索 field1 和 field2。文档 1 将返回这些默认字段，但文档 2 将覆盖返回 field3 和 field4。 GET /test/_mget?stored_fields=field1,field2 { &quot;docs&quot;: [ { &quot;_id&quot;: &quot;1&quot; }, { &quot;_id&quot;: &quot;2&quot;, &quot;stored_fields&quot;: [ &quot;field3&quot;, &quot;field4&quot; ] } ] }  ","version":"Next","tagName":"h3"},{"title":"指定文档路由​","type":1,"pageTitle":"多重获取（mget） API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_get#指定文档路由","content":"如果在索引编制过程中使用了路由，则需要指定检索文档的路由值。例如，下面的请求从路由键 key1 对应的分区获取 test/_doc/2，并从路由键 key2 对应的分区获取 test/_doc/1。 GET /_mget?routing=key1 { &quot;docs&quot;: [ { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;routing&quot;: &quot;key2&quot; }, { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;2&quot; } ] }  原文链接 ","version":"Next","tagName":"h3"},{"title":"批量 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#请求","content":"POST /_bulk POST /&lt;target&gt;/_bulk ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有以下的 索引权限用于数据流、索引或索引别名： 要使用 create 操作，必须拥有 create_doc、create、index 或 write 权限。数据流只支持 create 操作。要使用 index 操作，必须拥有 create、index 或 write 索引权限。要使用 delete 操作，必须拥有 delete 或 write 索引权限。要使用更 update 操作，必须拥有 index 或 write 索引权限。要通过批量 API 请求自动创建数据流或索引，必须拥有 auto_configure、create_index 或 manage 索引权限。要使用 refresh 参数使批量操作的结果在搜索时可见，必须拥有 maintenance 或 manage 索引权限。 自动创建数据流需要启用数据流的匹配索引模板。参阅设置数据流。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#描述","content":"提供了一种在单个请求中执行多个 index、create、delete 和 update 操作的方法。 这些操作使用换行分隔的 JSON（NDJSON）结构在请求正文中指定： action_and_meta_data\\n optional_source\\n action_and_meta_data\\n optional_source\\n .... action_and_meta_data\\n optional_source\\n  index 和 create 操作需要在下一行输入来源，其语义与标准索引 API 中的 op_type 参数相同：如果目标中已经存在具有相同 ID 的文档，则 create 失败；index 则根据需要添加或替换文档。 提示 数据流只支持 create 操作。要更新或删除数据流中的文档，必须以包含该文档的备用索引为目标。参阅在备用索引中更新或删除文档。 update 希望在下一行指定部分 doc、upsert 和脚本及其选项。 delete 不需要在下一行指定来源，其语义与标准删除 API 相同。 注意 最后一行数据必须以换行符 \\n 结束。每个换行符前都可以有一个 \\r（回车符）。向 _bulk 端点发送 NDJSON 数据时，请使用一个值为 application/json 或 application/x-ndjson 的 Content-Type 请求头。 由于这种格式使用字面 \\n 作为分隔符，因此要确保 JSON 操作和源代码没有优化打印。 如果在请求路径中提供了 &lt;target&gt;，它将用于任何未明确指定 _index 参数的操作。 格式说明：这里的目的是使处理速度尽可能快。由于某些操作会被重定向到其他节点上的其他分片，因此在接收节点端只对 action_meta_data 进行解析。 使用此协议的客户端库应尽量在客户端做类似的事情，并尽可能减少缓冲。 在单个批量请求中，没有&quot;正确&quot;的操作数。请尝试使用不同的设置，以找到适合你特定工作负载的最佳大小。请注意，Elasticsearch 默认将 HTTP 请求的最大大小限制为 100mb，因此客户必须确保任何请求都不会超过这一大小。无法索引超过大小限制的单个文档，因此必须在将此类文档发送到 Elasticsearch 之前将其预处理成更小的片。例如，在编制索引前将文档分割成页面或章节，或在 Elasticsearch 以外的系统中存储原始二进制数据，并在发送到 Elasticsearch 的文档中用指向外部系统的链接替换原始数据。 ","version":"Next","tagName":"h2"},{"title":"批量请求的客户端支持​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#批量请求的客户端支持","content":"一些官方支持的客户端提供了帮助程序，以协助批量请求和重新索引： GO 参阅 esutil.BulkIndexer Perl 参阅 Search::Elasticsearch::Client::5_0::Bulk 和 Search::Elasticsearch::Client::5_0::Scroll Python 参阅 elasticsearch.helpers.* JavaScript 参阅 client.helpers.* .NET 参阅 BulkAllObservable PHP 参阅 Bulk indexing ","version":"Next","tagName":"h3"},{"title":"使用 cURL 提交批量请求​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#使用-curl-提交批量请求","content":"如果向 curl 提供文本文件输入，必须使用 --data-binary 标志，而不是简单的 -d。后者不会保留换行符。示例： $ cat requests { &quot;index&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;1&quot; } } { &quot;field1&quot; : &quot;value1&quot; } $ curl -s -H &quot;Content-Type: application/x-ndjson&quot; -XPOST localhost:9200/_bulk --data-binary &quot;@requests&quot;; echo {&quot;took&quot;:7, &quot;errors&quot;: false, &quot;items&quot;:[{&quot;index&quot;:{&quot;_index&quot;:&quot;test&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:1,&quot;result&quot;:&quot;created&quot;,&quot;forced_refresh&quot;:false}}]}  ","version":"Next","tagName":"h3"},{"title":"乐观并发控制​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#乐观并发控制","content":"批量 API 调用中的每个 index 和 delete 操作都可以在各自的操作和元数据行中包含 if_seq_no 和 if_primary_term 参数。if_seq_no 和 if_primary_term 参数根据对现有文档的最后一次修改来控制操作的执行方式。详情参阅乐观并发控制。 ","version":"Next","tagName":"h3"},{"title":"版本控制​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#版本控制","content":"每个批量项目都可以使用 version 字段包含版本值。它会根据 _version 映射自动遵循索引/删除操作的行为。它还支持 version_type（参阅版本控制）。 ","version":"Next","tagName":"h3"},{"title":"路由​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#路由","content":"每个批量项目都可以使用 routing 字段包含路由值。它会根据 _routing 映射自动遵循索引/删除操作的行为。 提示 数据流不支持自定义路由，除非在创建数据流时启用了模板中的 allow_custom_routing 设置。 ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#等待活动分片","content":"在进行批量调用时，可以设置 wait_for_active_shards 参数，要求在开始处理批量请求之前，至少要有一定数量的分片副本处于活动状态。详情和使用示例参阅此处。 ","version":"Next","tagName":"h3"},{"title":"刷新​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#刷新","content":"控制搜索何时可以看到该请求所做的更改。参阅刷新。 提示 只有收到批量请求的分片才会受到 refresh 的影响。试想一下，一个 _bulk?refresh=wait_for 请求中包含三个文档，而这三个文档恰好被路由到一个有五个分区的索引中的不同分区。该请求只会等待这三个分区刷新。组成索引的其他两个分区完全不参与 _bulk 请求。 ","version":"Next","tagName":"h3"},{"title":"安全​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#安全","content":"参阅基于 URL 的访问控制。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#路径参数","content":"&lt;target&gt; (可选，字符串） 要执行批量操作的数据流、索引或索引别名的名称。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#查询参数","content":"list_executed_pipelines (可选，布尔值）如果为 true，响应将包括为每个索引器创建时执行的摄取管道。默认为 false。 pipeline (可选，字符串）用于预处理传入文档的管道 ID。如果索引指定了默认摄取管道，则将该值设为 _none 会禁用此请求的默认摄取管道。如果配置了最终管道，无论此参数的值如何，它都将始终运行。 refresh (可选，布尔值）如果为 true，Elasticsearch 会刷新受影响的分片，使操作在搜索中可见。默认为 false。 require_alias （可选，布尔值）如果为 true，则目标必须是索引别名。默认为false。 routing (可选，字符串） 用于将操作路由到特定分区的自定义值。 _source (可选，字符串）返回 _source 字段与否的真或假，或者要返回的字段列表。 _source_excludes (可选，字符串）以逗号分隔的源字段列表，用于从响应中排除。 也可以使用该参数从 _source_includes 查询参数指定的子集中排除字段。 如果 _source 参数为 false，该参数将被忽略。 _source_includes (可选，字符串）以逗号分隔的源字段列表，包含在响应中。 如果指定了该参数，则只返回这些源字段。你可以使用 _source_excludes 查询参数从该子集中排除字段。 如果 _source 参数为 false，该参数将被忽略。 timeout (可选，时间单位） 每个更新请求等待以下操作的周期： 自动创建索引 动态映射更新 等待活动分片 默认为 1m（一分钟）。这保证 Elasticsearch 在失败前至少等待超时时间。实际等待时间可能会更长，尤其是发生多次等待时。 wait_for_active_shards(可选，字符串） 进行操作前必须激活的分片副本数量。设置为 all 或任何正整数，最多不超过索引中的分片总数（number_of_replicas+1）。默认值：1，主分区。 参阅活动分片。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#请求体","content":"请求正文包含以新行分隔的创建、删除、索引和更新操作及其相关源数据的列表。 create (可选，字符串） 如果指定文档还不存在，则对其进行索引。下面一行必须包含要索引的源数据。 _index (可选，字符串）要执行操作的数据流、索引或索引别名的名称。如果请求路径中未指明 &lt;target&gt;，则必须使用此参数。 _id (可选，字符串） 文档 ID。如果未指定 ID，文件 ID 将自动生成。 list_executed_pipelines (可选，布尔值）如果为 true，响应将包括已执行的摄取管道。默认为 false。 require_alias (可选，布尔） 如果为 true，则操作必须以索引别名为目标。默认为 false。 dynamic_templates (可选，映射）从字段全名到动态模板名称的映射。默认为空映射。如果某个名称与动态模板相匹配，那么无论模板中是否定义了其他匹配谓词，都将应用该模板。如果某个字段已在映射中定义，则不会使用此参数。 delete (可选，字符串） 从索引中删除指定文档。 _index (可选，字符串）要执行操作的索引或索引别名的名称。如果未在请求路径中指定 &lt;target&gt;，则必须使用此参数。 _id (必填，字符串） 文档 ID。 require_alias (可选，布尔） 如果为 true，则操作必须以索引别名为目标。默认为 false。 index (可选，字符串）索引指定的文档。如果文档存在，则替换文档并递增版本。下面一行必须包含要索引的源数据。 _index (可选，字符串）要执行操作的索引或索引别名的名称。如果未在请求路径中指定 &lt;target&gt;，则必须使用此参数。 _id (可选，字符串） 文档 ID。如果未指定 ID，文件 ID 将自动生成。 list_executed_pipelines (可选，布尔值）如果为 true，响应将包括已执行的摄取管道。默认为 false。 require_alias (可选，布尔值） 如果为 true，则操作必须以索引别名为目标。默认为 false。 dynamic_templates (可选，映射）从字段全名到动态模板名称的映射。默认为空映射。如果某个名称与动态模板相匹配，那么无论模板中是否定义了其他匹配谓词，都将应用该模板。如果某个字段已在映射中定义，则不会使用此参数。 update (可选，字符串） 执行部分文档更新。下面一行必须包含部分文档和更新选项。 _index (可选，字符串）要执行操作的索引或索引别名的名称。如果未在请求路径中指定 &lt;target&gt;，则必须使用此参数。 _id (必填，字符串） 文档 ID。 require_alias (可选，布尔） 如果为 true，则操作必须以索引别名为目标。默认为 false。 doc (可选，对象）要索引的部分文档。update 操作必需。 &lt;fields&gt; (可选，对象）要索引的文档源。create 和 index 操作必需。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#响应体","content":"批量 API 的响应包含请求中每个操作的单独结果，并按照提交的顺序返回。单个操作的成功或失败不会影响请求中的其他操作。 took (整数）批量请求的处理时间（毫秒）。 errors (布尔值）如果为 true，则批量请求中的一个或多个操作未成功完成。 items (对象数组） 包含批量请求中每个操作的结果，按提交顺序排列。 items 对象属性 &lt;action&gt; (对象）参数名称是与操作相关的操作。可能的值包括创建、删除、索引和更新。 参数值是一个包含相关操作信息的对象。 &lt;action&gt; 属性 _index (字符串）与操作相关联的索引名称。如果操作以数据流为目标，则该索引是写入文档的后备索引。 _id (整数）与操作相关的文档 ID。 _version (整数）与操作相关的文档版本。每次更新文档时，文档版本都会递增。 该参数仅在操作成功时返回。 result (字符串）操作结果。成功的值包括 created、deleted 和 updated。其他有效值为 noop 和 not_found。 _shards (对象） 包含操作的分片信息。 只有操作成功才会返回该参数。 _shards 属性 total (整数）操作尝试执行的分片数。 successful (整数）操作成功的分片数。 failed (整数）操作尝试执行但失败的分片数量。 _seq_no (整数）为操作分配给文档的序列号。序列号用于确保文档的旧版本不会覆盖新版本。参阅乐观并发控制。 只有成功的操作才会返回此参数。 _primary_term (整数）为操作分配给文档的主要术语。参阅乐观并发控制。 该参数仅在操作成功时返回。 status (整数）操作返回的 HTTP 状态代码。 error (对象）包含有关操作失败的附加信息。 只有操作失败时才会返回该参数。 error 属性 type (字符串）操作的错误类型。 reason (字符串）操作失败的原因。 index_uuid (字符串）与失败操作相关的索引的通用唯一标识符 (UUID)。 shard (字符串）与失败操作相关的分区的 ID。 index (字符串）与失败操作相关联的索引名称。如果操作以数据流为目标，则这是试图将文档写入的后备索引。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#示例","content":"POST _bulk { &quot;index&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;1&quot; } } { &quot;field1&quot; : &quot;value1&quot; } { &quot;delete&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;2&quot; } } { &quot;create&quot; : { &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;3&quot; } } { &quot;field1&quot; : &quot;value3&quot; } { &quot;update&quot; : {&quot;_id&quot; : &quot;1&quot;, &quot;_index&quot; : &quot;test&quot;} } { &quot;doc&quot; : {&quot;field2&quot; : &quot;value2&quot;} }  API 返回以下结果： { &quot;took&quot;: 30, &quot;errors&quot;: false, &quot;items&quot;: [ { &quot;index&quot;: { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;status&quot;: 201, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot;: 1 } }, { &quot;delete&quot;: { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;not_found&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;status&quot;: 404, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 2 } }, { &quot;create&quot;: { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;status&quot;: 201, &quot;_seq_no&quot; : 2, &quot;_primary_term&quot; : 3 } }, { &quot;update&quot;: { &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;status&quot;: 200, &quot;_seq_no&quot; : 3, &quot;_primary_term&quot; : 4 } } ] }  ","version":"Next","tagName":"h2"},{"title":"批量更新示例​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#批量更新示例","content":"使用 update 操作时，retry_on_conflict 可作为操作本身的一个字段（而不是额外的有效载荷行），用于指定在版本冲突的情况下应重试多少次更新。 update 操作有效载荷支持以下选项：doc（部分文档）、upsert、doc_as_upsert、script、params（用于脚本）、lang（用于脚本）和 _source。有关选项的详细信息，参阅更新文档。更新操作示例： POST _bulk { &quot;update&quot; : {&quot;_id&quot; : &quot;1&quot;, &quot;_index&quot; : &quot;index1&quot;, &quot;retry_on_conflict&quot; : 3} } { &quot;doc&quot; : {&quot;field&quot; : &quot;value&quot;} } { &quot;update&quot; : { &quot;_id&quot; : &quot;0&quot;, &quot;_index&quot; : &quot;index1&quot;, &quot;retry_on_conflict&quot; : 3} } { &quot;script&quot; : { &quot;source&quot;: &quot;ctx._source.counter += params.param1&quot;, &quot;lang&quot; : &quot;painless&quot;, &quot;params&quot; : {&quot;param1&quot; : 1}}, &quot;upsert&quot; : {&quot;counter&quot; : 1}} { &quot;update&quot; : {&quot;_id&quot; : &quot;2&quot;, &quot;_index&quot; : &quot;index1&quot;, &quot;retry_on_conflict&quot; : 3} } { &quot;doc&quot; : {&quot;field&quot; : &quot;value&quot;}, &quot;doc_as_upsert&quot; : true } { &quot;update&quot; : {&quot;_id&quot; : &quot;3&quot;, &quot;_index&quot; : &quot;index1&quot;, &quot;_source&quot; : true} } { &quot;doc&quot; : {&quot;field&quot; : &quot;value&quot;} } { &quot;update&quot; : {&quot;_id&quot; : &quot;4&quot;, &quot;_index&quot; : &quot;index1&quot;} } { &quot;doc&quot; : {&quot;field&quot; : &quot;value&quot;}, &quot;_source&quot;: true}  ","version":"Next","tagName":"h3"},{"title":"操作失败的示例​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#操作失败的示例","content":"以下批量 API 请求包含更新不存在文档的操作。 POST /_bulk { &quot;update&quot;: {&quot;_id&quot;: &quot;5&quot;, &quot;_index&quot;: &quot;index1&quot;} } { &quot;doc&quot;: {&quot;my_field&quot;: &quot;foo&quot;} } { &quot;update&quot;: {&quot;_id&quot;: &quot;6&quot;, &quot;_index&quot;: &quot;index1&quot;} } { &quot;doc&quot;: {&quot;my_field&quot;: &quot;foo&quot;} } { &quot;create&quot;: {&quot;_id&quot;: &quot;7&quot;, &quot;_index&quot;: &quot;index1&quot;} } { &quot;my_field&quot;: &quot;foo&quot; }  由于这些操作无法成功完成，API 会返回一个 errors 标志为 true 的响应。 对于任何失败的操作，响应中还包含一个 error 对象。error 对象包含有关失败的附加信息，如错误类型和原因。 { &quot;took&quot;: 486, &quot;errors&quot;: true, &quot;items&quot;: [ { &quot;update&quot;: { &quot;_index&quot;: &quot;index1&quot;, &quot;_id&quot;: &quot;5&quot;, &quot;status&quot;: 404, &quot;error&quot;: { &quot;type&quot;: &quot;document_missing_exception&quot;, &quot;reason&quot;: &quot;[5]: document missing&quot;, &quot;index_uuid&quot;: &quot;aAsFqTI0Tc2W0LCWgPNrOA&quot;, &quot;shard&quot;: &quot;0&quot;, &quot;index&quot;: &quot;index1&quot; } } }, { &quot;update&quot;: { &quot;_index&quot;: &quot;index1&quot;, &quot;_id&quot;: &quot;6&quot;, &quot;status&quot;: 404, &quot;error&quot;: { &quot;type&quot;: &quot;document_missing_exception&quot;, &quot;reason&quot;: &quot;[6]: document missing&quot;, &quot;index_uuid&quot;: &quot;aAsFqTI0Tc2W0LCWgPNrOA&quot;, &quot;shard&quot;: &quot;0&quot;, &quot;index&quot;: &quot;index1&quot; } } }, { &quot;create&quot;: { &quot;_index&quot;: &quot;index1&quot;, &quot;_id&quot;: &quot;7&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;status&quot;: 201 } } ] }  要只返回操作失败的信息，请使用参数为 items.*.error 的 filter_path 查询参数。 POST /_bulk?filter_path=items.*.error { &quot;update&quot;: {&quot;_id&quot;: &quot;5&quot;, &quot;_index&quot;: &quot;index1&quot;} } { &quot;doc&quot;: {&quot;my_field&quot;: &quot;baz&quot;} } { &quot;update&quot;: {&quot;_id&quot;: &quot;6&quot;, &quot;_index&quot;: &quot;index1&quot;} } { &quot;doc&quot;: {&quot;my_field&quot;: &quot;baz&quot;} } { &quot;update&quot;: {&quot;_id&quot;: &quot;7&quot;, &quot;_index&quot;: &quot;index1&quot;} } { &quot;doc&quot;: {&quot;my_field&quot;: &quot;baz&quot;} }  API 返回以下结果： { &quot;items&quot;: [ { &quot;update&quot;: { &quot;error&quot;: { &quot;type&quot;: &quot;document_missing_exception&quot;, &quot;reason&quot;: &quot;[5]: document missing&quot;, &quot;index_uuid&quot;: &quot;aAsFqTI0Tc2W0LCWgPNrOA&quot;, &quot;shard&quot;: &quot;0&quot;, &quot;index&quot;: &quot;index1&quot; } } }, { &quot;update&quot;: { &quot;error&quot;: { &quot;type&quot;: &quot;document_missing_exception&quot;, &quot;reason&quot;: &quot;[6]: document missing&quot;, &quot;index_uuid&quot;: &quot;aAsFqTI0Tc2W0LCWgPNrOA&quot;, &quot;shard&quot;: &quot;0&quot;, &quot;index&quot;: &quot;index1&quot; } } } ] }  ","version":"Next","tagName":"h3"},{"title":"使用动态模板参数的示例​","type":1,"pageTitle":"批量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/bulk#使用动态模板参数的示例","content":"下面的示例创建了一个动态模板，然后使用 dynamic_templates 参数执行由索引/创建请求组成的批量请求。 PUT my-index/ { &quot;mappings&quot;: { &quot;dynamic_templates&quot;: [ { &quot;geo_point&quot;: { &quot;mapping&quot;: { &quot;type&quot; : &quot;geo_point&quot; } } } ] } } POST /_bulk { &quot;index&quot; : { &quot;_index&quot; : &quot;my_index&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;dynamic_templates&quot;: {&quot;work_location&quot;: &quot;geo_point&quot;}} } { &quot;field&quot; : &quot;value1&quot;, &quot;work_location&quot;: &quot;41.12,-71.34&quot;, &quot;raw_location&quot;: &quot;41.12,-71.34&quot;} { &quot;create&quot; : { &quot;_index&quot; : &quot;my_index&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;dynamic_templates&quot;: {&quot;home_location&quot;: &quot;geo_point&quot;}} } { &quot;field&quot; : &quot;value2&quot;, &quot;home_location&quot;: &quot;41.12,-71.34&quot;}  批量请求根据 dynamic_templates 参数创建了两个新字段 work_location 和 home_location，其类型为 geo_point；但 raw_location 字段是使用默认动态映射规则创建的，在这种情况下是 text 字段，因为它在 JSON 文档中是以字符串形式提供的。 原文链接 ","version":"Next","tagName":"h3"},{"title":"索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#请求","content":"PUT /&lt;target&gt;/_doc/&lt;_id&gt; POST /&lt;target&gt;/_doc/ PUT /&lt;target&gt;/_create/&lt;_id&gt; POST /&lt;target&gt;/_create/&lt;_id&gt; 警告 不能使用 PUT /&lt;target&gt;/_doc/&lt;_id&gt; 请求格式向数据流添加新文档。要指定文档ID，请改用 PUT/&lt;target&gt;/_create/&lt;_ID&gt; 格式。参阅向数据流添加文档。 ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或索引别名必须有索引权限。 要使用 PUT /&lt;target&gt;/_doc/&lt;_id&gt; 请求格式添加或覆盖文档，你必须有 create、index 或 write 索引权限。要使用 POST /&lt;target&gt;/_ doc/、PUT /&lt;target&gt;/_create/&lt;_id&gt; 或 POST /&lt;&lt;target&gt;/_create/&lt;_ id&gt; 请求格式添加文档，你必须有 create_doc、create、index 或 write 索引权限。要使用索引 API 请求自动创建数据流或索引，你必须具有 auto_configure、create_index 或 manage 索引权限。 自动数据流创建需要启用数据流的匹配索引模板。参阅设置数据流。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#路径参数","content":"&lt;target&gt; （必需，字符串）目标的数据流或索引名字。 如果目标不存在，并且与具有 data_stream 定义的索引模板的名称或通配符（*）模式匹配，则此请求将创建数据流。参阅设置数据流。 如果目标不存在且与数据流模板不匹配，则此请求将创建索引。 你可以使用解析索引 API 检查现有目标。 &lt;_id&gt; （可选，字符串）文档唯一标识。 参数要符合以下请求格式： PUT /&lt;target&gt;/_doc/&lt;_id&gt;PUT /&lt;target&gt;/_create/&lt;_id&gt;POST /&lt;target&gt;/_create/&lt;_id&gt; 为了自动生成文档 ID，使用此请求格式并忽略参数： POST /&lt;target&gt;/_doc/。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#查询参数","content":"if_seq_no （可选，整数）仅当文档具有此序列号时才执行此操作。参阅乐观并发控制。 if_primary_term （可选，整数）仅当文档具有此主词语时才执行此操作。参阅乐观并发控制。 op_type （可选，枚举）设置为 create，仅在文档不存在时为其编制索引（不存在则放置）。如果具有指定 _id 的文档已经存在，索引操作将失败。与使用 &lt;index&gt;/_create 端点相同的逻辑。有效值：index, create。如果指定了文档 id，则默认为 index。否则，它默认为 create。 提示 如果请求以数据流为目标，则 op_type 为 create 是必需的。参阅向数据流添加文档。 pipeline （可选，字符串）用于预处理传入文档的管道 ID。 refresh （可选，枚举）如果为 true，则 Elasticsearch 刷新受影响的分片，以使此操作对搜索可见；如果为 wait_for，则等待刷新，以使该操作对搜索可见；如果为 false，则不对刷新执行任何操作。有效值：true、false、wait_for。默认值：false。 routing （可选，字符串）用于将操作路由到特定分片的自定义值。 timeout （可选，时间单位）请求等待以下操作的时间段： 自动创建索引动态映射更新等待活动分片 默认为 1m（一分钟）。这保证了 Elasticsearch 在失败之前至少要等待超时。实际等待时间可能更长，尤其是在发生多次等待时。 version （可选，整数）并发控制的显式版本号。指定的版本必须与文档的当前版本匹配，请求才能成功。 version_type （可选，枚举）指定的版本类型：external、external_gte。 wait_for_active_shards （可选，字符串）继续操作前必须处于活动状态的分片副本数。设置为 all 或任何正整数，上限为索引中分片的总数（(number_of_replicas+1）。默认为：1，代表主分片。 参阅活动分片。 require_alias （可选，布尔值）如果为 true，则目标必须是索引别名。默认为false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#请求体","content":"&lt;field&gt; （必填，字符串）请求正文包含文档数据的 JSON 源。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#响应体","content":"_shards 提供有关索引操作的复制过程的信息。 _shards.total 指示应该对多少分片拷贝（主分片和副本分片）执行索引操作。 _shards.successful 指示索引操作成功的碎片副本数。索引操作成功时，successful 至少为1。 提示 索引操作成功返回时，​默认情况下副本分片可能不会全部启动，只有主节点是必须启动的。设置 wait_for_active_shards 以更改此默认行为。参阅活动分片。 _shards.failed 在副本分片上的索引操作失败时，包含复制相关错误的阵列。0 表示没有故障。 _index 文档添加到的索引的名称。 _type 文档类型。Elasticsearch 索引现在支持单个文档类型 _doc。 _id 添加的文档的唯一标识符。 _version 文档版本。每次更新文档时递增。 _seq_no 为索引操作分配给文档的序列号。序列号用于确保文档的旧版本不会覆盖新版本。参阅乐观并发控制。 _primary_term 为索引操作分配给文档的主要词语。参阅乐观并发控制。 result 索引操作的结果，created 或 updated。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#描述","content":"可以使用 _doc 或 _create 资源为新的 JSON 文档编制索引。使用 _create 可以确保仅在文档不存在时才对其进行索引。要更新现有文档，必须使用 _doc 资源。 ","version":"Next","tagName":"h2"},{"title":"自动创建数据流和索引​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#自动创建数据流和索引","content":"如果请求的目标不存在，并且匹配一个 带 data_stream 定义的索引模板，则索引操作会自动创建数据流。参阅设置数据流。 如果目标不存在并且与数据流模板不匹配，则操作会自动创建索引并应用任何匹配的索引模板。 提示 Elasticsearch包括几个内置索引模板。要避免与这些模板发生命名冲突，参阅避免索引模式冲突。 如果不存在映射，索引操作将创建动态映射。默认情况下，如果需要，新字段和对象将自动添加到映射中。有关字段映射的更多信息，参阅映射和更新映射 API。 自动创建索引由设置 action.auto_create_index 控制。此设置默认为 true，允许自动创建任何索引。你可以修改此设置以明确允许或阻止自动创建与指定模式匹配的索引，或者将其设置为 false 以完全禁用自动创建索引。指定要允许的模式的逗号分隔列表，或使用 + 或 - 作为每个模式的前缀，以指示是允许还是阻止该模式。当指定列表时，默认行为是不允许。 警告 设置 action.auto_create_index 只影响自动创建索引。它不影响创建数据流。 PUT _cluster/settings { &quot;persistent&quot;: { &quot;action.auto_create_index&quot;: &quot;my-index-000001,index10,-index1*,+ind*&quot; } } PUT _cluster/settings { &quot;persistent&quot;: { &quot;action.auto_create_index&quot;: &quot;false&quot; } } PUT _cluster/settings { &quot;persistent&quot;: { &quot;action.auto_create_index&quot;: &quot;true&quot; } }  &quot;action.auto_create_index&quot;: &quot;my-index-000001,index10,-index1*,+ind*&quot;：允许自动创建名为 my-index-000001或 index10 的索引，阻止创建与模式 index1* 匹配的索引，并允许创建与 ind* 模式匹配的任何其他索引。模式按指定的顺序匹配。&quot;action.auto_create_index&quot;: &quot;false&quot;：完全禁用自动索引创建。&quot;action.auto_create_index&quot;: &quot;true&quot;：允许自动创建任何索引。这是默认设置。 不存在则创建​ 可以使用 _create 资源或设置 op_type 参数来强制创建操作。在这种情况下，如果索引中已存在具有指定 ID 的文档，则索引操作将失败。 自动创建文档 ID​ 使用 POST /&lt;target&gt;/_doc/ 请求格式时，op_type 会自动设置为 create，索引操作会为文档生成唯一的 ID。 POST my-index-000001/_doc/ { &quot;@timestamp&quot;: &quot;2099-11-15T13:12:00&quot;, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } }  此 API 返回以下结果： { &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;failed&quot;: 0, &quot;successful&quot;: 2 }, &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;W0tpsmIBdwcYyG50zbta&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;result&quot;: &quot;created&quot; }  乐观并发控制​ 索引操作可以是有条件的，只有在为文档的最后一次修改指定了 if_seq_no 和 if_primary_term 参数指定的序号和主词语时，才能执行索引操作。如果检测到不匹配，该操作将导致 VersionConflictException 和状态代码 409。更多信息，参阅乐观并发控制。 路由​ 默认情况下，分片配置——或 routing ——通过使用文档 id 值的哈希来控制。为了进行更明确的控制，路由器使用的散列函数中的值可以使用 routing 参数直接按操作指定。例如： POST my-index-000001/_doc?routing=kimchy { &quot;@timestamp&quot;: &quot;2099-11-15T13:12:00&quot;, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } }  在本例中，根据提供的 routing 参数：“kimchy”，将文档路由到分片。 设置显式映射时，还可以使用 _routing 字段指导索引操作，以从文档本身提取路由值。这需要额外的文档解析传递（非常小的）开销。如果定义了 _routing 映射并将其设置为 required（必需的），则如果未提供或提取路由值，索引操作将失败。 提示 数据流不支持自定义路由，除非它们是在模板中启用 allow_custom_routing 设置的情况下创建的。 分布式​ 索引操作根据主分片的路由定向到主分片（参阅上面的路由部分），并在包含此分片的实际节点上执行。在主分片完成操作后，如果需要，更新将分发到适用的副本。 活动分片​ 为了提高写入系统的弹性，可以将索引操作配置为在继续操作之前等待一定数量的活动分片拷贝。如果所需数量的活动分片拷贝不可用，则写入操作必须等待并重试，直到所需分片拷贝启动或超时为止。默认情况下，写入操作仅等待主分片处于活动状态，然后再继续（即 wait_for_active_shards=1）。通过设置 index.write.wait_for_active_shards，可以在索引设置中动态覆盖此默认值。要更改每个操作的行为，可以使用 wait_for_active_shards 请求参数。 有效值为索引中每个分片配置的拷贝总数的全部或任何正整数（即 number_of_replicas+1）。指定负值或大于分片副本数的数字将引发错误。 例如，假设我们有一个由三个节点（A、B 和 C）组成的集群，我们创建一个 index 索引，将副本数设置为 3（结果是 4 个分片拷贝，比节点多一个拷贝）。如果尝试索引操作，默认情况下，该操作将仅确保每个分片的主副本在继续之前可用。这意味着，即使 B 和 C 停止运行，并且 A 托管了主分片副本，索引操作仍将仅使用数据的一个副本进行。如果在请求中将 wait_for_active_shards 设置为 3（并且所有 3 个节点都已启动），则索引操作将需要 3 个活动分片副本才能继续，这一要求应该得到满足，因为集群中有 3 个活动节点，每个节点都持有分片的副本。但是，如果将 wait_for_active_shards 设置为 all（或设置为 4，这是相同的），索引操作将不会继续，因为索引中没有每个分片的所有 4 个副本。除非集群中出现新节点来托管碎片的第四个副本，否则操作将超时。 需要注意的是，此设置大大降低了写入操作未写入所需数量的分片副本的可能性，但它并没有完全消除这种可能性，因为此检查发生在写入操作开始之前。一旦写入操作正在进行，仍有可能在任意数量的分片拷贝上复制失败，但在主拷贝上仍能成功。写入操作响应的 _shards 部分显示了复制成功/失败的分片拷贝数。 { &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;failed&quot;: 0, &quot;successful&quot;: 2 } }  刷新​ 控制此请求所做的更改对搜索可见的时间。参阅刷新。 空（noop）更新​ 使用索引 API 更新文档时，即使文档没有更改，也会始终创建文档的新版本。如果这不可接受，请使用将 detect_noop 设置为 true 的 _update API。此选项在索引 API 上不可用，因为索引 API 不获取旧源，并且无法将其与新源进行比较。 关于何时不接受空更新，没有一个硬性规定。这是许多因素的组合，例如数据源发送实际上是节点的更新的频率，以及每秒在接收更新的分片上运行多少 Elasticsearch 查询。 超时​ 在执行索引操作时，分配给执行索引操作的主分片可能不可用。这可能是因为主分片当前正在从网关恢复或正在重新定位。默认情况下，索引操作将等待主分片可用长达 1 分钟，然后失败并响应错误。timeout 参数可用于明确指定等待的时间。以下是将其设置为 5 分钟的示例： PUT my-index-000001/_doc/1?timeout=5m { &quot;@timestamp&quot;: &quot;2099-11-15T13:12:00&quot;, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } }  版本控制​ 每个索引文档都有一个版本号。默认情况下，使用内部版本控制，从 1 开始，每次更新时递增，包括删除。或者，版本号可以设置为外部值（例如，如果在数据库中维护）。要启用此功能，应将 version_type 设置为 external。提供的值必须是一个大于或等于 0 且小于 9.2e+18 左右的长数值。 使用外部版本类型时，系统会检查传递给索引请求的版本号是否大于当前存储文档的版本。如果为真，则将为文档编制索引并使用新版本号。如果提供的值小于或等于存储文档的版本号，则会发生版本冲突，索引操作将失败。例如： PUT my-index-000001/_doc/1?version=2&amp;version_type=external { &quot;user&quot;: { &quot;id&quot;: &quot;elkbee&quot; } }  提示 版本控制是完全实时的，不受搜索操作的近实时方面的影响。如果未提供版本，则执行操作时不进行任何版本检查。 在前面的示例中，操作将成功，因为提供的版本 2 高于当前文档版本 1。如果文档已经更新，并且其版本设置为 2 或更高，索引命令将失败并导致冲突（409 http状态代码）。 一个好的副作用是，只要使用源数据库中的版本号，就不需要维护由于源数据库更改而执行的异步索引操作的严格顺序。如果使用外部版本控制，即使使用数据库中的数据更新 Elasticsearch 索引的简单情况也会得到简化，因为如果索引操作出于任何原因出现故障，则只会使用最新版本。 版本类型​ 除了 external 版本类型外，Elasticsearch 还支持针对特定用例的其他类型： external 或 external_gt 仅当给定版本严格高于存储文档的版本或没有现有文档时，才为文档编制索引。给定的版本将用作新版本，并与新文档一起存储。提供的版本必须是非负的长数字。 external_gte 仅当给定版本等于或高于存储文档的版本时，才为文档编制索引。如果没有现有文档，操作也会成功。给定的版本将用作新版本，并与新文档一起存储。提供的版本必须是非负的长数字。 提示 external_gte 版本类型用于特殊用例，应谨慎使用。如果使用不当，可能会导致数据丢失。还有另一个选项，force，不推荐使用，因为它会导致主分片和副本分片分离。 ","version":"Next","tagName":"h3"},{"title":"示例​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/docs_index#示例","content":"将 JSON 文档插入 my-index-000001 索引，其 _id 为 1: PUT my-index-000001/_doc/1 { &quot;@timestamp&quot;: &quot;2099-11-15T13:12:00&quot;, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } }  此 API 返回以下结果： { &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;failed&quot;: 0, &quot;successful&quot;: 2 }, &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;result&quot;: &quot;created&quot; }  如果不存在具有该 ID 的文档，请使用 _create 资源将文档索引到 my-index-000001 索引中： PUT my-index-000001/_create/1 { &quot;@timestamp&quot;: &quot;2099-11-15T13:12:00&quot;, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } }  如果不存在具有该 ID 的文档，请设置要创建的 op_type 参数，以将文档索引到 my-index-000001 索引中： PUT my-index-000001/_doc/1?op_type=create { &quot;@timestamp&quot;: &quot;2099-11-15T13:12:00&quot;, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } }  原文链接 ","version":"Next","tagName":"h2"},{"title":"多词向量 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#请求","content":"POST /_mtermvectors POST /&lt;index&gt;/_mtermvectors ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有目标索引或索引别名的 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#描述","content":"你可以通过索引和 ID 指定现有文档，也可以在请求正文中提供人工文档。你可以在请求体或请求 URI 中指定索引。 响应包含一个 docs 数组，其中包含所有获取的词向量。每个元素都有词向量 API 提供的结构。 有关可包含在响应中的信息的更多信息，参阅词向量 API。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#路径参数","content":"&lt;index&gt; (可选，字符串）包含文件的索引名称。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#查询参数","content":"fields (可选，字符串） 用逗号分隔的字段列表或通配符表达式，这些字段将包含在统计信息中。 除非在 completion_fields 或 fielddata_fields 参数中提供了特定字段列表，否则将作为默认列表使用。 field_statistics (可选，布尔值） 如果为 true，响应将包括文档计数、文档频率总和以及词总频率总和。默认为 true。 &lt;offsets&gt; (可选，布尔值） 如果为 true，则响应包括词偏移。默认为 true。 payloads (可选，布尔值） 如果为 true，则响应包括词有效载荷。默认为 true。 positions (可选，布尔值） 如果为 true，则响应包括词位置。默认为 true。 preference (可选，字符串） 指定应在哪个节点或分片上执行操作。默认为随机。 routing (可选，字符串） 用于将操作路由到特定分区的自定义值。 realtime (可选，布尔值） 如果为 true，则表示请求是实时的，而不是近实时的。默认为 true。参阅实时。 term_statistics (可选，布尔值）如果为 true，则响应包括词频和文档频率。默认为 false。 version (可选，布尔值） 如果为 true，则返回作为命中一部分的文档版本。 version_type (可选，枚举值） 特定版本类型：external、external_gte。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#示例","content":"如果在请求 URI 中指定索引，则无需为请求体中的每个文档指定索引： POST /my-index-000001/_mtermvectors { &quot;docs&quot;: [ { &quot;_id&quot;: &quot;2&quot;, &quot;fields&quot;: [ &quot;message&quot; ], &quot;term_statistics&quot;: true }, { &quot;_id&quot;: &quot;1&quot; } ] }  如果请求的所有文件都在同一索引中，且参数相同，则可使用以下简化语法： POST /my-index-000001/_mtermvectors { &quot;ids&quot;: [ &quot;1&quot;, &quot;2&quot; ], &quot;parameters&quot;: { &quot;fields&quot;: [ &quot;message&quot; ], &quot;term_statistics&quot;: true } }  ","version":"Next","tagName":"h3"},{"title":"人工文档​","type":1,"pageTitle":"多词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/multi_termvectors#人工文档","content":"你还可以使用 mtermvectors 为请求体中提供的人工文档生成词向量。使用的映射由指定的 _index 决定。 POST /_mtermvectors { &quot;docs&quot;: [ { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;doc&quot; : { &quot;message&quot; : &quot;test test test&quot; } }, { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;doc&quot; : { &quot;message&quot; : &quot;Another test ...&quot; } } ] }  原文链接 ","version":"Next","tagName":"h3"},{"title":"乐观并发控制","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/optimistic_concurrency_control","content":"乐观并发控制 Elasticsearch 是分布式的。当创建、更新或删除文档时，文档的新版本必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求是并行发送的，而且可能会不按顺序到达目的地。Elasticsearch 需要一种方法来确保文档的旧版本永远不会覆盖新版本。 为了确保文档的旧版本不会覆盖新版本，对文档执行的每次操作都会由负责协调更改的主分片分配一个序列号。每次操作都会增加序列号，因此较新操作的序列号会高于较旧操作的序列号。然后，Elasticsearch 可以使用操作的序列号来确保较新的文档版本不会被分配给它的序列号较小的变更所覆盖。 例如，下面的索引命令将创建一个文档，并为其分配一个初始序列号和主要词： PUT products/_doc/1567 { &quot;product&quot; : &quot;r2d2&quot;, &quot;details&quot; : &quot;A resourceful astromech droid&quot; } 你可以在响应的 _seq_no 和 _primary_term 字段中看到分配的序列号和主要词： { &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;failed&quot;: 0, &quot;successful&quot;: 1 }, &quot;_index&quot;: &quot;products&quot;, &quot;_id&quot;: &quot;1567&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 362, &quot;_primary_term&quot;: 2, &quot;result&quot;: &quot;created&quot; } Elasticsearch 会记录上次更改其存储的每个文档的操作的序列号和主要词。序列号和主要词会在 获取 API 响应的 _seq_no 和 _primary_term 字段中返回： GET products/_doc/1567 返回： { &quot;_index&quot;: &quot;products&quot;, &quot;_id&quot;: &quot;1567&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 362, &quot;_primary_term&quot;: 2, &quot;found&quot;: true, &quot;_source&quot;: { &quot;product&quot;: &quot;r2d2&quot;, &quot;details&quot;: &quot;A resourceful astromech droid&quot; } } 注意：通过设置 seq_no_primary_term 参数，搜索 API 可以返回每个搜索结果的 _seq_no 和 _primary_term。 序列号和主要术语可唯一标识一项更改。通过记下返回的序列号和主要术语，可以确保只有在检索后没有其他更改的情况下才更改文档。这可以通过设置索引 API、更新 API 或删除 API 的 if_seq_no 和 if_primary_term 参数来实现。 例如，下面的索引调用将确保在文档中添加一个标签，而不会丢失描述的任何潜在更改或其他 API 添加的另一个标签： PUT products/_doc/1567?if_seq_no=362&amp;if_primary_term=2 { &quot;product&quot;: &quot;r2d2&quot;, &quot;details&quot;: &quot;A resourceful astromech droid&quot;, &quot;tags&quot;: [ &quot;droid&quot; ] } 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"?refresh","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/refresh","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"选用哪个设置​","type":1,"pageTitle":"?refresh","url":"/docs/elasticsearch-cn/rest_apis/document_apis/refresh#选用哪个设置","content":"除非你有充分的理由等待更改变得可见，否则请始终使用 refresh=false（默认设置）。最简单快捷的选择是从 URL 中省略 refresh 参数。 如果绝对必须让请求所做的更改与请求同步可见，则必须在增加 Elasticsearch 负载（true）和延长响应等待时间（wait_for）之间做出选择。以下几点可以帮助你做出决定： 索引更改的次数越多，wait_for 与 true 相比节省的工作量就越多。如果索引每隔一次 index.refresh_interval 才更改一次，那么 wait_for 不会节省任何工作。 true 会创建效率较低的索引结构（小段），这些小段随后必须合并到效率更高的索引结构（大段）中。也就是说，true 的代价是在创建索引时创建小段，在搜索时搜索小段，以及在合并时创建大段。 切勿连续启动多个 refresh=wait_for 请求。相反，使用 refresh=wait_for 将它们批量合并为一个批量请求，Elasticsearch 会并行启动所有请求，并在所有请求都完成后才返回。 如果将刷新间隔设为 -1，禁用自动刷新，那么使用 refresh=wait_for 的请求将无限期等待，直到某个操作导致刷新。相反，将 index.refresh_interval 设置为比默认值更短的值，如 200ms，会使 refresh=wait_for 的刷新速度更快，但仍会产生低效的分段。 refresh=wait_for 只影响它所在的请求，但通过强制立即刷新，refresh=true 会影响其他正在进行的请求。通常，如果你有一个正在运行的系统，你不想打扰它，那么 refresh=wait_for 是一个较小的修改。 ","version":"Next","tagName":"h2"},{"title":"refresh=wait_for 能强制刷新​","type":1,"pageTitle":"?refresh","url":"/docs/elasticsearch-cn/rest_apis/document_apis/refresh#refreshwait_for-能强制刷新","content":"如果在分片上已经有 index.max_refresh_listeners（默认值为 1000）请求在等待刷新时，收到了 refresh=wait_for 请求，那么该请求的行为将与刷新设置为 true 时的行为一样：它将强制刷新。这样做既能保证 refresh=wait_for 请求返回时，其变更对搜索是可见的，又能防止被阻塞的请求不经检查而占用资源。如果一个请求因为用完了监听器槽而强制刷新，那么它的响应将包含 &quot;forced_refresh&quot;：true。 无论批量请求修改了多少次分区，它们在每个分区上都只占用一个槽位。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"?refresh","url":"/docs/elasticsearch-cn/rest_apis/document_apis/refresh#示例","content":"这将创建一个文档，并立即刷新索引，使其可见： PUT /test/_doc/1?refresh {&quot;test&quot;: &quot;test&quot;} PUT /test/_doc/2?refresh=true {&quot;test&quot;: &quot;test&quot;}  这将创建一个文档，但不会使其在搜索时可见： PUT /test/_doc/3 {&quot;test&quot;: &quot;test&quot;} PUT /test/_doc/4?refresh=false {&quot;test&quot;: &quot;test&quot;}  这将创建一个文档，并等待它在搜索时可见： PUT /test/_doc/4?refresh=wait_for {&quot;test&quot;: &quot;test&quot;}  原文链接 ","version":"Next","tagName":"h2"},{"title":"读写文档","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"简介​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#简介","content":"Elasticsearch 中的每个索引都被划分为分片，每个分片可以有多个副本。这些副本被称为复制组，在添加或删除文档时必须保持同步。如果我们做不到这一点，从一个副本读取的结果就会与从另一个副本读取的结果大相径庭。保持分片副本同步并提供读取服务的过程就是我们所说的数据复制模型。 Elasticsearch 的数据复制模型基于主备份模型，在微软研究院的 PacificA 论文中有详细描述。该模型的基础是复制组中的单个副本作为主分片。其他副本称为副本分片。主分片是所有索引操作的主要入口。它负责验证这些操作并确保其正确性。一旦主分区接受了索引操作，主分区还负责将该操作复制到其他副本。 本节旨在对 Elasticsearch 复制模型进行高层概述，并讨论它对写操作和读操作之间各种交互的影响。 ","version":"Next","tagName":"h2"},{"title":"基本写模型​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#基本写模型","content":"Elasticsearch 中的每个索引操作都会首先通过路由（通常基于文档 ID）解析到一个复制组。一旦确定了复制组，操作就会在内部转发到该组的当前主分区。索引编制的这一阶段被称为协调阶段。 索引的下一个阶段是在主分区上执行的主分区阶段。主分区负责验证操作并将其转发给其他副本。由于副本可能处于离线状态，因此主分片不需要复制到所有副本。相反，Elasticsearch 会维护一个应接收操作的分片副本列表。该列表称为同步副本，由主节点维护。顾名思义，这些是一组 &quot;良好 &quot;的分片副本，它们保证已经处理了所有向用户确认的索引和删除操作。主分片负责维护这一不变性，因此必须将所有操作复制到这一组中的每个副本。 主分区遵循以下基本流程 验证传入的操作，如果结构上无效，则拒绝该操作（例如：有一个对象字段，而该字段应为数字）在本地执行操作，即索引或删除相关文档。这也会验证字段的内容，并在必要时拒绝（例如：关键字值太长，不适合 Lucene 索引）。将操作转发给当前同步副本集中的每个副本。如果有多个副本，则会并行执行。一旦所有同步副本都成功执行了操作并向主副本做出响应，主副本就会向客户端确认请求已成功完成。 每个同步副本在本地执行索引操作，以便拥有一个副本。这个索引阶段就是副本阶段。 这些索引阶段（协调、主要和副本）都是顺序进行的。为实现内部重试，每个阶段的生命周期都包含后续每个阶段的生命周期。例如，协调阶段在每个主阶段（可能分布在不同的主分片上）完成之前不会完成。在同步副本完成本地文档索引并响应副本请求之前，每个主阶段都不会完成。 ","version":"Next","tagName":"h2"},{"title":"失败处理​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#失败处理","content":"在索引编制过程中，很多事情都可能出错：磁盘可能损坏，节点之间可能断开连接，或者某些配置错误可能导致副本上的操作失败，尽管该操作在主节点上是成功的。这些情况并不常见，但主节点必须对此做出响应。 如果主节点本身发生故障，托管主节点的节点将向主节点发送相关消息。索引操作将等待（默认情况下最长 1 分钟）主节点将其中一个副本提升为主节点。然后，操作将被转发到新的主服务器进行处理。请注意，主节点还会监控节点的健康状况，并可能决定主动降级主节点。这种情况通常发生在持有主节点的节点因网络问题与集群隔离时。更多详情，参阅此处。 在主节点上成功执行操作后，主节点在副本分片上执行操作时必须处理潜在的故障。这可能是由于副本上的实际故障，也可能是由于网络问题导致操作无法到达副本（或副本无法响应）。所有这些情况的最终结果都是一样的：作为同步副本集一部分的副本会错过即将确认的操作。为了避免违反不变式，主节点会向主节点发送信息，要求将有问题的分片从同步副本集中移除。只有当主节点确认删除分块后，主节点才会确认该操作。请注意，主节点还会指示另一个节点开始构建新的分片副本，以便将系统恢复到健康状态。 在向副本转发操作时，主节点将使用副本来验证自己是否仍是活动主节点。如果主控因网络分区（或长时间 GC）而被隔离，它可能会在意识到自己已被降级之前继续处理传入的索引操作。来自过期主节点的操作将被副本拒绝。当主节点收到副本因其不再是主节点而拒绝其请求的响应时，它就会与主节点联系，并得知自己已被替换。然后，操作将被路由到新的主节点。 ","version":"Next","tagName":"h2"},{"title":"如果没有副本会怎样？​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#如果没有副本会怎样","content":"这是一种有效的情况，可能是由于索引配置，也可能仅仅是因为所有副本都失败了。在这种情况下，主分片会在没有任何外部验证的情况下处理操作，这看起来可能会有问题。另一方面，主分片无法自行使其他分片失效，只能请求主分片代其失效。这意味着主分片知道主分片是唯一的一个良好副本。因此，我们可以保证主分区不会将任何其他（过时的）分区副本提升为新的主分区，并且任何索引到主分区的操作都不会丢失。当然，由于此时我们只使用单一数据副本，物理硬件问题可能会导致数据丢失。参阅活动分片了解一些缓解方案。 ","version":"Next","tagName":"h3"},{"title":"基本读取模型​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#基本读取模型","content":"Elasticsearch 中的读取可以是非常轻量级的 ID 查找，也可以是需要消耗大量 CPU 性能的复杂聚合搜索请求。主备份模型的优点之一是，它能使所有分片副本保持一致（飞行中的操作除外）。因此，一个同步副本就足以满足读取请求。 当一个节点收到读取请求时，该节点负责将其转发给持有相关分片的节点，整理响应并回复客户端。我们称该节点为该请求的协调节点。基本流程如下： 将读取请求解析到相关分片。请注意，由于大多数搜索都会发送到一个或多个索引，因此通常需要从多个分片读取数据，每个分片代表不同的数据子集。从分片复制组中选择每个相关分片的活动副本。这可以是主副本，也可以是副本。默认情况下，Elasticsearch 使用自适应副本选择来选择分片副本。向所选副本发送分片级读取请求。合并结果并做出响应。请注意，在通过 ID 查找获取的情况下，只有一个分片是相关的，因此可以跳过这一步。 ","version":"Next","tagName":"h2"},{"title":"分片失败​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#分片失败","content":"当分片无法响应读取请求时，协调节点会将请求发送到同一复制组中的另一个分片副本。重复故障会导致没有可用的分片副本。 为确保快速响应，如果一个或多个分片发生故障，以下 API 将响应部分结果： 搜索多重搜索多重获取 包含部分结果的响应仍提供 200 OK HTTP 状态代码。分片失败由响应头的 timed_out 和 _shards 字段表示。 ","version":"Next","tagName":"h3"},{"title":"几个简单的影响​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#几个简单的影响","content":"这些基本流程中的每一个都决定了 Elasticsearch 作为一个系统在读取和写入时的行为方式。此外，由于读取和写入请求可以同时执行，因此这两个基本流程会相互影响。这就产生了一些固有的影响： 高效读取​ 在正常运行情况下，每个相关复制组只执行一次读操作。只有在故障情况下，同一分片的多个副本才会执行相同的搜索。 读取未确认​ 由于主分区首先在本地建立索引，然后复制请求，因此并发读取有可能在确认之前就已看到更改。 默认双副本​ 这种模式可以容错，同时只维护两个数据副本。这与基于法定人数的系统形成鲜明对比，后者的容错副本最少为 3 份。 ","version":"Next","tagName":"h3"},{"title":"失败​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#失败","content":"在故障情况下，可能出现以下情况： ","version":"Next","tagName":"h2"},{"title":"单个分区会降低索引速度​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#单个分区会降低索引速度","content":"由于主分区在每次操作过程中都会等待同步副本集中的所有副本，因此单个慢分区会拖慢整个复制组的速度。这就是我们为上述读取效率付出的代价。当然，单个慢分区也会拖慢路由到它的不幸搜索。 ","version":"Next","tagName":"h3"},{"title":"脏读​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#脏读","content":"孤立的主分区可能会暴露出不被确认的写入。造成这种情况的原因是，被隔离的主分片只有在向其副本发送请求或与主分片联系时才会意识到自己被隔离了。此时，操作已被编入主索引，可以通过并发读取进行读取。Elasticsearch 通过每秒 ping 一次主索引（默认情况下）以及在不知道主索引的情况下拒绝索引操作来降低这种风险。 ","version":"Next","tagName":"h3"},{"title":"冰山一角​","type":1,"pageTitle":"读写文档","url":"/docs/elasticsearch-cn/rest_apis/document_apis/replication#冰山一角","content":"本文档提供了 Elasticsearch 如何处理数据的高层概述。当然，引擎盖下还有更多工作要做。主条件、集群状态发布和主选举等都对系统的正常运行起着重要作用。本文档也不包括已知和重要的 bug（包括已关闭和开放的）。我们认识到 GitHub 很难跟上时代的步伐。为了帮助大家了解这些问题，我们在网站上维护了一个专门的弹性页面。我们强烈建议您阅读该页面。 原文链接 ","version":"Next","tagName":"h2"},{"title":"词向量 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#请求","content":"GET /&lt;index&gt;/_termvectors/&lt;_id&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有目标索引或索引别名的 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#描述","content":"你可以检索索引中存储的文档或请求体中传递的人工文档的词向量。 你可以通过 fields 参数或在请求体中添加字段来指定你感兴趣的字段。 GET /my-index-000001/_termvectors/1?fields=message  可使用通配符指定字段，类似于多重匹配查询。 词向量默认是实时的，而不是接近实时的。可以通过将 realtime 参数设置为 false 来更改。 你可以请求三种类型的值：词信息、词统计和字段统计。默认情况下，会返回所有字段的所有词信息和字段统计信息，但词统计信息不包括在内。 ","version":"Next","tagName":"h2"},{"title":"词信息​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#词信息","content":"字段中的词频（总是返回）词位置（position : true）开始和结束偏移量（offsets ：true）词的有效载荷（payloads : true），以 base64 编码字节形式返回 如果所请求的信息没有存储在索引中，则会在可能的情况下即时计算。此外，词向量还可以针对不在索引中，而由用户提供的文档进行计算。 警告 开始和结束偏移量假定使用的是 UTF-16 编码。如果要使用这些偏移量来获取生成此标记（token）的原始文本，则应确保所获取的子字符串也是使用 UTF-16 编码的。 ","version":"Next","tagName":"h3"},{"title":"词统计​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#词统计","content":"将 term_statistics 设置为 true（默认为 false）将返回 总词频（词在所有文档中出现的频率）文档频率（包含当前词的文档数量） 默认情况下不返回这些值，因为词统计会严重影响性能。 ","version":"Next","tagName":"h3"},{"title":"字段统计​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#字段统计","content":"将 field_statistics 设置为 false（默认为 true）将省略 ： 文档计数（有多少文档包含此字段）文档频率合计（该字段中所有术语的文档频率总和）总词频合计（该字段中每个词的总词频总和） ","version":"Next","tagName":"h3"},{"title":"词过滤​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#词过滤","content":"利用参数 filter，还可以根据术语的 tf-idf 分数对返回的词进行过滤。这对于找出文档的良好特征向量非常有用。该功能的工作方式类似类似于此查询的第二阶段。用法见示例 5。 支持以下子参数： \tmax_num_terms\t每个字段必须返回的最大词数。默认为 25。 min_term_freq\t忽略源文档中频率低于此值的单词。默认为 1。 max_term_freq\t忽略源文档中频率超过此值的单词。默认为无限制。 min_doc_freq\t忽略至少在这么多文档中没有出现的词。默认为 1。 max_doc_freq\t忽略在超过此数量的文档中出现的单词。默认为无限制。 min_word_length\t最小单词长度，低于此长度的词将被忽略。默认为 0。 max_word_length\t最大单词长度，超过此长度的词将被忽略。默认为无约束 (0)。 ","version":"Next","tagName":"h3"},{"title":"行为​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#行为","content":"词和字段统计不准确。未考虑已删除的文档。只检索请求文档所在分区的信息。因此，词和字段统计数据只能作为相对指标，绝对的数字在此情况下没有任何意义。默认情况下，在请求人工文档的词向量时，会随机选择一个分区来获取统计数据。请仅使用 routing 来选择特定的分区。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#路径参数","content":"&lt;index&gt; (必填，字符串）包含文档的索引名称。 &lt;_id&gt; (可选，字符串） 文档的唯一标识符。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#查询参数","content":"fields (可选，字符串） 用逗号分隔的字段列表或通配符表达式，这些字段将包含在统计信息中。 除非在 completion_fields 或 fielddata_fields 参数中提供了特定字段列表，否则将作为默认列表使用。 field_statistics (可选，布尔值） 如果为 true，响应将包括文档计数、文档频率总和以及词总频率总和。默认为 true。 &lt;offsets&gt; (可选，布尔值） 如果为 true，则响应包括词偏移。默认为 true。 payloads (可选，布尔值） 如果为 true，则响应包括词有效载荷。默认为 true。 positions (可选，布尔值） 如果为 true，则响应包括词位置。默认为 true。 preference (可选，字符串） 指定应在哪个节点或分片上执行操作。默认为随机。 routing (可选，字符串） 用于将操作路由到特定分区的自定义值。 realtime (可选，布尔值） 如果为 true，则表示请求是实时的，而不是近实时的。默认为 true。参阅实时。 term_statistics (可选，布尔值）如果为 true，则响应包括词频和文档频率。默认为 false。 version (可选，布尔值） 如果为 true，则返回作为命中一部分的文档版本。 version_type (可选，枚举值） 特定版本类型：external、external_gte。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#示例","content":"","version":"Next","tagName":"h2"},{"title":"返回存储的词向量​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#返回存储的词向量","content":"首先，我们创建一个索引，用于存储词向量、有效载荷等： PUT /my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;text&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;term_vector&quot;: &quot;with_positions_offsets_payloads&quot;, &quot;store&quot; : true, &quot;analyzer&quot; : &quot;fulltext_analyzer&quot; }, &quot;fullname&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;term_vector&quot;: &quot;with_positions_offsets_payloads&quot;, &quot;analyzer&quot; : &quot;fulltext_analyzer&quot; } } }, &quot;settings&quot; : { &quot;index&quot; : { &quot;number_of_shards&quot; : 1, &quot;number_of_replicas&quot; : 0 }, &quot;analysis&quot;: { &quot;analyzer&quot;: { &quot;fulltext_analyzer&quot;: { &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;whitespace&quot;, &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;type_as_payload&quot; ] } } } } }  其次，我们添加一些文件： PUT /my-index-000001/_doc/1 { &quot;fullname&quot; : &quot;John Doe&quot;, &quot;text&quot; : &quot;test test test &quot; } PUT /my-index-000001/_doc/2?refresh=wait_for { &quot;fullname&quot; : &quot;Jane Doe&quot;, &quot;text&quot; : &quot;Another test ...&quot; }  以下请求将返回文档 1（John Doe）中字段文本的所有信息和统计数据： GET /my-index-000001/_termvectors/1 { &quot;fields&quot; : [&quot;text&quot;], &quot;offsets&quot; : true, &quot;payloads&quot; : true, &quot;positions&quot; : true, &quot;term_statistics&quot; : true, &quot;field_statistics&quot; : true }  响应： { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;took&quot;: 6, &quot;term_vectors&quot;: { &quot;text&quot;: { &quot;field_statistics&quot;: { &quot;sum_doc_freq&quot;: 4, &quot;doc_count&quot;: 2, &quot;sum_ttf&quot;: 6 }, &quot;terms&quot;: { &quot;test&quot;: { &quot;doc_freq&quot;: 2, &quot;ttf&quot;: 4, &quot;term_freq&quot;: 3, &quot;tokens&quot;: [ { &quot;position&quot;: 0, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 4, &quot;payload&quot;: &quot;d29yZA==&quot; }, { &quot;position&quot;: 1, &quot;start_offset&quot;: 5, &quot;end_offset&quot;: 9, &quot;payload&quot;: &quot;d29yZA==&quot; }, { &quot;position&quot;: 2, &quot;start_offset&quot;: 10, &quot;end_offset&quot;: 14, &quot;payload&quot;: &quot;d29yZA==&quot; } ] } } } } }  ","version":"Next","tagName":"h3"},{"title":"即时生成词向量​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#即时生成词向量","content":"未明确存储在索引中的词向量会自动计算。下面的请求会返回文档 1 中字段的所有信息和统计数据，即使这些词没有明确存储在索引中。请注意，对于字段文本，不会重新生成词。 GET /my-index-000001/_termvectors/1 { &quot;fields&quot; : [&quot;text&quot;, &quot;some_field_without_term_vectors&quot;], &quot;offsets&quot; : true, &quot;positions&quot; : true, &quot;term_statistics&quot; : true, &quot;field_statistics&quot; : true }  ","version":"Next","tagName":"h3"},{"title":"人工文档​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#人工文档","content":"术语向量也可以为人工文档（即索引中不存在的文档）生成。例如，以下请求将返回与例 1 相同的结果。使用的映射由 index 决定。 如果开启了动态映射（默认），则将动态创建原始映射中没有的文档字段。 GET /my-index-000001/_termvectors { &quot;doc&quot; : { &quot;fullname&quot; : &quot;John Doe&quot;, &quot;text&quot; : &quot;test test test&quot; } }  每字段分析器​ 此外，还可以使用 per_field_analyzer 参数提供与字段分析器不同的分析器。这对于以任何方式生成词向量都很有用，尤其是在使用人工文档时。当为一个已经存储了词向量的字段提供分析器时，词向量将被重新生成。 GET /my-index-000001/_termvectors { &quot;doc&quot; : { &quot;fullname&quot; : &quot;John Doe&quot;, &quot;text&quot; : &quot;test test test&quot; }, &quot;fields&quot;: [&quot;fullname&quot;], &quot;per_field_analyzer&quot; : { &quot;fullname&quot;: &quot;keyword&quot; } }  响应： { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_version&quot;: 0, &quot;found&quot;: true, &quot;took&quot;: 6, &quot;term_vectors&quot;: { &quot;fullname&quot;: { &quot;field_statistics&quot;: { &quot;sum_doc_freq&quot;: 2, &quot;doc_count&quot;: 4, &quot;sum_ttf&quot;: 4 }, &quot;terms&quot;: { &quot;John Doe&quot;: { &quot;term_freq&quot;: 1, &quot;tokens&quot;: [ { &quot;position&quot;: 0, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 8 } ] } } } } }  ","version":"Next","tagName":"h3"},{"title":"词过滤​","type":1,"pageTitle":"词向量 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/termvectors#词过滤-1","content":"最后，可以根据 tf-idf 分数对返回的术语进行筛选。在下面的示例中，我们从具有给定 “plot” 字段值的人工文档中获取了三个最“有趣”的关键词。请注意，关键词 “Tony” 或任何停止词都不在响应之列，因为它们的 tf-idf 分数必然过低。 GET /imdb/_termvectors { &quot;doc&quot;: { &quot;plot&quot;: &quot;When wealthy industrialist Tony Stark is forced to build an armored suit after a life-threatening incident, he ultimately decides to use its technology to fight against evil.&quot; }, &quot;term_statistics&quot;: true, &quot;field_statistics&quot;: true, &quot;positions&quot;: false, &quot;offsets&quot;: false, &quot;filter&quot;: { &quot;max_num_terms&quot;: 3, &quot;min_term_freq&quot;: 1, &quot;min_doc_freq&quot;: 1 } }  响应： { &quot;_index&quot;: &quot;imdb&quot;, &quot;_version&quot;: 0, &quot;found&quot;: true, &quot;term_vectors&quot;: { &quot;plot&quot;: { &quot;field_statistics&quot;: { &quot;sum_doc_freq&quot;: 3384269, &quot;doc_count&quot;: 176214, &quot;sum_ttf&quot;: 3753460 }, &quot;terms&quot;: { &quot;armored&quot;: { &quot;doc_freq&quot;: 27, &quot;ttf&quot;: 27, &quot;term_freq&quot;: 1, &quot;score&quot;: 9.74725 }, &quot;industrialist&quot;: { &quot;doc_freq&quot;: 88, &quot;ttf&quot;: 88, &quot;term_freq&quot;: 1, &quot;score&quot;: 8.590818 }, &quot;stark&quot;: { &quot;doc_freq&quot;: 44, &quot;ttf&quot;: 47, &quot;term_freq&quot;: 1, &quot;score&quot;: 9.272792 } } } } }  原文链接 ","version":"Next","tagName":"h3"},{"title":"按查询更新 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#请求","content":"POST /&lt;target&gt;/_update_by_query ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有目标索引或索引别名的以下 索引权限： read index 或 write ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#描述","content":"您可以使用与搜索 API 相同的语法，在请求 URI 或请求正文中指定查询条件。 当你提交查询更新请求时，Elasticsearch 会在开始处理请求时获取数据流或索引的快照，并使用 internal 版本更新匹配的文档。当版本匹配时，文档就会更新，版本号也会递增。如果文档在快照拍摄和更新操作处理之间发生变化，则会导致版本冲突，操作失败。您可以选择计算版本冲突，而不是通过设置 conflicts 为 proceed 来停止和返回。请注意，如果您选择计算版本冲突，操作可能会尝试更新超过 max_docs 的源文档，直到它成功更新了 max_docs 文档，或完成了源查询中的所有文档。 提示 版本等于 0 的文档无法使用查询更新进行更新，因为 internal 版本管理不支持将 0 作为有效的版本号。 在处理查询更新请求时，Elasticsearch 会按顺序执行多个搜索请求，以找到所有匹配文档。每一批匹配文档都会执行一次批量更新请求。任何查询或更新失败都会导致查询更新请求失败，失败信息会显示在响应中。任何成功完成的更新请求仍然有效，不会回滚。 ","version":"Next","tagName":"h2"},{"title":"刷新分片​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#刷新分片","content":"一旦请求完成，指定 refresh 参数就会刷新所有分片。这与更新 API 的 refresh 参数不同，后者只会刷新收到请求的分片。与更新 API 不同的是，它不支持 wait_for。 ","version":"Next","tagName":"h3"},{"title":"异步运行查询更新​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#异步运行查询更新","content":"如果请求中包含 wait_for_completion=false，Elasticsearch 会执行一些预检检查，启动请求，并返回一个任务，你可以用它来取消或获取任务的状态。Elasticsearch 会在 .tasks/task/${taskId} 中创建该任务的文档记录。 ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#等待活动分片","content":"wait_for_active_shards控制的是，在继续处理请求之前，必须有多少份分片处于活动状态。参阅活动分片了解详情。timeout 控制每个写入请求等待不可用的分区变为可用的时间。两者的工作方式与批量 API 中的工作方式完全相同。查询更新使用滚动搜索，因此也可以指定 scroll 参数来控制搜索上下文的有效时间，例如：?scroll=10m。默认值为 5 分钟。 ","version":"Next","tagName":"h3"},{"title":"限制更新请求​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#限制更新请求","content":"要控制通过查询进行更新操作的速度，可以将 requests_per_second 设置为任意正数小数。这会为每个批次添加等待时间，以控制更新速率。如果将 requests_per_second 设置为 -1，则禁用节流。 节流会在批次之间使用等待时间，这样内部滚动请求的超时时间就会考虑到请求填充时间。填充时间是批次大小除以 requests_per_second 与写入时间之差。默认情况下，批次大小为 1000，因此如果将 requests_per_second 设置为 500，则批次大小为 1000： target_time = 1000 / 500 per second = 2 seconds wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds  由于批处理是以单个 _bulk 请求的形式发出的，因此大容量的批处理会导致 Elasticsearch 创建许多请求，并在开始下一组请求之前等待。这就是“突发（bursty）”而非“平稳（smooth）”。 ","version":"Next","tagName":"h3"},{"title":"切片​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#切片","content":"查询更新支持分片滚动，以并行处理更新过程。这不仅能提高效率，还能方便地将请求分解成更小的部分。 将 slices 设置为 auto，可为大多数数据流和索引选择合理的数量。如果要手动分片或以其他方式调整自动分片，请记住以下几点： 当 slices 等于索引或后备索引中的分片数时，查询性能最为高效。如果这个数字很大（例如 500），请选择一个较小的数字，因为过多的分片会降低性能。设置高于 slices 的分片通常不会提高效率，反而会增加开销。更新性能与可用资源的分片数呈线性关系。 在运行时间内，查询还是更新性能占主导地位取决于重新索引的文档和集群资源。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#路径参数","content":"allow_no_indices(可选，布尔值）如果为 false，则如果任何通配符表达式、索引别名或 _all 值仅针对丢失或关闭的索引，请求将返回错误。即使请求以其他开放索引为目标，该行为也适用。例如，如果某个索引以 foo 开头，但没有以 bar 开头的索引，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 analyzer(可选，字符串） 用于查询字符串的分析器。 该参数只能在指定 q 查询字符串参数时使用。 analyze_wildcard(可选，布尔值） 如果为 true，则分析通配符和前缀查询。默认为 false。 该参数只能在指定 q 查询字符串参数时使用。 conflicts(可选，字符串） 如果查询更新遇到版本冲突，将如何处理：abort 或 proceed。默认为 abort。 default_operator(可选，字符串）查询字符串的默认运算符：AND 或 OR。默认为 OR。 该参数只能在指定 q 查询字符串参数时使用。 df(可选，字符串）查询字符串中未给出字段前缀时作为默认字段使用的字段。 该参数只能在指定 q 查询字符串参数时使用。 expand_wildcards(可选，字符串） 通配符模式可匹配的索引类型。如果请求以数据流为目标，该参数将决定通配符表达式是否匹配隐藏的数据流。支持逗号分隔值，如 open,hidden。有效值为 all匹配任何数据流或索引，包括隐藏的数据流或索引。 open匹配打开的非隐藏索引。也可匹配任何非隐藏数据流。 closed匹配封闭的非隐藏索引。也匹配任何非隐藏数据流。数据流不能关闭。 hidden匹配隐藏数据流和隐藏索引。必须与打开、关闭或两者结合使用。 none不接受通配符模式。 默认为 open。 ignore_unavailable(可选，布尔值）如果为 false，则如果请求的目标索引丢失或关闭，则返回错误。默认为 false。 lenient(可选，布尔值）如果为 true，查询字符串中基于格式的查询失败（例如为数字字段提供文本）将被忽略。默认为 false。 该参数只能在指定 q 查询字符串参数时使用。 max_docs(可选，整数）要处理的最大文件数。默认为所有文档。当设置的值小于或等于 scroll_size 时，将不会使用滚动来检索操作结果。 pipeline(可选，字符串）用于预处理传入文档的管道 ID。如果索引指定了默认摄取管道，则将该值设为 _none 会禁用此请求的默认摄取管道。如果配置了最终管道，无论此参数的值如何，它都将始终运行。 preference(可选，字符串） 指定应在哪个节点或分片上执行操作。默认为随机。 q(可选，字符串） Lucene 查询字符串语法中的查询。 request_cache(可选，布尔值） 如果为 true，则该请求将使用请求缓存。默认为索引级设置。 refresh(可选，布尔值）如果为 true，Elasticsearch 会刷新受影响的分片，使操作在搜索中可见。默认为 false。 requests_per_second(可选，整数）该请求的节流阀，单位为每秒子请求数。默认为 -1（无节流）。 routing(可选，字符串） 用于将操作路由到特定分区的自定义值。 scroll(可选，时间单位）在滚动时保留搜索上下文的时间段。参阅滚动搜索结果）在滚动时保留搜索上下文。 scroll_size(可选，整数）支持操作的滚动请求大小。默认为 1000。 search_type(可选，字符串） 搜索操作的类型。可用选项： - `query_then_fetch` - `dfs_query_then_fetch` search_timeout(可选，时间单位）每次搜索请求的明确超时。默认为无超时。 slices(可选，整数）该任务应划分的子任务数。默认为 1，表示任务不被分割成子任务。 sort(可选，字符串）以逗号分隔的 &lt;field&gt;:&lt;direction&gt; 对列表。 stats(可选，字符串）请求的特定 tag，用于记录和统计。 terminate_after(可选，整数）每个分片要收集的最大文档数。如果查询达到此限制，Elasticsearch 会提前终止查询。Elasticsearch 会在排序前收集文档。 :::danger 重要 谨慎使用。Elasticsearch 会将此参数应用于处理请求的每个分片。在可能的情况下，让 Elasticsearch 自动执行提前终止。如果请求的目标数据流带有跨多个数据层的备份索引，则应避免指定此参数。 ::: timeout(可选，时间单位） 每个更新请求等待以下操作的周期： - 动态映射更新 - [等待活动分片](/rest_apis/document_apis/docs_index#活动分片) 默认为 1m（一分钟）。这保证 Elasticsearch 在失败前至少等待超时时间。实际等待时间可能会更长，尤其是发生多次等待时。 version(可选，布尔） 如果为 true，则返回作为命中一部分的文档版本。 wait_for_active_shards(可选，字符串） 进行操作前必须激活的分片副本数量。设置为 all 或任何正整数，最多不超过索引中的分片总数（number_of_replicas+1）。默认值：1，主分区。 参阅活动分片。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#请求体","content":"q(可选，查询对象）指定要使用查询 DSL 更新的文档。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#响应体","content":"took整个操作从开始到结束的毫秒数。timed_out如果在通过查询执行更新期间执行的任何请求超时，该标志将被设置为 true。total成功处理的文件数量。updated成功更新的文件数量。deleted成功删除的文件数量。batches通过查询更新拉回的滚动响应数。version_conflicts查询更新所遇到的版本冲突的数量。noops由于查询更新使用的脚本返回的 ctx.op 值为 noop 而被忽略的文档数量。retries批量操作重试次数，搜索操作重试次数。throttled_millis请求符合 requests_per_second 要求所需的毫秒数。requests_per_second查询更新期间每秒有效执行的请求数。throttled_until_millis在 _update_by_query 响应中，该字段应始终等于零。它只有在使用任务 API 时才有意义，因为它表示下一次再次执行节流请求的时间（以毫秒为单位，自纪元起算），以符合 requests_per_second 的要求。failures失败数组（如果在处理过程中出现无法恢复的错误）。如果该数组为非空，则请求会因为这些错误而中止。查询更新是通过批次实现的。任何故障都会导致整个流程中止，但当前批次中的所有故障都会被收集到数组中。可以使用 conflicts 选项来防止重新索引在版本冲突时中止。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#示例","content":"_update_by_query 的最简单用法是在不更改源的情况下对数据流或索引中的每个文档执行更新。这对于获取新属性或其他在线映射变化非常有用。 要更新选定的文档，请在请求正文中指定一个查询： 要更新选定的文档，请在请求正文中指定一个查询： POST my-index-000001/_update_by_query?conflicts=proceed { &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } } }  &quot;query&quot;: {：查询必须作为值传递给查询键，传递方式与搜索 API 相同。使用 q 参数的方法也与搜索 API 相同。 更新多个数据流或索引中的文件： POST my-index-000001,my-index-000002/_update_by_query  通过查询操作将更新限制在具有特定路由值的分区上： POST my-index-000001/_update_by_query?routing=1  默认情况下，通过查询更新使用的滚动批次为 1000。您可以使用 scroll_size 参数更改批次大小： POST my-index-000001/_update_by_query?scroll_size=100  使用唯一属性更新文档。 POST my-index-000001/_update_by_query { &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } }, &quot;max_docs&quot;: 1 }  ","version":"Next","tagName":"h2"},{"title":"更新文档源​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#更新文档源","content":"查询更新支持更新文档源的脚本。例如，以下请求会增加 my-index-000001 中 user.id 为 kimchy 的所有文档的计数字段： POST my-index-000001/_update_by_query { &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source.count++&quot;, &quot;lang&quot;: &quot;painless&quot; }, &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } } }  请注意，本例中没有指定 conflicts=proceed。在这种情况下，版本冲突应停止进程，以便处理故障。 与更新 API 一样，您可以设置 ctx.op 来更改执行的操作： noop：如果脚本认为不需要进行任何更改，则设置 ctx.op = &quot;noop&quot;。通过查询更新操作会跳过更新文档，并递增 noop 计数器。 delete：如果脚本决定删除文档，则设置 ctx.op = &quot;delete&quot;。通过查询更新操作会删除文档并递增已删除计数器。 查询更新仅支持 update、noop 和 delete。将 ctx.op 设置为其他任何值都会导致错误。在 ctx 中设置任何其他字段都会出错。此 API 只允许修改匹配文档的源文件，不能移动它们。 ","version":"Next","tagName":"h3"},{"title":"使用录入管道更新文档​","type":1,"pageTitle":"按查询更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update_by_query#使用录入管道更新文档","content":"通过查询更新可以通过指定管道使用摄取管道功能： PUT _ingest/pipeline/set-foo { &quot;description&quot; : &quot;sets foo&quot;, &quot;processors&quot; : [ { &quot;set&quot; : { &quot;field&quot;: &quot;foo&quot;, &quot;value&quot;: &quot;bar&quot; } } ] } POST my-index-000001/_update_by_query?pipeline=set-foo  通过查询操作获取更新状态编辑​ 您可以使用任务 API 通过查询请求获取所有正在运行的更新的状态： GET _tasks?detailed=true&amp;actions=*byquery  响应如下： { &quot;nodes&quot; : { &quot;r1A2WoRbTwKZ516z6NEs5A&quot; : { &quot;name&quot; : &quot;r1A2WoR&quot;, &quot;transport_address&quot; : &quot;127.0.0.1:9300&quot;, &quot;host&quot; : &quot;127.0.0.1&quot;, &quot;ip&quot; : &quot;127.0.0.1:9300&quot;, &quot;attributes&quot; : { &quot;testattr&quot; : &quot;test&quot;, &quot;portsfile&quot; : &quot;true&quot; }, &quot;tasks&quot; : { &quot;r1A2WoRbTwKZ516z6NEs5A:36619&quot; : { &quot;node&quot; : &quot;r1A2WoRbTwKZ516z6NEs5A&quot;, &quot;id&quot; : 36619, &quot;type&quot; : &quot;transport&quot;, &quot;action&quot; : &quot;indices:data/write/update/byquery&quot;, &quot;status&quot; : { &quot;total&quot; : 6154, &quot;updated&quot; : 3500, &quot;created&quot; : 0, &quot;deleted&quot; : 0, &quot;batches&quot; : 4, &quot;version_conflicts&quot; : 0, &quot;noops&quot; : 0, &quot;retries&quot;: { &quot;bulk&quot;: 0, &quot;search&quot;: 0 }, &quot;throttled_millis&quot;: 0 }, &quot;description&quot; : &quot;&quot; } } } } }  该对象包含实际状态。total 是 reindex 预计执行的操作总数。您可以通过添加 updated、 created 和 deleted 字段来估算进度。当它们的总和等于 total 字段时，请求就会完成。 使用任务 ID 可以直接查找任务。下面的示例检索了任务 r1A2WoRbTwKZ516z6NEs5A:36619 的信息： GET /_tasks/r1A2WoRbTwKZ516z6NEs5A:36619  此 API 的优势在于它与 wait_for_completion=false 集成，可以透明地返回已完成任务的状态。如果任务已完成，且对其设置了 wait_for_completion=false，则会返回 results 或 error 字段。此功能的代价是，wait_for_completion=false 会在 .tasks/task/${taskId} 创建一个文档。您可以自行删除该文档。 取消查询更新操作​ 可以使用任务取消 API 取消任何查询更新操作： POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel  任务 ID 可通过任务 API 找到。 任务取消应该很快，但可能需要几秒钟。上面的任务状态 API 将继续列出查询任务的更新，直到该任务检查到它已被取消并自行终止。 更改请求的节流​ 可以使用 _rethrottle API 在运行中的查询更新任务上更改 requests_per_second 的值： POST _update_by_query/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1  任务 ID 可通过任务 API 找到。 就像在 _update_by_query API 上设置一样，requests_per_second 可以是 -1 表示禁用节流，也可以是 1.7 或 12 等任何十进制数表示节流到该水平。加快查询速度的重节流会立即生效，但减慢查询速度的重节流会在完成当前批次后生效。这样可以防止滚动超时。 手动切片​ 通过向每个请求提供分片 ID 和分片总数，手动对查询更新进行分片： POST my-index-000001/_update_by_query { &quot;slice&quot;: { &quot;id&quot;: 0, &quot;max&quot;: 2 }, &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source['extra'] = 'test'&quot; } } POST my-index-000001/_update_by_query { &quot;slice&quot;: { &quot;id&quot;: 1, &quot;max&quot;: 2 }, &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source['extra'] = 'test'&quot; } }  您可以验证它是否有效： GET _refresh POST my-index-000001/_search?size=0&amp;q=extra:test&amp;filter_path=hits.total  这就产生了像这样一个合理的总数： { &quot;hits&quot;: { &quot;total&quot;: { &quot;value&quot;: 120, &quot;relation&quot;: &quot;eq&quot; } } }  使用自动切片​ 还可以使用分片滚动对 _id 进行分片，让查询更新自动并行化。使用 slices 指定要使用的分片数： POST my-index-000001/_update_by_query?refresh&amp;slices=5 { &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source['extra'] = 'test'&quot; } }  您也可以验证它是否有效： POST my-index-000001/_search?size=0&amp;q=extra:test&amp;filter_path=hits.total  这就产生了像这样一个合理的 total： { &quot;hits&quot;: { &quot;total&quot;: { &quot;value&quot;: 120, &quot;relation&quot;: &quot;eq&quot; } } }  将 slices 设置为 auto，Elasticsearch 就可以选择要使用的分片数量。此设置将在一定限制内对每个分片使用一个分片。如果有多个源数据流或索引，它会根据分片数量最少的索引或后备索引来选择分片数量。 在 _update_by_query 中添加 slices 只是将上一节中使用的手动过程自动化，创建子请求，这意味着它有一些怪异之处： 您可以在任务 API 中看到这些请求。这些子请求是带 slices 请求任务的 “子”任务。获取带 slices 请求的任务状态只包含已完成分片的状态。这些子任务可单独处理，如取消和重加速。重新加速 slices 请求会按比例重新加速未完成的子请求。使用 slices 取消请求将取消每个子请求。由于 slices 的特性，每个子请求不会得到完全平均的文件。所有文件都会被处理，但有些分片可能比其他分片大。预计较大的分片分布会更均匀。slices 请求的 requests_per_second 和 max_docs 等参数会按比例分配给每个子请求。结合上文关于分布不均的观点，你应该得出结论：使用 max_docs 和 slices 可能不会导致更新的文档数正好达到 max_docs 文档。每个子请求获取的源数据流或索引快照都略有不同，尽管这些快照都是在大致相同的时间获取的。 获取新属性​ 假设你创建了一个没有动态映射的索引，将数据填入其中，然后添加一个映射值，从数据中拾取更多的字段： PUT test { &quot;mappings&quot;: { &quot;dynamic&quot;: false, &quot;properties&quot;: { &quot;text&quot;: {&quot;type&quot;: &quot;text&quot;} } } } POST test/_doc?refresh { &quot;text&quot;: &quot;words words&quot;, &quot;flag&quot;: &quot;bar&quot; } POST test/_doc?refresh { &quot;text&quot;: &quot;words words&quot;, &quot;flag&quot;: &quot;foo&quot; } PUT test/_mapping { &quot;properties&quot;: { &quot;text&quot;: {&quot;type&quot;: &quot;text&quot;}, &quot;flag&quot;: {&quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;keyword&quot;} } }  &quot;dynamic&quot;: false,：这意味着新字段不会被编入索引，只会存储在 _source 中。PUT test/_mapping：这将更新映射以添加新的 flag 字段。要使用新字段，必须重新索引所有包含该字段的文档。 搜索数据什么也找不到： POST test/_search?filter_path=hits.total { &quot;query&quot;: { &quot;match&quot;: { &quot;flag&quot;: &quot;foo&quot; } } }  { &quot;hits&quot; : { &quot;total&quot;: { &quot;value&quot;: 0, &quot;relation&quot;: &quot;eq&quot; } } }  但您可以发出 _update_by_query 请求来获取新的映射： POST test/_update_by_query?refresh&amp;conflicts=proceed POST test/_search?filter_path=hits.total { &quot;query&quot;: { &quot;match&quot;: { &quot;flag&quot;: &quot;foo&quot; } } }  { &quot;hits&quot; : { &quot;total&quot;: { &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; } } }  在多字段中添加字段时，也可以执行完全相同的操作。 原文链接 ","version":"Next","tagName":"h3"},{"title":"索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引管理​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#索引管理","content":"创建索引删除索引获取索引索引存在关闭索引开启索引收缩索引拆分索引复制索引翻转冻结索引解冻索引解析索引 ","version":"Next","tagName":"h2"},{"title":"映射管理​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#映射管理","content":"更新映射获取映射获取字段映射类型存在 ","version":"Next","tagName":"h2"},{"title":"别名管理​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#别名管理","content":"别名创建或更新索引别名获取索引别名索引别名存在删除索引别名 ","version":"Next","tagName":"h2"},{"title":"索引设置​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#索引设置","content":"更新索引设置获取索引设置分析 ","version":"Next","tagName":"h2"},{"title":"索引模板​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#索引模板","content":"索引模板自动为新索引应用设置、映射以及别名。他们通常用于为时序数据配翻转索引，以确保每个新索引与前一个索引有相同的配置。关联到数据流的索引模板配置了它的和备份指示符。获取更多信息，参阅索引模板。 创建或更新索引模板获取索引模板删除索引模板创建或更新组件模板获取组件模板删除组件模板模拟索引模拟模板 ","version":"Next","tagName":"h2"},{"title":"监测​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#监测","content":"索引统计索引段索引恢复索引分片存储 ","version":"Next","tagName":"h2"},{"title":"状态管理​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#状态管理","content":"清除缓存刷新冲刷同步冲刷强制合并 ","version":"Next","tagName":"h2"},{"title":"悬空索引​","type":1,"pageTitle":"索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/#悬空索引","content":"列出悬空索引导入悬空索引删除悬空索引 原文链接 ","version":"Next","tagName":"h2"},{"title":"更新 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#请求","content":"POST /&lt;index&gt;/_update/&lt;_id&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有目标索引或索引别名的 index 或 write 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#描述","content":"使您能够编写文档更新脚本。脚本可以更新、删除或跳过修改文档。更新 API 还支持传递部分文档，并将其合并到现有文档中。要完全替换现有文档，请使用索引 API。 此操作： 从索引中获取文档（与分片对应）。运行指定的脚本。对结果建立索引。 文档仍需重新索引，但使用 update 可以减少一些网络往返，并降低 GET 和索引操作之间发生版本冲突的几率。 要使用 update，必须启用 _source 字段。除了 _source 外，还可以通过 ctx 映射访问以下变量：_index、_type、_id、_version、_routing 和 _now（当前时间戳）。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#路径参数","content":"&lt;index&gt;(必需，字符串）目标索引的名称。默认情况下，如果索引不存在，则会自动创建。有关详细信息，请参阅自动创建数据流和索引。&lt;_id&gt;(字符串）要更新文档的唯一标识符。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#查询参数","content":"if_seq_no(可选，整数）只有当文档具有此序列号时才执行操作。请参阅乐观并发控制。 if_primary_term(可选，整数）只有在文档具有该主要术语时才执行操作。请参阅乐观并发控制。 lang(可选，字符串）脚本语言。默认：painless。 require_alias(可选，布尔）如果为 true，则目标地址必须是索引别名。默认为 false。 refresh(可选，枚举）如果为 true，Elasticsearch 会刷新受影响的分片，使该操作在搜索中可见；如果为 wait_for，则等待刷新，使该操作在搜索中可见；如果为 false，则不刷新。有效值：true、false、wait_for。默认值：false。 retry_on_conflict(可选，整数）指定当冲突发生时，操作应重试多少次。默认值：0。 routing(可选，字符串）用于将操作路由到特定分区的自定义值。 _source(可选，列表）设置为 false 可禁用源检索（默认值：true）。您还可以指定一个以逗号分隔的列表，其中包含您要检索的字段。 _source_excludes(可选，列表）指定要排除的源字段。 _source_includes(可选，列表）指定要检索的源字段。 timeout(可选，时间单位）下列操作的等待时间： 动态映射更新等待活动分片默认为 1m（一分钟）。这可保证 Elasticsearch 在失败前至少等待超时时间。实际等待时间可能会更长，尤其是发生多次等待时。 wait_for_active_shards(可选，字符串）继续操作前必须激活的分片副本数量。设置为全部或任何正整数，最多不超过索引中的分片总数（number_of_replicas+1）。默认值：1，主分区。 参阅活动分片。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#示例","content":"首先，让我们为一个简单的文档编制索引： PUT test/_doc/1 { &quot;counter&quot; : 1, &quot;tags&quot; : [&quot;red&quot;] }  要递增计数器，可使用以下脚本提交更新请求： POST test/_update/1 { &quot;script&quot; : { &quot;source&quot;: &quot;ctx._source.counter += params.count&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot; : { &quot;count&quot; : 4 } } }  同样，您也可以使用更新脚本将标签添加到标签列表中（这只是一个列表，因此即使标签存在也会被添加）： POST test/_update/1 { &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source.tags.add(params.tag)&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot;: { &quot;tag&quot;: &quot;blue&quot; } } }  您还可以从标签列表中移除一个标签。remove 标签的无感函数会获取要移除元素的数组索引。为避免可能出现的运行时错误，首先要确保标签存在。如果列表中包含重复的标签，脚本只会删除其中一个。 POST test/_update/1 { &quot;script&quot;: { &quot;source&quot;: &quot;if (ctx._source.tags.contains(params.tag)) { ctx._source.tags.remove(ctx._source.tags.indexOf(params.tag)) }&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot;: { &quot;tag&quot;: &quot;blue&quot; } } }  您还可以添加或删除文档中的字段。例如，该脚本添加了 new_field 字段： POST test/_update/1 { &quot;script&quot; : &quot;ctx._source.new_field = 'value_of_new_field'&quot; }  相反，该脚本会删除字段 new_field： POST test/_update/1 { &quot;script&quot; : &quot;ctx._source.remove('new_field')&quot; }  下面的脚本将从对象字段中删除一个子字段： POST test/_update/1 { &quot;script&quot;: &quot;ctx._source['my-object'].remove('my-subfield')&quot; }  您也可以更改脚本中执行的操作，而不是更新文档。例如，如果 tags 字段包含 green，该请求将删除文档，否则什么也不做（noop）： POST test/_update/1 { &quot;script&quot;: { &quot;source&quot;: &quot;if (ctx._source.tags.contains(params.tag)) { ctx.op = 'delete' } else { ctx.op = 'noop' }&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot;: { &quot;tag&quot;: &quot;green&quot; } } }  ","version":"Next","tagName":"h2"},{"title":"更新文件的一部分​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#更新文件的一部分","content":"下面的部分更新在现有文档中添加了一个新字段： POST test/_update/1 { &quot;doc&quot;: { &quot;name&quot;: &quot;new_name&quot; } }  如果同时指定 doc 和 script，则 doc 将被忽略。如果指定脚本更新，请在脚本中包含要更新的字段。 ","version":"Next","tagName":"h3"},{"title":"检测无更新​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#检测无更新","content":"默认情况下，不改变任何内容的更新会检测到它们没有改变任何内容，并返回 &quot;result&quot;: &quot;noop&quot;： POST test/_update/1 { &quot;doc&quot;: { &quot;name&quot;: &quot;new_name&quot; } }  如果 name 的值已经是 new_name，更新请求将被忽略，响应中的 result 元素将返回 noop： { &quot;_shards&quot;: { &quot;total&quot;: 0, &quot;successful&quot;: 0, &quot;failed&quot;: 0 }, &quot;_index&quot;: &quot;test&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 2, &quot;_primary_term&quot;: 1, &quot;_seq_no&quot;: 1, &quot;result&quot;: &quot;noop&quot; }  您可以通过设置 &quot;detect_noop&quot;: false 来禁用此行为： POST test/_update/1 { &quot;doc&quot;: { &quot;name&quot;: &quot;new_name&quot; }, &quot;detect_noop&quot;: false }  ","version":"Next","tagName":"h3"},{"title":"更新插入​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#更新插入","content":"如果文档不存在，upsert 元素的内容将作为新文档插入。如果文档存在，则执行 script： POST test/_update/1 { &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source.counter += params.count&quot;, &quot;lang&quot;: &quot;painless&quot;, &quot;params&quot;: { &quot;count&quot;: 4 } }, &quot;upsert&quot;: { &quot;counter&quot;: 1 } }  ","version":"Next","tagName":"h3"},{"title":"脚本式更新插入​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#脚本式更新插入","content":"要在文档是否存在的情况下运行脚本，请将 scripted_upsert 设置为 true： POST test/_update/1 { &quot;scripted_upsert&quot;: true, &quot;script&quot;: { &quot;source&quot;: &quot;&quot;&quot; if ( ctx.op == 'create' ) { ctx._source.counter = params.count } else { ctx._source.counter += params.count } &quot;&quot;&quot;, &quot;params&quot;: { &quot;count&quot;: 4 } }, &quot;upsert&quot;: {} }  ","version":"Next","tagName":"h3"},{"title":"文档作为更新插入​","type":1,"pageTitle":"更新 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/update#文档作为更新插入","content":"您可以将 doc_as_upsert 设为 true，使用 doc 的内容作为 upsert 值，而不是发送部分 doc 和 upsert doc： POST test/_update/1 { &quot;doc&quot;: { &quot;name&quot;: &quot;new_name&quot; }, &quot;doc_as_upsert&quot;: true }  提示 不支持将摄入管道与 doc_as_upsert 结合使用。 原文链接 ","version":"Next","tagName":"h3"},{"title":"别名存在 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/alias_exists","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"别名存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/alias_exists#请求","content":"HEAD _alias/&lt;alias&gt; HEAD &lt;target&gt;/_alias/&lt;alias&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"别名存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/alias_exists#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须对索引有 view_index_metadata 或 manage 索引权限。如果你指定一个目标，你必须对目标也有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"别名存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/alias_exists#路径参数","content":"&lt;alias&gt; （可选，字符串）以逗号分隔的待检查的别名列表。支持通配符（*）。 &lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流或索引。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"别名存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/alias_exists#查询参数","content":"expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 all。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"别名存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/alias_exists#响应码","content":"200 所有指定的别名都存在。 404 一个或多个指定的别名不存在。 原文链接 ","version":"Next","tagName":"h2"},{"title":"重索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#请求","content":"POST /_reindex ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#前置条件","content":"如果启用了 Elasticsearch 安全功能，则必须拥有以下安全权限： 用于源数据流、索引或索引别名的 read 索引权限。用于目标数据流、索引或索引别名的 write 索引权限。要通过重索引 API 请求自动创建数据流或索引，您必须拥有目标数据流、索引或别名的 auto_configure、create_index 或 manage 索引权限。如果从远程集群重索引，则 source.remote.user 必须拥有 monitor 集群权限和 read 源数据流、索引或别名的索引权限。 如果从远程集群重索引，必须在 elasticsearch.yml 的 reindex.remote.whitelist 设置中明确允许远程主机。参阅从远程重索引。自动创建数据流需要启用数据流的匹配索引模板。参阅设置数据流。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#描述","content":"从源索引中提取文档源，并将文档索引到目标索引中。你可以将所有文档复制到目标索引，也可以重新索引文档的一个子集。 与 _update_by_query 一样，_reindex 也会获取源的快照，但其目标必须不同，因此不太可能发生版本冲突。dest 元素可以像索引 API 一样进行配置，以控制乐观并发控制。省略 version_type 或将其设置为 internal 会导致 Elasticsearch 盲目地将文档转储到目标中，并覆盖任何碰巧具有相同 ID 的文档。 将 version_type 设置为 external 会导致 Elasticsearch 保留源文件中的版本，创建任何丢失的文档，并更新目标文件中版本比源文件中版本旧的文档。 将 op_type 设置为 create 会导致 _reindex 只创建目标中缺失的文档。所有现有文档都将导致版本冲突。 重要 由于数据流是仅附加的，因此对目标数据流的任何重新索引请求的 op_type 都必须是 create。重新索引只能向目标数据流添加新文档。它不能更新目标数据流中的现有文档。 默认情况下，版本冲突会中止 _reindex 进程。要在存在冲突的情况下继续重新索引，可将“conflicts”请求正文参数设置为 proceed。在这种情况下，响应将包括遇到的版本冲突的计数。请注意，其他错误类型的处理不受“conflicts”参数的影响。此外，如果选择对版本冲突进行计数，操作可能会尝试重新索引超过 max_docs 的源文档，直到成功将 max_docs 文档索引到目标中，或者完成源查询中的所有文档。 ","version":"Next","tagName":"h2"},{"title":"异步运行重索引​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#异步运行重索引","content":"如果请求中包含 wait_for_completion=false，Elasticsearch 会执行一些预检检查，启动请求，并返回一个任务，你可以用它来取消或获取任务的状态。Elasticsearch 会在 _tasks/&lt;task_id&gt; 中以文档形式创建该任务的记录。 ","version":"Next","tagName":"h3"},{"title":"从多个来源重新索引​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#从多个来源重新索引","content":"如果有许多源要重新索引，通常最好一次一个地重新索引，而不是使用 glob 模式来获取多个源。这样，如果出现错误，就可以删除部分完成的源代码，重新开始。这也使得并行处理变得相当简单：拆分要重新索引的源列表，然后并行运行每个列表。 一次性的 bash 脚本似乎就能很好地解决这个问题： for index in i1 i2 i3 i4 i5; do curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{ &quot;source&quot;: { &quot;index&quot;: &quot;'$index'&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;'$index'-reindexed&quot; } }' done  ","version":"Next","tagName":"h3"},{"title":"节流​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#节流","content":"将 requests_per_second 设置为任意十进制正数（1.4、6、1000 等），以控制 _reindex 发布成批索引操作的速度。通过为每个批次添加等待时间来节流请求。要禁用节流，请将 requests_per_second 设置为 -1。 节流是通过在批次之间等待来实现的，这样 _reindex 内部使用的 scroll 就可以获得一个考虑了填充时间的超时。填充时间是批次大小除以每秒请求数与写入时间之差。默认情况下，批量大小为 1000，因此，如果将 requests_per_second 设置为 500，如下： target_time = 1000 / 500 per second = 2 seconds wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds  由于批处理是以单个 _bulk 请求的形式发出的，因此大容量的批处理会导致 Elasticsearch 创建许多请求，然后等待一段时间再开始下一组请求。这就是“突发”而非“平滑”。 ","version":"Next","tagName":"h3"},{"title":"重新节流​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#重新节流","content":"可以使用 _rethrottle API 在运行中的重索引上更改 requests_per_second 的值： POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1  任务 ID 可通过任务 API 找到。 就像在重索引 API 上设置一样，request_per_second 可以是 -1 表示禁用节流，也可以是 1.7 或 12 等任何十进制数表示节流到该水平。加快查询速度的节流立即生效，但减慢查询速度的节流将在完成当前批次后生效。这样可以防止滚动超时。 ","version":"Next","tagName":"h3"},{"title":"切片​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#切片","content":"重索引支持分片滚动，以并行处理重新索引过程。这种并行化可以提高效率，并为将请求分解成更小的部分提供方便。 注意 从远程群集重索引不支持手动或自动分片。 手动切片​ 通过为每个请求提供分片 ID 和分片总数，手动对重新索引请求进行分片： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;slice&quot;: { &quot;id&quot;: 0, &quot;max&quot;: 2 } }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } } POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;slice&quot;: { &quot;id&quot;: 1, &quot;max&quot;: 2 } }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  你可以通过以下方式验证其工作原理： GET _refresh POST my-new-index-000001/_search?size=0&amp;filter_path=hits.total  这样就得出了这样一个合理的总数： { &quot;hits&quot;: { &quot;total&quot; : { &quot;value&quot;: 120, &quot;relation&quot;: &quot;eq&quot; } } }  自动切片​ 你也可以使用切片滚动 对 _id 进行切分，让 _reindex 自动并行化。使用分片指定要使用的分片数量： POST _reindex?slices=5&amp;refresh { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  你还可以通过以下方式验证其工作原理： POST my-new-index-000001/_search?size=0&amp;filter_path=hits.total  这样就得出了这样一个合理的总数： { &quot;hits&quot;: { &quot;total&quot; : { &quot;value&quot;: 120, &quot;relation&quot;: &quot;eq&quot; } } }  将 slices 设置为 auto，Elasticsearch 就可以选择要使用的切片数量。此设置将在一定限制内对每个分片使用一个切片。如果有多个来源，它会根据分片数量最少的索引或后备索引来选择切片数量。 在 _reindex 中添加切片只是将上一节中使用的手动流程自动化，创建子请求，这意味着它有一些怪异之处： 您可以在任务 API 中看到这些请求。这些子请求是带 slices 请求任务的“子”任务。获取带 slices 请求的任务状态只包含已完成切片的状态。这些子任务可单独处理，如取消和重新节流。重新节流 slices 请求会按比例重新加速未完成的子请求。取消 slices 请求将取消每个子请求。由于 slices 的特性，每个子请求不会得到完全平均的文件。所有文件都会被处理，但有些切片可能比其他切片大。预计较大的切片分布会更均匀。slices 请求的 requests_per_second 和 max_docs 等参数会按比例分配给每个子请求。结合上面关于分布不均的观点，你应该得出结论：使用带 slices 的 max_docs 可能不会导致精确的 max_docs 文档被重索引。每个子请求获得的源快照略有不同，尽管这些快照都是在大致相同的时间获取的。 选择切片数量​ 如果是自动切片，将 slices 设置为 auto 会为大多数索引选择合理的切片数。如果手动分片或以其他方式调整自动分片，请使用以下指南。 当切片数等于索引中的分片数时，查询性能最为高效。如果这个数字很大（如 500），请选择较低的数字，因为过多的 slices 会影响性能。将切片数设置得高于分片数一般不会提高效率，反而会增加开销。 索引性能与可用资源的 slices 数量成线性关系。 在运行时间内，查询性能还是索引性能占主导地位取决于重新索引的文档和集群资源。 ","version":"Next","tagName":"h3"},{"title":"重新索引路由​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#重新索引路由","content":"默认情况下，如果 _reindex 看到一个带有路由的文档，那么除非脚本更改，否则路由将被保留。你可以在目标请求中设置路由来更改路由： keep将为每个匹配发送的批量请求上的路由设置为匹配上的路由。这是默认值。discard将为每个匹配发送的批量请求的路由设置为空。=&lt;文本&gt;将为每个匹配发送的批量请求的路由设置为 = 后面的所有文本。 例如，你可以使用以下请求将 source 的公司名称为 cat 的所有文件复制到 dest，并将路由设置为 cat。 POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;source&quot;, &quot;query&quot;: { &quot;match&quot;: { &quot;company&quot;: &quot;cat&quot; } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;dest&quot;, &quot;routing&quot;: &quot;=cat&quot; } }  默认情况下，_reindex 使用的滚动批次为 1000。您可以使用 source 元素中的 size 字段更改批次大小： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;source&quot;, &quot;size&quot;: 100 }, &quot;dest&quot;: { &quot;index&quot;: &quot;dest&quot;, &quot;routing&quot;: &quot;=cat&quot; } }  ","version":"Next","tagName":"h3"},{"title":"使用摄取管道重索引​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#使用摄取管道重索引","content":"重索引也可以使用摄取管道功能，方法是像这样指定一个 pipeline： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;source&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;dest&quot;, &quot;pipeline&quot;: &quot;some_ingest_pipeline&quot; } }  ","version":"Next","tagName":"h3"},{"title":"查询参数​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#查询参数","content":"refresh (可选，布尔值）如果为 true，Elasticsearch 会刷新受影响的分片，使操作在搜索中可见。默认为 false。 timeout (可选，时间单位） 每个更新请求等待以下操作的周期： 自动创建索引 动态映射更新 等待活动分片 默认为 1m（一分钟）。这保证 Elasticsearch 在失败前至少等待超时时间。实际等待时间可能会更长，尤其是发生多次等待时。 wait_for_active_shards(可选，字符串） 进行操作前必须激活的分片副本数量。设置为 all 或任何正整数，最多不超过索引中的分片总数（number_of_replicas+1）。默认值：1，主分区。 参阅活动分片。 wait_for_completion (可选，布尔） 如果为 true，则请求会阻塞，直到操作完成。默认为 true。 requests_per_second (可选，整数）该请求的节流阀，单位为每秒子请求数。默认为 -1（无节流）。 require_alias （可选，布尔值）如果为 true，则目标必须是索引别名。默认为false。 scroll （可选，时间值）指定滚动搜索时索引的一致视图应保持多长时间。 slices (可选，整数）该任务应划分的子任务数。默认为 1，表示任务不被分割成子任务。 max_docs (可选，整数）要处理的最大文件数。默认为所有文档。当设置的值小于或等于 scroll_size 时，将不会使用滚动来检索操作结果。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#请求体","content":"conflicts (可选，字符串） 如果查询更新遇到版本冲突，将如何处理：abort 或 proceed。默认为 abort。 max_docs (可选，整数）要重新索引的最大文档数。如果 conflicts 等于 proceed，重索引会尝试重新索引比 max_docs 更多的源文档，直到它成功地将 max_docs 文档索引到目标中，或索引完源查询中的所有文档。 source index (必填，字符串）要复制的数据流、索引或别名的名称。也接受逗号分隔的列表，以便从多个来源重新索引。 query (可选，查询对象）使用 Query DSL 指定要删除的文档。 remote host (可选，字符串）要从 Elasticsearch 编制索引的远程实例的 URL。从远程建立索引时必须使用。 username (可选，字符串） 用于远程主机身份验证的用户名。 password (可选，字符串） 用于远程主机身份验证的密码。 socket_timeout (可选，时间单位） 远程套接字读取超时。默认为 30 秒。 connect_timeout (可选，时间单位） 远程连接超时。默认为 30 秒。 headers (可选，对象）包含请求标头的对象。 size （可选，整数） 每个批次要索引的文档数。在远程索引时使用，以确保批次适合堆上缓冲区（默认最大为 100 MB）。 slice id (可选，整数）用于手动切片的切片 ID。 max (可选，整数）切片总数。 sort (可选，列表）以逗号分隔的 &lt;字段&gt;:&lt;方向&gt; 对列表，索引前按其排序。与 max_docs 结合使用可控制重新索引哪些文档。 警告 7.6 弃用重新索引中的排序已被弃用。在重索引中排序永远不能保证按顺序索引文档，而且会阻碍重索引的进一步发展，如弹性和性能改进。如果与 max_docs 结合使用，请考虑使用查询过滤器。 _source (可选，字符串）如果为 true，则重新索引所有源字段。如果设置为列表，则会重新索引所选字段。默认为 true。 dest index (必填，字符串） 复制到的数据流、索引或索引别名的名称。 version_type (可选，枚举）索引操作要使用的版本。有效值：internal、external、external_gt、external_gte。更多信息，参阅版本类型。 op_type (可选，枚举）设置为 `create` 时，只对尚未存在的文档建立索引（即不存在时创建）。有效值：`index`、`create`。默认为 `index`。 重要 要重新索引到数据流目标，参数必须为 create。 pipeline (可选，字符串）要使用的管道名称。 script source (可选，字符串）重新索引时要运行的更新文档源或元数据的脚本。 lang (可选，枚举）脚本语言：painless、expression、mustache、java。更多信息，参阅脚本。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#响应体","content":"took (整数）全部操作花的总毫秒。 timed_out (布尔值) 如果在重新索引过程中执行的任何请求超时，该标志将被设置为 true。 total (整数）成功处理的文件数。 updated (整数）成功更新的文档数，即在重新索引更新之前，具有相同 ID 的文档已经存在。 created (整数）成功创建的文件数。 deleted (整数）成功删除的文件数。 batches (整数）通过重新索引拉回的滚动响应数。 noops (整数）由于用于重新索引的脚本为 ctx.op 返回了 noop 值而被忽略的文件数。 version_conflicts (整数）重新索引遇到的版本冲突的数量。 retries (整数） 重索引尝试重试的次数，bulk 是重试批量操作的次数，search 是重试搜索操作的次数。 throttled_millis (整数）为符合 requests_per_second 要求而等待的毫秒数。 requests_per_second (整数）重新索引期间每秒有效执行的请求数。 throttled_until_millis (整数）在 _reindex 响应中，该字段应始终等于零。它只有在使用任务 API 时才有意义，因为它表示下一次再次执行节流请求的时间（以毫秒为单位，从Epoch 开始），以符合 requests_per_second 的要求。 failures (数组)失败数组，表示在处理过程中出现了无法恢复的错误。如果该数组非空，则请求会因为这些故障而中止。重新索引是通过批次实现的，任何故障都会导致整个流程中止，但当前批次中的所有故障都会被收集到数组中。可以使用 conflicts 选项来防止重新索引因版本冲突而中止。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#示例","content":"","version":"Next","tagName":"h2"},{"title":"使用查询重新索引所选文件​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#使用查询重新索引所选文件","content":"你可以通过在 source 中添加查询来限制文档。例如，下面的请求只将 user.id 为 kimchy 的文档复制到 my-new-index-000001 中： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  ","version":"Next","tagName":"h3"},{"title":"使用 max_docs 重索引所选文件​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#使用-max_docs-重索引所选文件","content":"你可以通过设置 max_docs 来限制处理的文档数量。例如，此请求将单个文档从 my-index-000001 复制到 my-new-index-000001： POST _reindex { &quot;max_docs&quot;: 1, &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  ","version":"Next","tagName":"h3"},{"title":"从多个源重索引​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#从多个源重索引","content":"源中的 index 属性可以是一个列表，这样就可以在一次请求中从多个源复制文件。这将从 my-index-000001 和 my-index-000002 索引中复制文件： POST _reindex { &quot;source&quot;: { &quot;index&quot;: [&quot;my-index-000001&quot;, &quot;my-index-000002&quot;] }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000002&quot; } }  提示 重索引 API 不会努力处理 ID 冲突，因此最后写入的文档将“获胜”，但顺序通常无法预测，因此依赖这种行为并不是一个好主意。相反，可以使用脚本确保 ID 的唯一性。 ","version":"Next","tagName":"h3"},{"title":"使用源过滤器重索引选择字段​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#使用源过滤器重索引选择字段","content":"你可以使用源过滤重索引原始文档中的子集字段。例如，以下请求只重新索引每个文档的 user.id 和 _doc 字段： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;_source&quot;: [&quot;user.id&quot;, &quot;_doc&quot;] }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  ","version":"Next","tagName":"h3"},{"title":"重索引以更改字段名称​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#重索引以更改字段名称","content":"_reindex 可以用来建立一个带有重命名字段的索引副本。假设你创建了一个包含如下文档的索引： POST my-index-000001/_doc/1?refresh { &quot;text&quot;: &quot;words words&quot;, &quot;flag&quot;: &quot;foo&quot; }  但你不喜欢名称标志，想用标签来代替它。_reindex 可以为你创建另一个索引： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; }, &quot;script&quot;: { &quot;source&quot;: &quot;ctx._source.tag = ctx._source.remove(\\&quot;flag\\&quot;)&quot; } }  现在你可以获取新文件了： GET my-new-index-000001/_doc/1  将返回： { &quot;found&quot;: true, &quot;_id&quot;: &quot;1&quot;, &quot;_index&quot;: &quot;my-new-index-000001&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 44, &quot;_primary_term&quot;: 1, &quot;_source&quot;: { &quot;text&quot;: &quot;words words&quot;, &quot;tag&quot;: &quot;foo&quot; } }  ","version":"Next","tagName":"h3"},{"title":"重新索引每日指数​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#重新索引每日指数","content":"你可以将 _reindex 与 Painless 结合使用，重新索引每日索引，将新模板应用到现有文档中。 假设你的索引包含以下文档： PUT metricbeat-2016.05.30/_doc/1?refresh {&quot;system.cpu.idle.pct&quot;: 0.908} PUT metricbeat-2016.05.31/_doc/1?refresh {&quot;system.cpu.idle.pct&quot;: 0.105}  用于 metricbeat-* 索引的新模板已经加载到 Elasticsearch 中，但它只适用于新创建的索引。可以使用 Painless 重新索引现有文档并应用新模板。 下面的脚本会从索引名称中提取日期，并创建一个附加 -1 的新索引。metricbeat-2016.05.31 中的所有数据都将被重新索引到 metricbeat-2016.05.31-1 中。 POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;metricbeat-*&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;metricbeat&quot; }, &quot;script&quot;: { &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;ctx._index = 'metricbeat-' + (ctx._index.substring('metricbeat-'.length(), ctx._index.length())) + '-1'&quot; } }  现在可以在 *-1 索引中找到以前的 metricbeat 索引中的所有文件。 GET metricbeat-2016.05.30-1/_doc/1 GET metricbeat-2016.05.31-1/_doc/1  前一种方法也可与更改字段名称结合使用，以便仅将现有数据加载到新索引中，并根据需要重新命名任何字段。 ","version":"Next","tagName":"h3"},{"title":"提取源的随机子集​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#提取源的随机子集","content":"_reindex 可用于提取源代码的随机子集进行测试： POST _reindex { &quot;max_docs&quot;: 10, &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;query&quot;: { &quot;function_score&quot; : { &quot;random_score&quot; : {}, &quot;min_score&quot; : 0.9 } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  &quot;min_score&quot; : 0.9：你可能需要根据从源数据中提取的相对数据量来调整 min_score。 ","version":"Next","tagName":"h3"},{"title":"在重新索引过程中修改文件​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#在重新索引过程中修改文件","content":"与 _update_by_query 一样，_reindex 也支持修改文档的脚本。与 _update_by_query 不同，允许脚本修改文档的元数据。本示例对源文件的版本进行了修改： POST _reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot;, &quot;version_type&quot;: &quot;external&quot; }, &quot;script&quot;: { &quot;source&quot;: &quot;if (ctx._source.foo == 'bar') {ctx._version++; ctx._source.remove('foo')}&quot;, &quot;lang&quot;: &quot;painless&quot; } }  正如在 _update_by_query 中一样，你可以设置 ctx.op 来更改在目标上执行的操作： noop 如果脚本认为不需要在目标中索引文档，则设置 ctx.op = &quot;noop&quot;。响应体中的 noop 计数器将报告无操作。 delete 如果脚本认为必须从目的地删除文档，请设置 ctx.op = &quot;delete&quot;。删除情况将在响应体中的已删除计数器中报告。 将 ctx.op 设置为任何其他值都会返回错误，设置 ctx 中的任何其他字段也是如此。 想想这些可能性吧！只要小心谨慎，你可以改变的有： _id_index_version_routing 将 _version 设置为空或从 ctx 映射中清除它，就像在索引请求中不发送版本一样；不管目标上的版本是什么，也不管你在 _reindex 请求中使用的版本类型是什么，它都会导致文档在目标中被覆盖。 ","version":"Next","tagName":"h3"},{"title":"从远程重索引​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#从远程重索引","content":"重索引支持从远程 Elasticsearch 集群重新索引： POST _reindex { &quot;source&quot;: { &quot;remote&quot;: { &quot;host&quot;: &quot;http://otherhost:9200&quot;, &quot;username&quot;: &quot;user&quot;, &quot;password&quot;: &quot;pass&quot; }, &quot;index&quot;: &quot;my-index-000001&quot;, &quot;query&quot;: { &quot;match&quot;: { &quot;test&quot;: &quot;data&quot; } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  host 参数必须包含协议、主机、端口（如 https://otherhost:9200）和可选路径（如 https://otherhost:9200/proxy）。username 和 password 参数是可选参数，如果存在这两个参数，_reindex 将使用基本认证连接到远程 Elasticsearch 节点。使用基本认证时，请确保使用 https，否则密码将以纯文本形式发送。有一系列设置可用于配置 https 连接的行为。 使用 Elastic Cloud 时，也可以通过使用有效的 API 密钥对远程集群进行身份验证： POST _reindex { &quot;source&quot;: { &quot;remote&quot;: { &quot;host&quot;: &quot;http://otherhost:9200&quot;, &quot;headers&quot;: { &quot;Authorization&quot;: &quot;ApiKey API_KEY_VALUE&quot; } }, &quot;index&quot;: &quot;my-index-000001&quot;, &quot;query&quot;: { &quot;match&quot;: { &quot;test&quot;: &quot;data&quot; } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  必须在 elasticsearch.yml 中使用 reindex.remote.whitelist 属性明确允许远程主机。可以将其设置为以逗号分隔的允许远程 host 和 port 组合列表。协议会被忽略，只使用主机和端口。例如： reindex.remote.whitelist: &quot;otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*&quot;  允许的主机列表必须配置在任何将协调重新索引的节点上。 此功能应适用于任何版本的 Elasticsearch 远程群集。这样就可以通过从旧版本的群集重新索引，将任何版本的 Elasticsearch 升级到当前版本。 警告 Elasticsearch 不支持跨主要版本的向前兼容性。例如，你无法将 7.x 集群重新索引到 6.x 集群中。 要启用发送到旧版本 Elasticsearch 的查询，查询参数会直接发送到远程主机，无需验证或修改。 注意 从远程集群重新索引不支持手动或自动切片。 从远程服务器重新索引使用堆上缓冲区，默认最大大小为 100MB。如果远程索引包含非常大的文档，则需要使用较小的批量大小。下面的示例将批量大小设置为 10，这是非常非常小的。 POST _reindex { &quot;source&quot;: { &quot;remote&quot;: { &quot;host&quot;: &quot;http://otherhost:9200&quot;, ... }, &quot;index&quot;: &quot;source&quot;, &quot;size&quot;: 10, &quot;query&quot;: { &quot;match&quot;: { &quot;test&quot;: &quot;data&quot; } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;dest&quot; } }  还可以使用 socket_timeout 字段设置远程连接上的套接字读取超时，使用 connect_timeout 字段设置连接超时。两者的默认值都是 30 秒。本例将套接字读取超时设置为一分钟，连接超时设置为 10 秒： POST _reindex { &quot;source&quot;: { &quot;remote&quot;: { &quot;host&quot;: &quot;http://otherhost:9200&quot;, ..., &quot;socket_timeout&quot;: &quot;1m&quot;, &quot;connect_timeout&quot;: &quot;10s&quot; }, &quot;index&quot;: &quot;source&quot;, &quot;query&quot;: { &quot;match&quot;: { &quot;test&quot;: &quot;data&quot; } } }, &quot;dest&quot;: { &quot;index&quot;: &quot;dest&quot; } }  ","version":"Next","tagName":"h2"},{"title":"配置 SSL 参数​","type":1,"pageTitle":"重索引 API","url":"/docs/elasticsearch-cn/rest_apis/document_apis/reindex#配置-ssl-参数","content":"从远程重新索引支持可配置的 SSL 设置。这些设置必须在 elasticsearch.yml 文件中指定，但安全设置除外，因为安全设置是在 Elasticsearch keystore 中添加的。无法在 _reindex 请求的正文中配置 SSL。 支持以下设置： reindex.ssl.certificate_authorities 应受信任的 PEM 编码证书文件的路径列表。不能同时指定 reindex.ssl.certificate_authorities 和 reindex.ssl.truststore.path。 reindex.ssl.truststore.path 包含要信任的证书的 Java 密钥存储文件的路径。密钥存储可以是 “JKS” 或 “PKCS#12” 格式。不能同时指定 reindex.ssl.certificate_authorities 和 reindex.ssl.truststore.path。 reindex.ssl.truststore.password 信任库的密码（reindex.ssl.truststore.path）。[7.17.0]请使用 reindex.ssl.truststore.secure_password 代替。此设置不能与 reindex.ssl.truststore.secure_password 同时使用。 reindex.ssl.truststore.secure_password（安全） 信任存储（reindex.ssl.truststore.path）的密码。此设置不能与 reindex.ssl.truststore.password 一起使用。 reindex.ssl.truststore.type 信任存储的类型（reindex.ssl.truststore.path）。必须是 jks 或 PKCS12。如果信任存储路径以 “.p12”、“.pfx” 或 “pkcs12” 结尾，则默认设置为 PKCS12。否则，默认为 jks。 reindex.ssl.verification_mode 指示验证类型，以防止中间人攻击和证书伪造。可选择 full（验证主机名和证书路径）、certificate（验证证书路径，但不验证主机名）或 none（不执行验证--在生产环境中强烈不建议这样做）。默认为 full。 reindex.ssl.certificate 指定用于 HTTP 客户端身份验证的 PEM 编码证书（或证书链）的路径（如果远程集群需要），此设置要求同时设置 reindex.ssl.key。不能同时指定 reindex.ssl.certificate 和 reindex.ssl.keystore.path。 reindex.ssl.key 指定与用于客户端身份验证的证书（reindex.ssl.certificate）相关的 PEM 编码私钥的路径。不能同时指定 reindex.ssl.key 和 reindex.ssl.keystore.path。 reindex.ssl.key_passphrase如果 PEM 编码私钥（reindex.ssl.key）已加密，则指定用于解密的口令。[7.17.0]请优先使用 reindex.ssl.secure_key_passphrase。不能与 reindex.ssl.secure_key_passphrase 一起使用。 reindex.ssl.secure_key_passphrase（安全） 指定用于解密 PEM 编码私钥（reindex.ssl.key）（如果已加密）的口令。不能与 reindex.ssl.key_passphrase 一起使用。 reindex.ssl.keystore.path 指定包含用于 HTTP 客户端身份验证的私钥和证书的密钥库路径（如果远程群集需要）。该密钥库可以是 &quot;JKS &quot;或 &quot;PKCS#12 &quot;格式。不能同时指定 reindex.ssl.key 和 reindex.ssl.keystore.path。 reindex.ssl.keystore.type 密钥存储的类型（reindex.ssl.keystore.path）。必须是 jks 或 PKCS12。如果密钥库路径以&quot;.p12&quot;、&quot;.pfx &quot;或 &quot;pkcs12 &quot;结尾，则默认为 PKCS12。否则，默认为 jks。 reindex.ssl.keystore.password密钥存储的密码（reindex.ssl.keystore.path）。[7.17.0]请使用 reindex.ssl.keystore.secure_password 代替。此设置不能与 reindex.ssl.keystore.secure_password 同时使用。 reindex.ssl.keystore.secure_password（安全） 密钥存储的密码（reindex.ssl.keystore.path）。此设置不能与 reindex.ssl.keystore.password 一起使用。 reindex.ssl.keystore.key_password 密钥存储（reindex.ssl.keystore.path）中密钥的密码。默认为密钥库密码。[7.17.0]请使用 reindex.ssl.keystore.secure_key_password 代替。此设置不能与 reindex.ssl.keystore.secure_key_password 同时使用。 reindex.ssl.keystore.secure_key_password（安全） 密钥存储（reindex.ssl.keystore.path）中密钥的密码。默认为密钥库密码。此设置不能与 reindex.ssl.keystore.key_password 一起使用。 原文链接 ","version":"Next","tagName":"h3"},{"title":"分析索引磁盘的使用 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze_index_disk_usage","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"分析索引磁盘的使用 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze_index_disk_usage#请求","content":"POST /&lt;target&gt;/_disk_usage ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"分析索引磁盘的使用 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze_index_disk_usage#前置条件","content":"如果 Elasticsearch 安全特性启用，你对指定索引、数据流或别名必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"分析索引磁盘的使用 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze_index_disk_usage#路径参数","content":"&lt;target&gt; （必需，字符串）用于限制请求的，逗号分隔的数据流或索引。推荐使用单个索引（或数据流的最新备份索引）执行此 API，因为 API 会大量消耗资源。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"分析索引磁盘的使用 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze_index_disk_usage#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 flush （可选，布尔值）如果为 true，Elasticsearch 在分析前对索引执行冲刷。如果为 false，响应可能不包含未提交的数据。默认为 true。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 run_expensive_tasks （必需，布尔值）分析字段磁盘使用情况需要大量资源。为了使用此 API，这个参数必须设置为 true。默认为 false。 wait_for_active_shards （可选，字符串）继续操作前必须处于活动状态的分片副本数。设置为 all 或任何正整数，上限为索引中分片的总数（(number_of_replicas+1）。默认为：1，代表主分片。 参阅活动分片。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"分析索引磁盘的使用 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze_index_disk_usage#示例","content":"POST /my-index-000001/_disk_usage?run_expensive_tasks=true  API 返回： { &quot;_shards&quot;: { &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;my-index-000001&quot;: { &quot;store_size&quot;: &quot;929mb&quot;, &quot;store_size_in_bytes&quot;: 974192723, &quot;all_fields&quot;: { &quot;total&quot;: &quot;928.9mb&quot;, &quot;total_in_bytes&quot;: 973977084, &quot;inverted_index&quot;: { &quot;total&quot;: &quot;107.8mb&quot;, &quot;total_in_bytes&quot;: 113128526 }, &quot;stored_fields&quot;: &quot;623.5mb&quot;, &quot;stored_fields_in_bytes&quot;: 653819143, &quot;doc_values&quot;: &quot;125.7mb&quot;, &quot;doc_values_in_bytes&quot;: 131885142, &quot;points&quot;: &quot;59.9mb&quot;, &quot;points_in_bytes&quot;: 62885773, &quot;norms&quot;: &quot;2.3kb&quot;, &quot;norms_in_bytes&quot;: 2356, &quot;term_vectors&quot;: &quot;2.2kb&quot;, &quot;term_vectors_in_bytes&quot;: 2310 }, &quot;fields&quot;: { &quot;_id&quot;: { &quot;total&quot;: &quot;49.3mb&quot;, &quot;total_in_bytes&quot;: 51709993, &quot;inverted_index&quot;: { &quot;total&quot;: &quot;29.7mb&quot;, &quot;total_in_bytes&quot;: 31172745 }, &quot;stored_fields&quot;: &quot;19.5mb&quot;, &quot;stored_fields_in_bytes&quot;: 20537248, &quot;doc_values&quot;: &quot;0b&quot;, &quot;doc_values_in_bytes&quot;: 0, &quot;points&quot;: &quot;0b&quot;, &quot;points_in_bytes&quot;: 0, &quot;norms&quot;: &quot;0b&quot;, &quot;norms_in_bytes&quot;: 0, &quot;term_vectors&quot;: &quot;0b&quot;, &quot;term_vectors_in_bytes&quot;: 0 }, &quot;_primary_term&quot;: {...}, &quot;_seq_no&quot;: {...}, &quot;_version&quot;: {...}, &quot;_source&quot;: { &quot;total&quot;: &quot;603.9mb&quot;, &quot;total_in_bytes&quot;: 633281895, &quot;inverted_index&quot;: {...}, &quot;stored_fields&quot;: &quot;603.9mb&quot;, &quot;stored_fields_in_bytes&quot;: 633281895, &quot;doc_values&quot;: &quot;0b&quot;, &quot;doc_values_in_bytes&quot;: 0, &quot;points&quot;: &quot;0b&quot;, &quot;points_in_bytes&quot;: 0, &quot;norms&quot;: &quot;0b&quot;, &quot;norms_in_bytes&quot;: 0, &quot;term_vectors&quot;: &quot;0b&quot;, &quot;term_vectors_in_bytes&quot;: 0 }, &quot;context&quot;: { &quot;total&quot;: &quot;28.6mb&quot;, &quot;total_in_bytes&quot;: 30060405, &quot;inverted_index&quot;: { &quot;total&quot;: &quot;22mb&quot;, &quot;total_in_bytes&quot;: 23090908 }, &quot;stored_fields&quot;: &quot;0b&quot;, &quot;stored_fields_in_bytes&quot;: 0, &quot;doc_values&quot;: &quot;0b&quot;, &quot;doc_values_in_bytes&quot;: 0, &quot;points&quot;: &quot;0b&quot;, &quot;points_in_bytes&quot;: 0, &quot;norms&quot;: &quot;2.3kb&quot;, &quot;norms_in_bytes&quot;: 2356, &quot;term_vectors&quot;: &quot;2.2kb&quot;, &quot;term_vectors_in_bytes&quot;: 2310 }, &quot;context.keyword&quot;: {...}, &quot;message&quot;: {...}, &quot;message.keyword&quot;: {...} } } }  &quot;store_size&quot;: &quot;929mb&quot;：仅分析索引分片的存储大小。 &quot;total&quot;: &quot;928.9mb&quot;：索引的已分析分片的字段的总大小。这个总数通常小于 &lt;1&gt; 中指定的索引大小，因为一些小的元数据文件被忽略，数据文件的某些部分可能不会被 API 扫描。 &quot;stored_fields&quot;: &quot;19.5mb&quot;：_id 字段的存储大小 &quot;stored_fields&quot;: &quot;603.9mb&quot;：_source 字段的存储大小。由于存储的字段是以压缩格式存储在一起的，因此存储字段的估计大小可能是不准确的。可能低估了 _id 字段的存储大小，而高估了 _source 字段的存储大小。 原文链接 ","version":"Next","tagName":"h2"},{"title":"别名 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#请求","content":"POST /_aliases ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有以下的索引权限： 为了使用 add 或 remove 操作，你必须对所有索引和索引别名有 manage 索引权限。为了使用 remove_index 操作，你必须对索引有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#描述","content":"Elasticsearch 中的 API 在处理指定索引时接受一个索引名，在适用时接受多个索引。索引别名 API 允许为索引添加一个名字，所有 API 自动将别名转换为实际索引名字。别名也可以映射到多个索引，指定别名时别名将自动扩展到别名索引。别名还可以与在搜索和路由值时自动应用的筛选器相关联。别名不能与索引同名。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#查询参数","content":"master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#请求体","content":"actions （必需，操作数组）待执行的操作集合。有效的操作包括： add 为索引添加一个别名 remove 从索引移除一个别名 remove_index 删除具体的索引，类似删除索引 API。尝试移除一个索引别名会失败。 你也可以在别名对象中执行这些操作。别名对象中有效的值包括： index （字符串）用于执行操作的索引名字的通配符表达式。 如果 indices 参数未被指定，此参数是必需的。 提示 你不能向索引别名添加数据流。 indices （数组）用于执行操作的索引名数组。 如果 index 参数未被指定，此参数是必需的。 提示 你不能向索引别名添加数据流。 alias （字符串）待添加、移除或删除的以逗号分隔的列表或通配符表达式的索引别名。支持日期数学。 如果 aliases 参数未被指定，对操作 add 或 remove 此参数是必需的。 aliases （字符串数组）待添加、移除或删除索引别名数组。支持日期数学。 如果 alias 参数未被指定，对操作 add 或 remove 此参数是必需的。 filter （可选，查询对象）过滤器查询用于限制索引别名。 如果指定，索引别名仅用于过滤器返回的文档。 参阅过滤的别名获取示例。 is_hidden （可选，布尔值）如果为 true，默认会从通配符表达式中排除别名，除非通过参数 expand_wildcards 重载请求，类似 隐藏索引。对于共享别名的所有索引，必须将此属性设置为相同的值。默认为 false。 must_exist （可选，布尔值）如果为 true，待移除的别名必须存在。默认为 false。 is_write_index （可选，布尔值）如果为 true，分配此索引作为别名的写索引。默认为 false。 一个别名一次可以有一个写索引。 参阅写索引获取示例。 警告 对一个索引，别名没有显示地设置 is_write_index: true，且只引用了一个索引，那在引用另一个索引之前，引用的索引的行为将与写索引一致。 routing （可选，字符串）用于路由操作到指定分片的自定义值。 参阅路由获取示例。 index_routing （可选，字符串）用于别名索引操作的自定义路由值。 参阅路由获取示例。 search_routing （可选，字符串）用于别名搜索操作的自定义路由值。 参阅路由获取示例。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#示例","content":"","version":"Next","tagName":"h2"},{"title":"添加一个别名​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#添加一个别名","content":"以下请求为索引 test1 添加别名 alias1。 POST /_aliases { &quot;actions&quot; : [ { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } } ] }  索引别名支持日期数学。 POST /_aliases { &quot;actions&quot; : [ { &quot;add&quot; : { &quot;index&quot; : &quot;logs&quot;, &quot;alias&quot; : &quot;&lt;logs_{now/M}&gt;&quot; } } ] }  ","version":"Next","tagName":"h3"},{"title":"移除一个别名​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#移除一个别名","content":"以下请求移除别名 alias1。 POST /_aliases { &quot;actions&quot; : [ { &quot;remove&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } } ] }  ","version":"Next","tagName":"h3"},{"title":"重命名一个别名​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#重命名一个别名","content":"重命名一个别名，简单地在同一个 API 中执行操作 remove（移除）又 add（添加）。这个操作是原子的，不用担心别名会短时间的不指向索引。 POST /_aliases { &quot;actions&quot; : [ { &quot;remove&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } }, { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias2&quot; } } ] }  ","version":"Next","tagName":"h3"},{"title":"向多个索引添加一个别名​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#向多个索引添加一个别名","content":"通过简单的几个操作 add（添加），就能将别名关联到多个索引。 POST /_aliases { &quot;actions&quot; : [ { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;, &quot;alias&quot; : &quot;alias1&quot; } }, { &quot;add&quot; : { &quot;index&quot; : &quot;test2&quot;, &quot;alias&quot; : &quot;alias1&quot; } } ] }  多个索引也可以通过一个操作中的 indices 数组的语法指定： POST /_aliases { &quot;actions&quot; : [ { &quot;add&quot; : { &quot;indices&quot; : [&quot;test1&quot;, &quot;test2&quot;], &quot;alias&quot; : &quot;alias1&quot; } } ] }  为了在一个操作中指定多个别名，相应的 aliases 数组语法也可以使用。 如上示例，匹配模式也可以用于关联一个别名给共享同一个名字的多个索引： POST /_aliases { &quot;actions&quot; : [ { &quot;add&quot; : { &quot;index&quot; : &quot;test*&quot;, &quot;alias&quot; : &quot;all_test_indices&quot; } } ] }  在这种情况下，别名是一个即时别名，它将对所有当前匹配的索引进行分组，与此模式匹配的新索引将被添加或移除时，它不会自动更新。 索引指向多个索引的别名是错误的。 也可以在一个原子操作中用别名交换索引。这意味着在集群状态下，不会有别名指向无索引的时间点。然而，由于索引和搜索涉及多个步骤，因此正在运行或排队的请求可能会由于临时不存在索引而失败。 PUT test PUT test_2 POST /_aliases { &quot;actions&quot; : [ { &quot;add&quot;: { &quot;index&quot;: &quot;test_2&quot;, &quot;alias&quot;: &quot;test&quot; } }, { &quot;remove_index&quot;: { &quot;index&quot;: &quot;test&quot; } } ] }  PUT test 误加的一个索引PUT test_2 准备加的索引{ &quot;remove_index&quot;: { &quot;index&quot;: &quot;test&quot; } } remove_index 类似删除索引，只会移除具体的索引。 ","version":"Next","tagName":"h3"},{"title":"过滤的别名​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#过滤的别名","content":"带过滤器的别名提供了一种简单的方法来创建同一索引的不同“视图”。可以通过查询 DSL 定义过滤器，可应用于使用别名的所有搜索、按查询删除和其他类似操作。 为了创建带过滤器的别名，首先我们需要确认字段已经在映射中存在： PUT /my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;@timestamp&quot;: { &quot;type&quot;: &quot;date&quot; }, &quot;user&quot;: { &quot;properties&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } } } }  现在我们可以在 @timestamp 和 user.id 上创建一个带过滤器的别名： POST /_aliases { &quot;actions&quot;: [ { &quot;add&quot;: { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;alias&quot;: &quot;alias2&quot;, &quot;filter&quot;: { &quot;bool&quot;: { &quot;filter&quot;: [ { &quot;range&quot;: { &quot;@timestamp&quot;: { &quot;gte&quot;: &quot;now-1d/d&quot;, &quot;lt&quot;: &quot;now/d&quot; } } }, { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } } ] } } } } ] }  ","version":"Next","tagName":"h3"},{"title":"路由​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#路由","content":"别名可以关联路由值。此功能可以与筛选别名一起使用，以避免不必要的分片操作。 以下命名创建一个指向索引 test 的新别名 alias1。在 alias1 被创建后，通过此别名的操作都会自动修改为使用值 1 来路由： POST /_aliases { &quot;actions&quot;: [ { &quot;add&quot;: { &quot;index&quot;: &quot;test&quot;, &quot;alias&quot;: &quot;alias1&quot;, &quot;routing&quot;: &quot;1&quot; } } ] }  也可以为搜索和索引操作指定不同的路由值： POST /_aliases { &quot;actions&quot;: [ { &quot;add&quot;: { &quot;index&quot;: &quot;test&quot;, &quot;alias&quot;: &quot;alias2&quot;, &quot;search_routing&quot;: &quot;1,2&quot;, &quot;index_routing&quot;: &quot;2&quot; } } ] }  如上例所示，搜索路由可以包含几个由逗号分隔的值。索引路由可以只包含一个值。 如果使用路由别名的搜索操作也具有路由参数，则使用该参数中指定的搜索别名路由和路由的交集。例如以下的命令中会使用 2 作为路由值： GET /alias2/_search?q=user.id:kimchy&amp;routing=2,3  ","version":"Next","tagName":"h3"},{"title":"写索引​","type":1,"pageTitle":"别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/aliases#写索引","content":"可以将别名指向的索引关联为写索引。当指定时，指向多个索引的别名的所有索引和更新请求都将尝试解析为一个索引，即写入索引。每个别名一次只能分配一个索引作为写索引。如果未指定写索引，并且别名引用了多个索引，则不允许写。 可以使用别名 API 和索引创建 API 将与别名关联的一个索引指定为写索引。将索引设置为具有别名的写索引也会影响在翻转期间如何操作别名（参阅带写索引的翻转）。 POST /_aliases { &quot;actions&quot;: [ { &quot;add&quot;: { &quot;index&quot;: &quot;test&quot;, &quot;alias&quot;: &quot;alias1&quot;, &quot;is_write_index&quot;: true } }, { &quot;add&quot;: { &quot;index&quot;: &quot;test2&quot;, &quot;alias&quot;: &quot;alias1&quot; } } ] }  在这个例子中，我们将别名 alias1 关联到 test 和 test2，而 test 选择作为写索引。 PUT /alias1/_doc/1 { &quot;foo&quot;: &quot;bar&quot; }  索引到 /alias1/_doc/1 的新文档正如它是 /test/_doc/1。 GET /test/_doc/1  要交换别名的哪个索引来作为写索引，可用别名 API 来原子交换。 POST /_aliases { &quot;actions&quot;: [ { &quot;add&quot;: { &quot;index&quot;: &quot;test&quot;, &quot;alias&quot;: &quot;alias1&quot;, &quot;is_write_index&quot;: false } }, { &quot;add&quot;: { &quot;index&quot;: &quot;test2&quot;, &quot;alias&quot;: &quot;alias1&quot;, &quot;is_write_index&quot;: true } } ] }  原文链接 ","version":"Next","tagName":"h3"},{"title":"分析 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#请求","content":"GET /_analyze POST /_analyze GET /&lt;index&gt;/_analyze POST /&lt;index&gt;/_analyze ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#前置条件","content":"如果 Elasticsearch 安全特性启用，你对指定索引必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#路径参数","content":"&lt;index&gt; （可选，字符串）用于产生分析器的索引。 如果指定，&lt;analyzer&gt; 或 &lt;field&gt; 将覆盖此值。 如果没有指定分析器或字段，则分析 API 将为索引使用默认分析器。 如果没有指定索引或索引没有默认分析器，则分析 API 使用标准分析器。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#查询参数","content":"-analyzer （可选，字符串）将用于提供的 text 的分析器的名称。这可以是一个内置分析器，也可以是在索引中配置的分析器。 如果未指定此参数，则分析 API 将使用该字段映射中定义的分析器。 如果没有指定字段，分析 API 将对索引使用默认分析器。 如果没有指定索引，或者索引没有默认分析器，则分析 API 使用标准分析器。 attributes （可选，字符串数组）用于过滤 explain 参数输出的 token（标记）属性数组。 char_filter （可选，字符串数组）在 tokenizer（标记器）之前，预处理字符的字符过滤器数组。参阅字符过滤器参考获知一系列的字符过滤器。 explain （可选，布尔值）如果为 true，响应包含标记的属性和更多详情。默认为 false。【更多详情信息的格式在 Lucene 中被标记为实验性的，将来可能会改变。】 field （可选，字符串）用于导出分析器的字段。要使用该参数，必须指定一个索引。 如果指定，参数 analyzer 将覆盖此值。 如果没有指定字段，分析 API 将对索引使用默认分析器。 如果没有指定索引或索引没有默认分析器，则分析 API 使用标准分析器。 filter （可选，字符串数组）用于在标记器之后应用的标记过滤器数组。参阅标记过滤器参考获知一系列的标记过滤器。 normalizer （可选，字符串）用于将文本转换为单个标记的规范化器。参阅规范化器获知一系列的规范化器。 text （必需，字符串或字符串数组）待分析的文本。如果是字符串数组，会作为多值字段分析。 tokenizer （可选，字符串）标记器，用于将文本转换为标记。参阅标记器获知一系列的标记器。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#示例","content":"","version":"Next","tagName":"h2"},{"title":"未指定索引​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#未指定索引","content":"你可以对文本串应用任何内置分析器，不用指定索引的。 GET /_analyze { &quot;analyzer&quot; : &quot;standard&quot;, &quot;text&quot; : &quot;this is a test&quot; }  ","version":"Next","tagName":"h3"},{"title":"文本串数组​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#文本串数组","content":"如果参数 text 以字符串数组形式提供，它会作为多值字段分析。 GET /_analyze { &quot;analyzer&quot; : &quot;standard&quot;, &quot;text&quot; : [&quot;this is a test&quot;, &quot;the second text&quot;] }  ","version":"Next","tagName":"h3"},{"title":"自定义分析器​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#自定义分析器","content":"你可以使用分析 API 来测试从标记器、标记过滤器和字符过滤器构建的自定义 transient（瞬态）分析器。标记过滤器使用 filter 参数: GET /_analyze { &quot;tokenizer&quot; : &quot;keyword&quot;, &quot;filter&quot; : [&quot;lowercase&quot;], &quot;text&quot; : &quot;this is a test&quot; }  GET /_analyze { &quot;tokenizer&quot; : &quot;keyword&quot;, &quot;filter&quot; : [&quot;lowercase&quot;], &quot;char_filter&quot; : [&quot;html_strip&quot;], &quot;text&quot; : &quot;this is a &lt;b&gt;test&lt;/b&gt;&quot; }  自定义标记器、标记过滤器和字符过滤器可以在请求体中指定，如下所示: GET /_analyze { &quot;tokenizer&quot; : &quot;whitespace&quot;, &quot;filter&quot; : [&quot;lowercase&quot;, {&quot;type&quot;: &quot;stop&quot;, &quot;stopwords&quot;: [&quot;a&quot;, &quot;is&quot;, &quot;this&quot;]}], &quot;text&quot; : &quot;this is a test&quot; }  ","version":"Next","tagName":"h3"},{"title":"指定索引​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#指定索引","content":"你也可以针对特定的索引运行分析 API: GET /analyze_sample/_analyze { &quot;text&quot; : &quot;this is a test&quot; }  上面的代码将使用与索引 analyze_sample 相关联的默认索引分析器，对 “this is a test” 文本进行分析。也可以提供一个 analyzer 来使用与索引所关联不同的分析器: GET /analyze_sample/_analyze { &quot;analyzer&quot; : &quot;whitespace&quot;, &quot;text&quot; : &quot;this is a test&quot; }  ","version":"Next","tagName":"h3"},{"title":"从字段映射导出分析器​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#从字段映射导出分析器","content":"分析器可以基于字段映射来派生，例如: GET /analyze_sample/_analyze { &quot;field&quot; : &quot;obj1.field1&quot;, &quot;text&quot; : &quot;this is a test&quot; }  这将导致基于在 obj1.field1 映射中配置的分析器进行分析(如果没有，则为默认的索引分析器)。 ","version":"Next","tagName":"h3"},{"title":"规范化器​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#规范化器","content":"可以为与索引 analyze_sample 关联的规范化器的关键字字段提供一个 normalizer。 GET /analyze_sample/_analyze { &quot;normalizer&quot; : &quot;my_normalizer&quot;, &quot;text&quot; : &quot;BaR&quot; }  或者通过在标记筛选器和字符过滤器中构建自定义瞬态规范化器。 GET /_analyze { &quot;filter&quot; : [&quot;lowercase&quot;], &quot;text&quot; : &quot;BaR&quot; }  ","version":"Next","tagName":"h3"},{"title":"解释分析​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#解释分析","content":"如果你想获得更高级的细节，请将 explain设置为 true (默认为 false)。它会输出每个标记的所有标记属性。你可以通过设置选项 attributes 来过滤你想输出的标记属性。 提示 更多详情信息的格式在 Lucene 中被标记为实验性的，将来可能会改变。 GET /_analyze { &quot;tokenizer&quot; : &quot;standard&quot;, &quot;filter&quot; : [&quot;snowball&quot;], &quot;text&quot; : &quot;detailed output&quot;, &quot;explain&quot; : true, &quot;attributes&quot; : [&quot;keyword&quot;] }  &quot;attributes&quot; : [&quot;keyword&quot;] 设置 “keyword” 为唯一输出的 “keyword” 属性 请求返回以下结果： { &quot;detail&quot; : { &quot;custom_analyzer&quot; : true, &quot;charfilters&quot; : [ ], &quot;tokenizer&quot; : { &quot;name&quot; : &quot;standard&quot;, &quot;tokens&quot; : [ { &quot;token&quot; : &quot;detailed&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 8, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 0 }, { &quot;token&quot; : &quot;output&quot;, &quot;start_offset&quot; : 9, &quot;end_offset&quot; : 15, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 1 } ] }, &quot;tokenfilters&quot; : [ { &quot;name&quot; : &quot;snowball&quot;, &quot;tokens&quot; : [ { &quot;token&quot; : &quot;detail&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 8, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 0, &quot;keyword&quot; : false }, { &quot;token&quot; : &quot;output&quot;, &quot;start_offset&quot; : 9, &quot;end_offset&quot; : 15, &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;, &quot;position&quot; : 1, &quot;keyword&quot; : false } ] } ] } }  &quot;keyword&quot; : false 由于在请求中指定了 &quot;attributes&quot;，只输出 &quot;keyword&quot; 属性。 ","version":"Next","tagName":"h3"},{"title":"设置标记限制​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/analyze#设置标记限制","content":"生成过多的标记可能会导致节点耗尽内存。下面的设置允许限制可以产生的标记的数量: index.analyze.max_token_count 通过 _analyze API 可以产生的标记的最大数量。默认值为 10,000。如果生成的标记超出这个限制，会抛出错误。没有指定索引的 _analyze 端点将始终使用 10,000 作为限制。这个设置允许你控制一个特定索引的限制: PUT /analyze_sample { &quot;settings&quot; : { &quot;index.analyze.max_token_count&quot; : 20000 } }  GET /analyze_sample/_analyze { &quot;text&quot; : &quot;this is a test&quot; }  原文链接 ","version":"Next","tagName":"h3"},{"title":"复制索引","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#请求","content":"POST /&lt;index&gt;/_clone/&lt;target-index&gt; PUT /&lt;index&gt;/_clone/&lt;target-index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 manage 索引权限。为了复制索引，索引必须标记为只读，并且集群健康状态为 green（绿色）。 例如，以下请求在 `` 上阻止写操作，所以它就能被复制。元数据变更，比如删除索引仍然是允许的。 PUT /my_source_index/_settings { &quot;settings&quot;: { &quot;index.blocks.write&quot;: true } }  在数据流的当前写索引不能被复制。为了复制当前写索引，这个数据流必须先被翻转，这样一个新的写索引被创建，前一个写索引才能被复制。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#描述","content":"使用复制索引 API 来复制现有索引到一个新的索引，现有索引的每个源主分片也会复制到新索引的新主分片中。 ","version":"Next","tagName":"h2"},{"title":"复制的原理​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#复制的原理","content":"复制按以下步骤进行： 首先，它创建一个与源索引定义一样的新的目标索引。接着，从源索引硬连接 segment（段）到目标索引。（如果文件系统不支持硬连接，那么所有的 segment（段）都会复制到新索引中，这是一个非常耗时的过程）最后，恢复目标索引，就像刚被重新打开的关闭索引一样。 ","version":"Next","tagName":"h3"},{"title":"复制一个索引​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#复制一个索引","content":"为了将 my_source_index 复制为新的索引 my_target_index，执行以下请求： POST /my_source_index/_clone/my_target_index  一旦将目标索引添加到集群状态，上述请求将立即返回——它不会等待复制操作开始。 警告 索引只有满足以下要求才能被复制： 目标索引不存在源索引的主分片数与目标索引一致处理复制进程的节点必须有足够的可用磁盘空间来容纳现有索引的第二个副本 _clone API 类似创建索引 API，也为目标索引接受参数 settings 和 aliases： POST /my_source_index/_clone/my_target_index { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 5 }, &quot;aliases&quot;: { &quot;my_search_indices&quot;: {} } }  &quot;index.number_of_shards&quot;: 5 目标索引的分片数。必须与源索引分片数相同。 在 _clone 请求中，可以不指定映射（mapping）。源索引的映射将用于目标索引。 ","version":"Next","tagName":"h3"},{"title":"监控复制过程​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#监控复制过程","content":"监控过程可以通过 _cat recovery API 监控，，或使用 集群健康 API 通过 wait_for_status 参数设置为 yellow（黄色）等待所有主分片成功分配。 _clone API 一旦目标索引被添加到集群的状态，在任何分片被分配前，就会返回结果。这时，所有的分片都处于 unassigned（未分配）状态。如果由于任一原因，目标索引不能分配，它的主分片会保持 unassigned 直到它能在节点上分配。 一旦主节点被分配了，它的状态会变为 initializing（初始化中），拆分过程开始。当拆分操作完成，分片会变为 active（激活）。这时，Elasticsearch 会尝试分配任何副本，并可能决定主分片重定位到另一个节点。 ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#等待活动分片","content":"由于拆分操作创建一个新索引来拆分分片进去，所以在索引创建的设置等待活动分片也应用于拆分索引操作。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#路径参数","content":"&lt;index&gt; （必需，字符串）待复制的源索引名字 &lt;target-index&gt; （必需，字符串）创建的目标索引名字 索引名字必须符合以下约定： 只能是小写字符不能包含字符：\\、/、*、?、&quot;、&lt;、&gt;、|、 (空格)、,、#7.0 之前索引可以包含冒号（:），但在 7.0 之后不推荐。不能以 -、_、+ 开头不能是 . 或 ..长度不能超过 255 字节（注意是字节，所以多字节字符会更快达到 255 的限制）名字以 . 开头不推荐，除非由插件管理的隐藏索引和内部索引 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#查询参数","content":"wait_for_active_shards（可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。默认为：1，主分片。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"复制索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clone_index#请求体","content":"aliases （可选，别名对象）包含目标索引的索引别名。参阅批量索引别名。 settings （可选，索引设置对象）目标索引配置选项。参阅索引设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"清除缓存 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#请求","content":"POST /&lt;target&gt;/_cache/clear POST /_cache/clear ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 fielddata （可选，布尔值）如果为 true，清除字段缓存。 使用 fields 字段仅清除特定字段的缓存。 fields （可选，字符串）逗号分隔用于限制 fielddata 参数的字段名字列表。 默认为所有字段。 提示 此参数不支持对象或字段别名。 index （可选，字符串）用于限制请求的，逗号分隔的索引名字。 ignore_unavailable （可选，布尔值）如果为 true，丢失或关闭的索引不包含在响应中。 默认为 false。 query （可选，布尔值）如果为 true，清除查询缓存。 request （可选，布尔值）如果为 true，清除请求缓存。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#示例","content":"","version":"Next","tagName":"h2"},{"title":"清除指定缓存​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#清除指定缓存","content":"默认情况，清除缓存 API 清除所有缓存。你可以通过以下以下查询参数为 true 来清除指定缓存： fielddataqueryrequest POST /my-index-000001/_cache/clear?fielddata=true POST /my-index-000001/_cache/clear?query=true POST /my-index-000001/_cache/clear?request=true  第一个请求，仅清除字段缓存第二个请求，仅清除查询缓存第三个请求，仅清除请求缓存 ","version":"Next","tagName":"h3"},{"title":"清除指定字段缓存​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#清除指定字段缓存","content":"为了只清除指定指定字段缓存，使用 fields 查询参数： POST /my-index-000001/_cache/clear?fields=foo,bar  此请求清除字段 foo 和 bar 的缓存 ","version":"Next","tagName":"h3"},{"title":"清除所有数据流和索引的缓存​","type":1,"pageTitle":"清除缓存 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/clear_cache#清除所有数据流和索引的缓存","content":"POST /_cache/clear  原文链接 ","version":"Next","tagName":"h3"},{"title":"关闭索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"关闭索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index#请求","content":"POST /&lt;index&gt;/_close ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"关闭索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"关闭索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index#描述","content":"你使用关闭索引 API 来关闭开启的索引。 关闭的索引被阻止进行读/写操作，并且不允许开启的索引允许的所有操作。在关闭的索引中不能索引文档或搜索文档。这允许关闭的索引不必维护索引或搜索文档的内部数据结构，以减少集群的开销。 当打开或关闭索引时，主节点负责重新启动索引分片以反映索引的新状态。分片将经过正常的恢复过程。打开的/关闭的索引数据由集群自动复制，以确保始终安全地保留足够的分片副本。 你可以打开和关闭多个索引。如果请求显示引用缺失的索引，会抛出错误。这个行为可以通用 ignore_unavailable=true 参数禁用。 所有索引可以通过 _all 作为索引名字或指定标识所有索引模式（如 *）来一次打开或关闭。 在配置文件中通过设置 action.destructive_requires_name 标识为 true，可以禁用通过通配符或 _all 来定义所有索引。这个设置也可以通过集群更新设置 API 来修改。 关闭的索引会消耗显著数量的硬盘空间，这在托管环境中可能会造成问题。通过集群设置 API 将 cluster.indices.close.enable 设置为 false，可以禁用关闭索引。默认值为 true。 在7.12.0及更早版本中，无法关闭数据流上的当前写入索引。为了关闭当前写索引，数据流必须先被翻转以便创建新的写入索引，这样之前的写入索引能被关闭。此限制从 7.12.1 不再适用。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"关闭索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index#路径参数","content":"&lt;index&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引。 使用 _all 或 * 关闭所有索引。修改 action.destructive_requires_name 集群设置为 true，可以禁用通过 _all 或 * 关闭索引。你可以在文件 elasticsearch.yml 中 或通过 集群更新设置 API 来更新这个设置。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"关闭索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 wait_for_active_shards（可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。值 index-setting 指依据索引设置 index.write.wait_for_active_shards 等待。默认：0，意味着不等待任何分片准备。 参阅活动分片。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"关闭索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/close_index#示例","content":"以下例子展示如何关闭一个索引： POST /my-index-000001/_close  API 返回以下响应： { &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;indices&quot;: { &quot;my-index-000001&quot;: { &quot;closed&quot;: true } } }  原文链接 ","version":"Next","tagName":"h2"},{"title":"创建或更新索引别名 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#请求","content":"PUT /&lt;index&gt;/_alias/&lt;alias&gt; POST /&lt;index&gt;/_alias/&lt;alias&gt; PUT /&lt;index&gt;/_aliases/&lt;alias&gt; POST /&lt;index&gt;/_aliases/&lt;alias&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#前置条件","content":"如果 Elasticsearch 安全特性启用，你对所有索引和索引别名必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#路径参数","content":"&lt;index&gt; （必需的，字符串）待添加别名的，逗号分隔列表或通配符的索引名。 为了向集群中的所有索引添加别名，使用值 _all。 提示 你不能给数据流添加索引别名。 &lt;alias&gt; （必需的，字符串）待创建或升级的索引别名的名字。支持日期数学。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#查询参数","content":"master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#请求体","content":"filter （可选，查询对象）过滤器查询用于限制索引别名。 如果指定，索引别名仅用于过滤器返回的文档。 routing （可选，字符串）用于路由操作到指定分片的自定义值。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#示例","content":"索引别名支持日期数学。 ","version":"Next","tagName":"h2"},{"title":"添加一个基于时间的别名​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#添加一个基于时间的别名","content":"以下的请求为索引 logs_20302801 创建一个别名 2030。 PUT /logs_20302801/_alias/2030  ","version":"Next","tagName":"h3"},{"title":"添加一个基于用户的别名​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#添加一个基于用户的别名","content":"首先，创建一个带有 user_id 字段映射的索引 users： PUT /users { &quot;mappings&quot; : { &quot;properties&quot; : { &quot;user_id&quot; : {&quot;type&quot; : &quot;integer&quot;} } } }  接着，为特定用户 user_12 添加索引别名： PUT /users/_alias/user_12 { &quot;routing&quot; : &quot;12&quot;, &quot;filter&quot; : { &quot;term&quot; : { &quot;user_id&quot; : 12 } } }  ","version":"Next","tagName":"h3"},{"title":"在索引创建时添加一个别名​","type":1,"pageTitle":"创建或更新索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_alias#在索引创建时添加一个别名","content":"你可以使用创建索引 API在索引创建时添加一个索引别名。 PUT /logs_20302801 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;year&quot;: { &quot;type&quot;: &quot;integer&quot; } } }, &quot;aliases&quot;: { &quot;current_day&quot;: {}, &quot;2030&quot;: { &quot;filter&quot;: { &quot;term&quot;: { &quot;year&quot;: 2030 } } } } }  创建索引 API 在索引别名的名字中也支持日期数学。 原文链接 ","version":"Next","tagName":"h3"},{"title":"创建或更新组件模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#请求","content":"PUT /_component_template/&lt;component-template&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#描述","content":"索引模板可以由多个组件模板组成。要使用组件模板，请在索引模板的 composed_of 列表中指定它。组件模板仅作为匹配索引模板的一部分应用于新数据流和索引。 直接在索引模板或创建索引请求中指定设置和映射，将覆盖组件模板中指定的任何设置或映射。 组件模板仅在创建索引期间使用。对于数据流，包括创建数据流和创建流的备份索引。对组件模板的更改不会影响现有索引，包括流的备份索引。 ","version":"Next","tagName":"h2"},{"title":"组件模板中的备注​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#组件模板中的备注","content":"你可以在索引模板中使用 C 风格的 /* */ 块注释。除了在大括号之前，你可以在请求体任何地方包含注释。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#路径参数","content":"&lt;component-template&gt; （必需，字符串）待创建的组件模板名字 Elasticsearch 包含以下内置的组件模板： logs-mappingslogs-settingsmetrics-mappingsmetrics-settingssynthetics-mappingsynthetics-settings Elastic 代理 使用这些模板为其数据流配置备份索引。如果使用 Elastic 代理，并希望覆盖其中一个模板，请将替换模板的版本设置为高于当前版本。 如果你不使用 Elastic 代理，又想禁用内置的组件和索引模板，通过集群更新设置 API设置 stack.templates.enabled 为 false。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#查询参数","content":"create （可选，布尔值）如果为 true，请求不会覆盖或更新已有组件模板。默认为 false。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#请求体","content":"template （必需，对象）将应用的模板，可包括映射（mappings）、设置（settings）或别名（aliases）配置。 template 属性 aliases （可选，对象）索引的别名。如果索引模板包含数据流(data_stream)，此参数不支持。 aliases 对象属性 &lt;alias&gt; （必需，对象）键为别名名字。支持日期数学。 对象体包含别名的选项。支持空对象。 &lt;alias&gt; 属性 filter （可选，查询 DSL 对象）用于限制别名查询时可以访问的文档。 index_routing （可选，字符串）用于将索引操作路由到特定分片的值。如果指定，这将覆盖索引操作的路由值。 is_hidden （可选，布尔值）如果为 true，别名是隐藏的。默认为 false。别名所有的索引必须有相同的 is_hidden 值。 is_write_index （可选，布尔值）如果为 true，索引是别名的写索引。默认为false。 routing （可选，字符串）用于将索引和搜索操作路由到特定分片的值。 search_routing （可选，字符串）用于将搜索操作路由到特定分片的值。如果指定，这将覆盖搜索操作的 routing 值。 mappings （可选，映射对象）索引中字段的映射。如果指定，此映射可以包括： 字段名字字段数据类型映射参数 参阅映射。 settings（可选，索引设置对象）索引配置选项。参阅索引设置。 version （可选，整数）用于显式管理组件模板的版本号。Elasticsearch 不会自动生成或增加此数字。 allow_auto_create （可选，布尔值）此设置覆盖了集群设置中的 action.auto_create_index 的值。如果在模板中设置为 true，即使通过 actions.auto_create_index 禁用了自动创建索引，索引也能通过这个模板自动创建。如果设置为 false，匹配模板的索引或数据流必须被显示创建，且可能永远不会被自动创建。 _meta （可选，对象）可选的有关组件模板的用户元数据。可以有任何内容。Elasticsearch 不会自动生成此内容。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#示例","content":"","version":"Next","tagName":"h2"},{"title":"带索引别名的组件模板​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#带索引别名的组件模板","content":"你可以在组件模板中包含索引别名。 PUT _component_template/template_1 { &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 1 }, &quot;aliases&quot; : { &quot;alias1&quot; : {}, &quot;alias2&quot; : { &quot;filter&quot; : { &quot;term&quot; : {&quot;user.id&quot; : &quot;kimchy&quot; } }, &quot;routing&quot; : &quot;shard-1&quot; }, &quot;{index}-alias&quot; : {} } } }  &quot;{index}-alias&quot; : {}： 在别名中的 {index} 占位符，会在索引创建时应用模板时，替换为真实的索引名字。 ","version":"Next","tagName":"h3"},{"title":"应用组件模板​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#应用组件模板","content":"不能直接将组件模板应用于数据流或索引。若要应用，组件模板必须包含在索引模板的 composed_of 列表中。参阅索引模板。 ","version":"Next","tagName":"h3"},{"title":"组件模板版本控制​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#组件模板版本控制","content":"可以使用 version 参数向组件模板添加版本号。外部系统可以使用这些版本号来简化模板管理。 version 参数是可选的，Elasticsearch 不会自动生成或使用它。 若要取消设置 version，请在不指定模板的情况下替换模板。 PUT /_component_template/template_1 { &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 1 } }, &quot;version&quot;: 123 }  为了检查 version，你可以使用获取组件模板 API。 ","version":"Next","tagName":"h3"},{"title":"组件模板元数据​","type":1,"pageTitle":"创建或更新组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_component_template#组件模板元数据","content":"你可以使用 _meta 参数向组件模板添加任意元数据。此用户定义的对象存储在集群状态，因此最好保持其简短。 _meta 参数是可选的，Elasticsearch 不会自动生成或使用它。 要取消设置 _meta，请在不指定模板的情况下替换模板。 PUT /_component_template/template_1 { &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 1 } }, &quot;_meta&quot;: { &quot;description&quot;: &quot;set number of shards to one&quot;, &quot;serialization&quot;: { &quot;class&quot;: &quot;MyComponentTemplate&quot;, &quot;id&quot;: 10 } } }  为了检查 _meta，你可以使用获取组件模板 API。 原文链接 ","version":"Next","tagName":"h3"},{"title":"创建索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#请求","content":"PUT /&lt;index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 create_index 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#描述","content":"你可以使用创建索引 API 向 Elasticsearch 集群添加一个新的索引。当创建索引时，你可以指定以下项： 索引设置索引字段映射索引别名 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#路径参数","content":"&lt;index&gt; （必需的，字符串）你希望创建的索引的名字。 索引名字必须符合以下约定： 只能是小写字符不能包含字符：\\、/、*、?、&quot;、&lt;、&gt;、|、 (空格)、,、#7.0 之前索引可以包含冒号（:），但在 7.0 之后不推荐。不能以 -、_、+ 开头不能是 . 或 ..长度不能超过 255 字节（注意是字节，所以多字节字符会更快达到 255 的限制）名字以 . 开头不推荐，除非由插件管理的隐藏索引和内部索引 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#查询参数","content":"include_type_name[7.0.0开始不推荐] （可选，布尔值）如果为 true，映射体中需要映射类型。 wait_for_active_shards（可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。默认为：1，主分片。 参阅 活动分片 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#请求体","content":"aliases（可选，别名对象）包含索引的索引别名。参阅批量索引别名。 mappings（可选，映射对象）索引中字段映射。如果指定，映射可以包含： 字段名字字段数据类型映射参数 参阅映射 settings（可选，索引设置对象）索引的配置选项。参阅索引设置 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#示例","content":"","version":"Next","tagName":"h2"},{"title":"索引设置​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#索引设置","content":"创建的每个索引可以有与它关联的特定设置，在请求体中定义： PUT /my-index-000001 { &quot;settings&quot;: { &quot;index&quot;: { &quot;number_of_shards&quot;: 3, &quot;number_of_replicas&quot;: 2 } } }  number_of_shards 默认为 1number_of_replicas 默认为 1 （例如，每个主分片一个副本） 或更简单： PUT /my-index-000001 { &quot;settings&quot;: { &quot;number_of_shards&quot;: 3, &quot;number_of_replicas&quot;: 2 } }  提示 在 settings 部分中，不必显示指定 index 部分。 有关创建索引时，可以设置的所有不同索引级别设置的详细信息，参阅章节索引模块。 ","version":"Next","tagName":"h3"},{"title":"映射​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#映射","content":"创建索引 API 允许提供映射定义： PUT /test { &quot;settings&quot;: { &quot;number_of_shards&quot;: 1 }, &quot;mappings&quot;: { &quot;properties&quot;: { &quot;field1&quot;: { &quot;type&quot;: &quot;text&quot; } } } }  提示 在 7.0.0 之前，mapping（映射）定义用于包含类型名字。尽管现在不推荐在请求中指定类型，但如果设置了请求参数 include_type_name，仍然可以提供类型。更多的信息，参阅移除映射类型。 ","version":"Next","tagName":"h3"},{"title":"别名​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#别名","content":"创建索引 API 也允许提供一组别名。 PUT /test { &quot;aliases&quot;: { &quot;alias_1&quot;: {}, &quot;alias_2&quot;: { &quot;filter&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } }, &quot;routing&quot;: &quot;shard-1&quot; } } }  ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"创建索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_index#等待活动分片","content":"默认情况下，索引创建只会在每个分片的主副本已启动或请求超时时，向客户端返回响应。索引创建响应将表明发生了什么。 { &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;index&quot;: &quot;test&quot; }  acknowledged 表明在集群中索引是否成功创建，同时 shards_acknowledged 表明在超时之前，是否为每个分片启动了必需的分片副本数量。注意，acknowledged 或 shards_acknowledged 仍有可能为 false，但索引创建是成功的。这个值只简单表明在超时前操作是否完成。如果 acknowledged 为 false，然后为新创建的索引更新集群状态之前，我们超时了，但它也可能很快被创建。如果 shards_acknowledged 为 false，在启动所需数量的分片之前我们就超时了（默认情况下，只有主碎片），即使集群状态已成功更新以反映新创建的索引（如，acknowledged=true）。 我们可以通过索引设置 index.write.wait_for_active_shards，更改等待主分片启动的默认值（注意改变这个设置也会影响后续写入操作上的 wait_for_active_shards 值）： PUT /test { &quot;settings&quot;: { &quot;index.write.wait_for_active_shards&quot;: &quot;2&quot; } }  或者通过请求参数 wait_for_active_shards： PUT /test?wait_for_active_shards=2  对 wait_for_active_shards 的详情解释，及它的可能值能在这里找到。 原文链接 ","version":"Next","tagName":"h3"},{"title":"删除组件模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_component_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_component_template#请求","content":"DELETE /_component_template/&lt;component-template&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_component_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"删除组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_component_template#描述","content":"使用删除组件模板 API 可以删除一个或多个组件模板。组件模板是构造索引模板的构造块，用于指定索引映射、设置和别名。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_component_template#路径参数","content":"&lt;component-template&gt; （必需，字符串）用于限制请求的，逗号分隔的组件模板名字或通配符表达式。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_component_template#查询参数","content":"master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"删除悬空索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_dangling_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_dangling_index#请求","content":"DELETE /_dangling/&lt;index-uuid&gt;?accept_data_loss=true  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_dangling_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage 集群权限来使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"删除悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_dangling_index#描述","content":"如果 Elasticsearch 遇到当前集群状态中缺少的索引数据，则认为这些索引处于悬空状态。例如，如果在 Elasticsearch 节点脱机时删除多个 cluster.index.tombstones.size 索引，则可能会发生这种情况。 通过引用其 UUID 可以删除悬空索引。使用列出悬空索引 API 定位索引的 UUID。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_dangling_index#路径参数","content":"&lt;index-uuid&gt; （必需的，字符串）待删除索引的 UUID，你可以通过列出悬空索引 API 找到它。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_dangling_index#查询参数","content":"accept_data_loss （必需的，布尔值）此字段必须设置为 true 才能导入悬空索引。由于 Elasticsearch 无法知道悬空索引数据来自何处，也无法确定哪些分片副本是新的，哪些是旧的，因此它无法保证导入的数据代表索引在集群中最后一次出现时的最新状态。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"创建或更新索引模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#请求","content":"PUT /_index_template/&lt;index-template&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#描述","content":"Elasticsearch 基于通配符模式来匹配索引名字，将模板应用于相应的新索引。 索引模板通过数据流或索引创建时应用。对数据流而言，当数据流的备份索引创建时，这些设置和映射会被应用。在[创建索引]((/rest_apis/index_apis/create_index)请求中指定的设置和映射会重载索引模板中指定的任意设置或映射。 修改索引模板不会影响已有的索引，包括数据流已有的备份索引。 ","version":"Next","tagName":"h2"},{"title":"索引模板中的注释​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#索引模板中的注释","content":"你可以在索引模板中使用 C 风格的 /* */ 块注释。除了在大括号之前，你可以在请求体任何地方包含注释。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#路径参数","content":"&lt;index-template&gt; （必需，字符串）待创建索引模板名字。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#查询参数","content":"create （可选，布尔值）如果为 true，此请求不会替代或更新已有的索引模板。默认为 false。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#请求体","content":"composed_of （可选，字符串数组）一个组件模板名称的有序列表。组件模板按指定的顺序合并，这意味着最后指定的组件模板具有最高的优先级。参阅组合多个组件模板查看示例。 data_stream （可选，对象）如果这个对象被包含了，那么这个模板将会用于创建数据流和他们的备份索引。支持一个空对象。 数据流必须有 data_stream 对象来匹配索引模板。参阅创建索引模板。 data_stream 属性 hidden （可选，字符串）如果为 true，数据流是隐藏的。默认为 false。 index_patterns （必需的，字符串数组）用于在创建时匹配数据流和索引名字的通配符（*）表达式数组。 Elasticsearch 包含几个内置的索引模板。为了避免这些模板的命名冲突，参阅避免索引模式冲突。 _meta （可选，对象）关于索引模板的可选用户元数据。可以有任意内容。Elasticsearch 不会自动生成此信息。 priority （可选，整数）用于在创建新数据流或索引时确定索引模板的优先级。具有最高优先级的索引模板先被选择。如果未指定优先级，则将模板视为优先级为 0（最低优先级）。Elasticsearch 不会自动生成此值。 template （可选，对象）要应用的模板。它可以选择包括别名、映射或设置配置。 template 属性 aliases （可选，对象）索引的别名。如果索引模板包含了 data_stream，此参数不被支持。 aliases 对象属性 &lt;alias&gt; （必需，对象）键值是别名名称。支持日期数学。 对象体包含别名的选项。支持空对象。 &lt;alias&gt; 属性 filter （可选，查询 DSL 对象）用于限制别名查询时可以访问的文档。 index_routing （可选，字符串）用于将索引操作路由到特定分片的值。如果指定，这将覆盖索引操作的路由值。 is_hidden （可选，布尔值）如果为 true，别名是隐藏的。默认为 false。别名所有的索引必须有相同的 is_hidden 值。 is_write_index （可选，布尔值）如果为 true，索引是别名的写索引。默认为 false。 routing （可选，字符串）用于将索引和搜索操作路由到特定分片的值。 search_routing （可选，字符串）用于将搜索操作路由到特定分片的值。如果指定，这将覆盖搜索操作的 routing 值。 mappings （可选，映射对象）索引中字段的映射。如果指定，此映射可以包括： 字段名字字段数据类型映射参数 参阅映射。 settings（可选，索引设置对象）索引的配置索引。参阅索引设置。 version （可选，整数）用于外部管理索引模板的版本号。Elasticsearch 不会自动生成此值。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#示例","content":"","version":"Next","tagName":"h2"},{"title":"带索引别名的索引模板​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#带索引别名的索引模板","content":"你可以在索引模板中包含索引别名。 PUT _index_template/template_1 { &quot;index_patterns&quot; : [&quot;te*&quot;], &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 1 }, &quot;aliases&quot; : { &quot;alias1&quot; : {}, &quot;alias2&quot; : { &quot;filter&quot; : { &quot;term&quot; : {&quot;user.id&quot; : &quot;kimchy&quot; } }, &quot;routing&quot; : &quot;shard-1&quot; }, &quot;{index}-alias&quot; : {} } } }  &quot;{index}-alias&quot; : {}：在索引创建期间，别名中的 {index} 占位符将替换为模板应用到的实际索引名称。 ","version":"Next","tagName":"h3"},{"title":"多匹配模板​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#多匹配模板","content":"如果多个索引模板与新索引或数据流的名称匹配，则使用具有最高优先级的模板。例如： PUT /_index_template/template_1 { &quot;index_patterns&quot; : [&quot;t*&quot;], &quot;priority&quot; : 0, &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 1, &quot;number_of_replicas&quot;: 0 }, &quot;mappings&quot; : { &quot;_source&quot; : { &quot;enabled&quot; : false } } } } PUT /_index_template/template_2 { &quot;index_patterns&quot; : [&quot;te*&quot;], &quot;priority&quot; : 1, &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 2 }, &quot;mappings&quot; : { &quot;_source&quot; : { &quot;enabled&quot; : true } } } }  对于以 te* 开头的索引，将启用 _source，索引将有两个主分片和一个副本，因为只会应用 template_2。 提示 不允许有相同优先级且索引模式重合的多个模板，且在尝试创建一个模板，而它与现有索引模板匹配具有相同优先级时，将引发错误。 ","version":"Next","tagName":"h3"},{"title":"模板版本​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#模板版本","content":"可以使用 version 参数向索引模板添加版本号。外部系统可以使用这些版本号来简化模板管理。 version 参数是可选的，Elasticsearch 不自动生成也不使用。 若要取消设置 version，请在不指定它的情况下替换模板。 PUT /_index_template/template_1 { &quot;index_patterns&quot; : [&quot;foo&quot;, &quot;bar&quot;], &quot;priority&quot; : 0, &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 1 } }, &quot;version&quot;: 123 }  为了检查 version，你可以使用获取索引模板 API。 ","version":"Next","tagName":"h3"},{"title":"模板元数据​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#模板元数据","content":"你可以使用 _meta 参数向索引模板添加任意元数据。这个用户定义的对象存储在集群状态下，因此最好保持它内容简短。 _meta 参数是可选的，Elasticsearch 不自动生成也不使用。 若要取消设置 _meta，请在不指定它的情况下替换模板。 PUT /_index_template/template_1 { &quot;index_patterns&quot;: [&quot;foo&quot;, &quot;bar&quot;], &quot;template&quot;: { &quot;settings&quot; : { &quot;number_of_shards&quot; : 3 } }, &quot;_meta&quot;: { &quot;description&quot;: &quot;set number of shards to three&quot;, &quot;serialization&quot;: { &quot;class&quot;: &quot;MyIndexTemplate&quot;, &quot;id&quot;: 17 } } }  为了检查 _meta，你可以使用获取索引模板 API。 ","version":"Next","tagName":"h3"},{"title":"数据流定义​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#数据流定义","content":"要对数据流使用索引模板，该模板必须包含 data_stream 对象。 PUT /_index_template/template_1 { &quot;index_patterns&quot;: [&quot;logs-*&quot;], &quot;data_stream&quot;: { } }  参阅创建索引模板。 ","version":"Next","tagName":"h3"},{"title":"合并别名、映射和设置​","type":1,"pageTitle":"创建或更新索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/create_or_update_index_template#合并别名映射和设置","content":"当在索引模板的 composed_of 字段中指定多个组件模板时，它们将按指定的顺序合并，这意味着后面的组件模板覆盖早期的组件模板。下一步将合并父索引模板中的任何映射、设置或别名。最后，将合并索引请求本身的任何配置。 在本例中，两个组件模板的顺序会更改索引的分片数： PUT /_component_template/template_with_2_shards { &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 2 } } } PUT /_component_template/template_with_3_shards { &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 3 } } } PUT /_index_template/template_1 { &quot;index_patterns&quot;: [&quot;t*&quot;], &quot;composed_of&quot;: [&quot;template_with_2_shards&quot;, &quot;template_with_3_shards&quot;] }  在这种情况下，匹配 t* 的索引将有三个主分片。如果组合模板的顺序颠倒，索引将有两个主分片。 映射定义递归合并，这意味着以后的映射组件可以引入新的字段映射并更新映射配置。如果一个字段映射已经包含在早期组件中，那么它的定义将被后面的组件完全覆盖。 这种递归合并策略不仅适用于字段映射，还适用于根选项，如 dynamic_templates 和 meta。如果早期组件包含 dynamic_templates 块，则默认情况下，新的 dynamic_templates 条目将附加到末尾。如果已经存在具有相同键的条目，则该条目将被新定义覆盖。 原文链接 ","version":"Next","tagName":"h3"},{"title":"删除索引模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_template#请求","content":"DELETE /_index_template/&lt;index-template&gt; &lt;index-template&gt; 可以包含多个用逗号分隔的模板名字。如果指定了多个模板名字，那就不能使用通配符，并且要与已有模板名字完全一样。 ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"删除索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_template#描述","content":"使用删除索引模板 API 去删除一个或多个索引模板。索引模板定义了可以自动用于新索引的设置、映射和别名。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_template#路径参数","content":"&lt;index-template&gt; （必需，字符串）限制请求的逗号分隔的索引名字列表。支持通配符（*）。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_template#查询参数","content":"master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"删除索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index#请求","content":"DELETE /&lt;index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 delete_index 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index#路径参数","content":"&lt;index&gt; （必需的，字符串）待删除的索引的逗号分隔列表或通配符表达式。 在这个参数中，通配符表达式只能匹配开启、具体的索引。你不能通过别名删除索引。 为了删除所有索引，使用 _all 或 *。为了禁止使用 _all 或通配符表达式删除索引，修改 action.destructive_requires_name 集群设置为 true。你可以在 elasticsearch.yml 文件中或通过集群更新 API 更新设置。 提示 你不能删除数据流的当前写入索引。为了删除索引，你必须翻转数据流，这样一个新的写索引就创建了。这时你就可以使用删除索引 API 删除之前的写索引。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"删除索引别名","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_alias","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"删除索引别名","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_alias#请求","content":"DELETE /&lt;index&gt;/_alias/&lt;alias&gt; DELETE /&lt;index&gt;/_aliases/&lt;alias&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"删除索引别名","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_alias#前置条件","content":"如果 Elasticsearch 安全特性启用，你对所有索引和索引别名必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"删除索引别名","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_alias#路径参数","content":"&lt;index&gt;（必需的，字符串）用于限制请求的，逗号分隔列表或通配符的索引名。 为了包含集群中的所有索引，使用值 _all 或 *。 &lt;alias&gt;（必需的，字符串）用于限制请求的，逗号分隔列表或通配符的索引别名。 为了获取所有索引别名的信息，使用值 _all 或 *。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"删除索引别名","url":"/docs/elasticsearch-cn/rest_apis/index_apis/delete_index_alias#查询参数","content":"master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"冲刷 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#请求","content":"POST /&lt;target&gt;/_flush GET /&lt;target&gt;/_flush POST /_flush GET /_flush ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 maintenance 或 manage 索引权限 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#描述","content":"冲刷数据流或索引是确保当前仅存储在事务日志中的任何数据也永久存储在 Lucene 索引中的过程。重新启动时，Elasticsearch 将重放从事务日志到 Lucene 索引的所有未冲刷操作，以使其恢复到重新启动前的状态。Elasticsearch 会根据需要自动触发冲刷，使用试探法权衡未冲刷事务日志的大小和执行每次冲刷的成本。 一旦每个操作被冲刷，它将永久存储在 Lucene 索引中。这可能意味着不需要在事务日志中维护它的附加副本，除非出于其他原因保留它。事务日志由多个文件组成，称为年代，一旦不再需要，Elasticsearch 将删除任何年代文件，从而释放磁盘空间。 也可以使用冲刷 API 触发对一个或多个索引的冲刷，尽管用户很少需要直接调用此 API。如果在索引某些文档后调用冲刷 API，则成功的响应表明 Elasticsearch 已冲刷在调用冲刷 API 之前索引的所有文档。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 force （可选，布尔值）如果为 true，即使没有变更要提交给索引，请求也强制冲刷。默认为 true。 可使用此参数来参加事务日志的年代值。 此参数视为内部参数。 ignore_unavailable （可选，布尔值）如果为 true，丢失或关闭的索引不包含在响应中。 默认为 false。 wait_if_ongoing （可选，布尔值）如果为 true，当另一个冲刷操作运行时，冲刷操作会阻塞到执行为止。 如果为 false，当另一个冲刷操作运行时，请求冲刷操作时，Elasticsearch 会直接返回错误。 默认为 true。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#示例","content":"","version":"Next","tagName":"h2"},{"title":"冲刷指定的数据流或索引​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#冲刷指定的数据流或索引","content":"POST /my-index-000001/_flush  ","version":"Next","tagName":"h3"},{"title":"冲刷多个数据流和索引​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#冲刷多个数据流和索引","content":"POST /my-index-000001,my-index-000002/_flush  ","version":"Next","tagName":"h3"},{"title":"冲刷集群中所有数据流和索引​","type":1,"pageTitle":"冲刷 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/flush#冲刷集群中所有数据流和索引","content":"POST /_flush  原文链接 ","version":"Next","tagName":"h3"},{"title":"获取组件模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#请求","content":"GET /_component_template/&lt;component-template&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#路径参数","content":"&lt;component-template&gt; （可选，字符串）用于限制请求的，逗号分隔的组件模板名字。支持通配符（*）表达式。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#查询参数","content":"flat_settings （可选，布尔值）如果为 true，以平面格式返回设置。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#示例","content":"","version":"Next","tagName":"h2"},{"title":"通过通配符表达式获取组件模板​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#通过通配符表达式获取组件模板","content":"GET /_component_template/temp*  ","version":"Next","tagName":"h3"},{"title":"获取所有组件模板​","type":1,"pageTitle":"获取组件模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_component_template#获取所有组件模板","content":"GET /_component_template  原文链接 ","version":"Next","tagName":"h3"},{"title":"强制合并 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#请求","content":"POST /&lt;target&gt;/_forcemerge POST /_forcemerge ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 maintenance 或 manage 索引权限 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#描述","content":"使用强制合并 API 强制合并一个或多个索引的分片。合并通过将部分片段合并在一起，减少了每个片段中的片段数，还释放了被删除文档所使用的空间。合并通常自动进行，但有时手动触发合并是有用的。 警告 只有在完成对索引的写入后，才能对其调用强制合并。强制合并可以产生非常大的（&gt;5GB）段，并且如果继续写入这样的索引，那么自动合并策略将永远不会考虑这些段以用于将来合并，直到它们大部分由删除的文档组成。这可能会导致索引中保留非常大的段，从而导致磁盘使用率增加和搜索性能下降。 ","version":"Next","tagName":"h2"},{"title":"在强制合并期间阻塞​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#在强制合并期间阻塞","content":"调用此 API ，直到合并完成都是阻塞的。如果客户端连接在完成之前丢失，则强制合并过程将在后台继续。强制合并相同索引的任何新请求也将被阻止，直到正在进行的强制合并完成。 ","version":"Next","tagName":"h3"},{"title":"强制合并多个索引​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#强制合并多个索引","content":"你可以通过以下目标强制将多个索引与单个请求合并： 包含多个备份索引的一个或多个数据流 多指标 一个或多个别名 集群中的所有数据流和索引 使用 force_merge 线程池分别强制合并每个目标分片。默认情况下，每个节点只有一个强制合并线程，这意味着该节点上的碎片一次强制合并一个。如果在节点上展开 force_merge 线程池，则它将强制并行合并其分片。 强制合并使被合并的分片的存储空间临时增加，在 max_num_segments 参数设置为 1 的情况下，存储空间将增加一倍，因为所有的片段都需要重写为新的片段。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 flush （可选，布尔值）如果为 true，Elasticsearch 在强制合并后对索引执行刷新。默认为 true。 ignore_unavailable （可选，布尔值）如果为 true，丢失或关闭的索引不包含在响应中。 默认为 false。 max_num_segments （可选，整型）待合并的段数量。为了完全合并索引，设置为 1。默认为检查是否需要执行合并。如果是，执行它。 only_expunge_deletes （可选，布尔值）如果为 true，仅删除包含文档删除的段。默认为 false。 在 Lucene 中，文档不会从段中删除；只是标记为已删除。在合并过程中，将创建一个不包含这些文档删除的新段。 提示 此参数不会覆写设置 index.merge.policy.expunge_deletes_allowed。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#示例","content":"","version":"Next","tagName":"h2"},{"title":"强制合并一个指定的数据流或索引​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#强制合并一个指定的数据流或索引","content":"POST /my-index-000001/_forcemerge  ","version":"Next","tagName":"h3"},{"title":"强制合并多个数据流或索引​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#强制合并多个数据流或索引","content":"POST /my-index-000001,my-index-000002/_forcemerge  ","version":"Next","tagName":"h3"},{"title":"强制合并所有索引​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#强制合并所有索引","content":"POST /_forcemerge  ","version":"Next","tagName":"h3"},{"title":"数据流和基于时间的索引​","type":1,"pageTitle":"强制合并 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/force_merge#数据流和基于时间的索引","content":"强制合并对于管理数据流的旧备份索引和其他基于时间的索引非常有用，尤其是在翻转之后。在这些情况下，每个索引只在一段时间内接收索引流量。一旦索引不再接收写入，它的分片就可以强制合并到单个段中。 POST /.ds-my-data-stream-2099.03.07-000001/_forcemerge?max_num_segments=1  这是一个好主意，因为单段分片有时可以使用更简单、更高效的数据结构来执行搜索。 原文链接 ","version":"Next","tagName":"h3"},{"title":"冻结索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/freeze_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"冻结索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/freeze_index#请求","content":"POST /&lt;index&gt;/_freeze ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"冻结索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/freeze_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引或索引别名必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"冻结索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/freeze_index#描述","content":"已冻结的索引在集群上几乎没有开销（除了在内存中维护它的元数据）且是只读的。只读索引禁止写操作，比如 docs-index_ 或强制合并。参阅已冻结索引和解冻索引。 在数据流中的当前写索引不能被冻结。为了冻结当前写索引，数据流必须先被翻转，这样一个新的写索引被创建，前一个写索引才能被冻结。 警告 冻结一个索引会在同一个 API 调用中关闭这个索引并且重新打开它。这将导致在短时间内主分片不被分配，直到再次分配主分片前集群会变为红色（red）。这个限制在未来可能被移除。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"冻结索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/freeze_index#路径参数","content":"&lt;index&gt; （必需，字符串）标识索引。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"冻结索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/freeze_index#示例","content":"以下的示例冻结和解冻一个索引。 POST /my-index-000001/_freeze POST /my-index-000001/_unfreeze  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index#请求","content":"GET /&lt;target&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index#路径参数","content":"&lt;target&gt; （必需的，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（*）。 若要以集群中的所有数据流和索引为目标，省略此参数或使用 _all 或 *。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 flat_settings （可选，布尔值）如果为 true，以平面格式返回设置。默认为 false。 include_defaults （可选，字符串）如果为 true，在响应中返回所有默认设置。默认为 false。 include_type_name [7.0.0开始不推荐]（可选，布尔值）如果为 true，映射体中期望有映射类型。默认为 false。 ignore_unavailable （可选，布尔值）如果为 true，请求不存在的索引将返回错误。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点检索信息。默认为 false，意味着从主节点检索信息。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"获取字段映射 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#请求","content":"GET /_mapping/field/&lt;field&gt; GET /&lt;target&gt;/_mapping/field/&lt;field&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或索引别名必须有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引和别名列表。支持通配符（）。为了标明所有数据流和索引，省略这个参数或者使用 `或_all`。 &lt;field&gt; （可选，字符串）逗号分隔的字段列表或者通配符，用于限制返回的信息。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 include_type_name[7.0.0开始不推荐] （可选，布尔值）如果为 true，映射体中需要映射类型。 ignore_unavailable（可选，布尔值）如果为 true，请求不存在的索引将返回错误。默认为 false。 include_defaults（可选，布尔值）如果为 true，响应包含默认的映射值。默认为 false。 local（可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#示例","content":"","version":"Next","tagName":"h2"},{"title":"索引设置示例​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#索引设置示例","content":"当创建新索引时，你可以提供字段映射。以下的创建索引 API 请求，创建一个名为 publications 的索引，并有几个字段映射。 PUT /publications { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;text&quot; }, &quot;title&quot;: { &quot;type&quot;: &quot;text&quot; }, &quot;abstract&quot;: { &quot;type&quot;: &quot;text&quot; }, &quot;author&quot;: { &quot;properties&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;text&quot; }, &quot;name&quot;: { &quot;type&quot;: &quot;text&quot; } } } } } }  以下请求仅返回字段 title 的映射： GET publications/_mapping/field/title  API 返回以下的响应： { &quot;publications&quot;: { &quot;mappings&quot;: { &quot;title&quot;: { &quot;full_name&quot;: &quot;title&quot;, &quot;mapping&quot;: { &quot;title&quot;: { &quot;type&quot;: &quot;text&quot; } } } } } }  ","version":"Next","tagName":"h3"},{"title":"指定字段​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#指定字段","content":"获取映射 API 允许你指定逗号分隔的字段列表。 例如，为了选择 author 字段的 id，你必须使用命名 author.id。 GET publications/_mapping/field/author.id,abstract,name  返回： { &quot;publications&quot;: { &quot;mappings&quot;: { &quot;author.id&quot;: { &quot;full_name&quot;: &quot;author.id&quot;, &quot;mapping&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;text&quot; } } }, &quot;abstract&quot;: { &quot;full_name&quot;: &quot;abstract&quot;, &quot;mapping&quot;: { &quot;abstract&quot;: { &quot;type&quot;: &quot;text&quot; } } } } } }  获取字段映射 API 也支持通配符。 GET publications/_mapping/field/a*  返回： { &quot;publications&quot;: { &quot;mappings&quot;: { &quot;author.name&quot;: { &quot;full_name&quot;: &quot;author.name&quot;, &quot;mapping&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;text&quot; } } }, &quot;abstract&quot;: { &quot;full_name&quot;: &quot;abstract&quot;, &quot;mapping&quot;: { &quot;abstract&quot;: { &quot;type&quot;: &quot;text&quot; } } }, &quot;author.id&quot;: { &quot;full_name&quot;: &quot;author.id&quot;, &quot;mapping&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;text&quot; } } } } } }  ","version":"Next","tagName":"h3"},{"title":"多目标和字段​","type":1,"pageTitle":"获取字段映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_field_mapping#多目标和字段","content":"获取字段映射 API 可以用于一次请求获取多个数据流或索引的多个字段映射。 路径参数中的 &lt;target&gt; 及 &lt;field&gt; 都支持逗号分隔的列表和通配符。 你也可以忽略参数 &lt;target&gt; 或者使用 * 或 _all 来指示集群中的所有数据流和索引。 同样的，你也可以忽略参数 &lt;field&gt;，或者使用 * 来获取目标数据流或索引的所有字段映射。然而参数 &lt;field&gt; 不支持 _all 值。 例如，以下的请求获取在任何名为 my-index-000001 或 my-index-000002 的数据流或索引中 message 字段的映射。 GET /my-index-000001,my-index-000002/_mapping/field/message  以下的请求获取集群中任何数据流或索引的字段 message 和 user.id 的映射。 GET /_all/_mapping/field/message  以下的请求获取集群中任何数据流或索引带有 id 属性的字段的映射。 GET /_all/_mapping/field/*.id  原文链接 ","version":"Next","tagName":"h3"},{"title":"获取索引模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#请求","content":"GET /_index_template/&lt;index-template&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#路径参数","content":"&lt;index-template&gt; （必需，字符串）限制请求的逗号分隔的索引名字列表。支持通配符（*）。 为了获取所有索引模板，忽略此参数或使用 * 值。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#查询参数","content":"flat_settings （可选，布尔值）如果为 true，以平面格式返回设置。默认为 false。 include_type_name [7.0.0开始不推荐] （可选，布尔值）如果为 true，映射体中需要映射类型。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#示例","content":"","version":"Next","tagName":"h2"},{"title":"使用通配符表达式获取索引模板​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#使用通配符表达式获取索引模板","content":"GET /_index_template/temp*  ","version":"Next","tagName":"h3"},{"title":"获取所有索引模板​","type":1,"pageTitle":"获取索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_template#获取所有索引模板","content":"GET /_index_template  原文链接 ","version":"Next","tagName":"h3"},{"title":"获取索引设置 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#请求","content":"GET /&lt;target&gt;/_settings GET /&lt;target&gt;/_settings/&lt;setting&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 view_index_metadata、monitor 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 &lt;setting&gt; （可选，字符串）用于限制请求的逗号分隔的设置名字或通配符。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 flat_settings （可选，布尔值）如果为 true，以平面格式返回设置。默认为 false。 include_defaults（可选，布尔值）如果为 true，响应包含默认的映射值。默认为 false。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点检索信息。默认为 false，意味着从主节点检索信息。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#示例","content":"","version":"Next","tagName":"h2"},{"title":"多数据流和索引​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#多数据流和索引","content":"获取索引设置 API 可以用于一次请求获取超过一个数据流或索引的设置。为了获取一个集群中所有索引的设置，你可以为 &lt;target&gt;使用 _all 或 *。也支持通配符表达式。以下是一些示例： GET /my-index-000001,my-index-000002/_settings GET /_all/_settings GET /log_2099_*/_settings  ","version":"Next","tagName":"h3"},{"title":"按名字过滤设置​","type":1,"pageTitle":"获取索引设置 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_settings#按名字过滤设置","content":"返回的设置可以通过通配符匹配过滤，如下所示： GET /log_2099_-*/_settings/index.number_*  原文链接 ","version":"Next","tagName":"h3"},{"title":"获取映射 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping#请求","content":"GET /_mapping GET /&lt;target&gt;/_mapping ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或索引别名必须有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引和别名列表。支持通配符（）。为了标明所有数据流和索引，省略这个参数或者使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 include_type_name[7.0.0开始不推荐] （可选，布尔值）如果为 true，映射体中需要映射类型。 ignore_unavailable（可选，布尔值）如果为 true，请求不存在的索引将返回错误。默认为 false。 local（可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping#示例","content":"","version":"Next","tagName":"h2"},{"title":"多个数据流和索引​","type":1,"pageTitle":"获取映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_mapping#多个数据流和索引","content":"获取映射 API 可以一次请求获取多个数据流或索引。此 API 通常按以下语法使用：host:port/&lt;target&gt;/_mapping，&lt;target&gt; 可接受逗号分隔的名字列表。为了获取集群中所有数据流和索引，&lt;target&gt; 使用 _all 或 *，或者忽略参数 &lt;target&gt;。以下为一些示例： GET /my-index-000001,my-index-000002/_mapping  如果你想获取集群中所有索引的映射，以下示例都是等价的： GET /*/_mapping GET /_all/_mapping GET /_mapping  原文链接 ","version":"Next","tagName":"h3"},{"title":"导入悬空索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"导入悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index#请求","content":"POST /_dangling/&lt;index-uuid&gt;?accept_data_loss=true  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"导入悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage 集群权限来使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"导入悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index#描述","content":"如果 Elasticsearch 遇到当前集群状态中缺少的索引数据，则认为这些索引处于悬空状态。例如，如果在 Elasticsearch 节点脱机时删除多个 cluster.index.tombstones.size 索引，则可能会发生这种情况。 通过引用其 UUID 将单个索引导入集群。使用列出悬空索引 API 定位索引的 UUID。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"导入悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index#路径参数","content":"&lt;index-uuid&gt; （必需的，字符串）待导入索引的 UUID，你可以通过列出悬空索引 API 找到它。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"导入悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index#查询参数","content":"accept_data_loss （必需的，布尔值）此字段必须设置为 true 才能导入悬空索引。由于 Elasticsearch 无法知道悬空索引数据来自何处，也无法确定哪些分片副本是新的，哪些是旧的，因此它无法保证导入的数据代表索引在集群中最后一次出现时的最新状态。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"导入悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/import_dangling_index#示例","content":"以下示例展示如何导入一个悬空索引： POST /_dangling/zmM4e0JtBkeUjiHD-MihPQ?accept_data_loss=true  API 返回以下响应： { &quot;acknowledged&quot; : true }  原文链接 ","version":"Next","tagName":"h2"},{"title":"获取索引别名 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#请求","content":"GET /_alias GET /_alias/&lt;alias&gt; GET /&lt;index&gt;/_alias/&lt;alias&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#前置条件","content":"如果 Elasticsearch 安全特性启用，你对索引别名必须有 view_index_metadata 或 manage 索引权限。如果你指定一个索引，你对这个索引也必须要有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#路径参数","content":"&lt;alias&gt; （可选，字符串）用于限制请求的，逗号分隔列表或通配符的索引别名。 为了获取所有索引别名的信息，使用值 _all 或 *。 &lt;index&gt; （可选，字符串）用于限制请求的，逗号分隔列表或通配符的索引名。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable （可选，布尔值）如果为 true，请求不存在的索引将返回错误。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#示例","content":"","version":"Next","tagName":"h2"},{"title":"获取一个索引的所有别名​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#获取一个索引的所有别名","content":"你可以通过创建索引 API请求在索引创建时添加索引别名。 以下的创建索引 API 请求创建带有两个别名的索引 logs_20302801： current_day2030，仅返回索引 logs_20302801 中字段 year 的值为 2030 的文档 PUT /logs_20302801 { &quot;aliases&quot; : { &quot;current_day&quot; : {}, &quot;2030&quot; : { &quot;filter&quot; : { &quot;term&quot; : {&quot;year&quot; : 2030 } } } } }  以下获取索引别名 API 请求返回索引 logs_20302801 所有别名： GET /logs_20302801/_alias/*  API 返回以下响应： { &quot;logs_20302801&quot; : { &quot;aliases&quot; : { &quot;current_day&quot; : { }, &quot;2030&quot; : { &quot;filter&quot; : { &quot;term&quot; : { &quot;year&quot; : 2030 } } } } } }  ","version":"Next","tagName":"h3"},{"title":"获取一个指定别名​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#获取一个指定别名","content":"以下的索引别名 API 请求返回别名 2030： GET /_alias/2030  API 返回以下响应： { &quot;logs_20302801&quot; : { &quot;aliases&quot; : { &quot;2030&quot; : { &quot;filter&quot; : { &quot;term&quot; : { &quot;year&quot; : 2030 } } } } } }  ","version":"Next","tagName":"h3"},{"title":"获取基于通配符的别名​","type":1,"pageTitle":"获取索引别名 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/get_index_alias#获取基于通配符的别名","content":"以下的索引别名 API 请求返回以 20 开头的任何别名： GET /_alias/20*  API 返回以下响应： { &quot;logs_20302801&quot; : { &quot;aliases&quot; : { &quot;2030&quot; : { &quot;filter&quot; : { &quot;term&quot; : { &quot;year&quot; : 2030 } } } } } }  原文链接 ","version":"Next","tagName":"h3"},{"title":"索引存在 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_exists","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"索引存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_exists#请求","content":"HEAD /&lt;target&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"索引存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_exists#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"索引存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_exists#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（*）。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"索引存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_exists#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 flat_settings （可选，布尔值）如果为 true，以平面格式返回设置。默认为 false。 include_defaults （可选，字符串）如果为 true，在响应中返回所有默认设置。默认为 false。 ignore_unavailable （可选，布尔值）如果为 true，请求不存在的索引将返回错误。默认为 false。 local （可选，布尔值）如果为 true，请求只从本地节点检索信息。默认为 false，意味着从主节点检索信息。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"索引存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_exists#响应码","content":"200 表明所有指定的索引或索引别名存在。 404 表明一个至多个索引或索引别名不存在。 原文链接 ","version":"Next","tagName":"h2"},{"title":"索引段 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#请求","content":"GET /&lt;target&gt;/_segments GET /_segments ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 monitor 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 verbose 【实验特性】（可选，布尔值）如果为 true，响应包含 Lucene 内存使用的详细信息。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#响应体","content":"&lt;segment&gt; （字符串）段的名字，比如 _0。段名称源自段生成，并在内部用于在分片目录中创建文件名。 generation （整数值）年代值，通常为 0。Elasticsearch 为写入的每个段增加此生成编号。Elasticsearch 再使用此数字派生段名称。 num_docs （整数值）Lucene 报告的文档数。这将排除已删除的文档，并将所有嵌套文档与其父文档分开计数。它还排除了最近编制索引但不属于某个段的文档。 deleted_docs （整数值）Lucene 报告的已删除文档数，可能高于或低于你执行的删除操作数。此数字不包括最近执行的但不属于某个段的删除。如果有必要，删除的文档将通过自动合并过程进行清理。此外，Elasticsearch 还创建额外的已删除文档，以便在内部跟踪分片上最近的操作历史。 size_in_bytes （整数值）用于段的磁盘空间，如 50kb。 memory_in_bytes （整数值）存储在内存中用于高效搜索的段数据字节，如 1264。 值 -1 表示 Elasticsearch 无法计算此数字。 committed （布尔值）如果为 true，这些段将同步到磁盘。同步的段可以在硬重新启动后存活。 如果为 false，则来自未提交段的数据也存储在事务日志中，以便 Elasticsearch 能够在下一次启动时重播更改。 search （布尔值）如果为 true，段是可搜索的。 如果为 false，段很大可能已写入磁盘，但需要刷新才可搜索。 version （字符串）用于写段的 Lucene 版本。 compound （布尔值）如果为 true，Lucene 将段中的所有文件合并为一个文件以保存文件描述符。 attributes （对象）包含有关是否启用了高压缩的信息。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#示例","content":"","version":"Next","tagName":"h2"},{"title":"获取指定数据流或索引的段信息​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#获取指定数据流或索引的段信息","content":"GET /test/_segments  ","version":"Next","tagName":"h3"},{"title":"获取多个数据流和索引的段信息​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#获取多个数据流和索引的段信息","content":"GET /test1,test2/_segments  ","version":"Next","tagName":"h3"},{"title":"获取集群中所有数据流和索引的段信息​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#获取集群中所有数据流和索引的段信息","content":"GET /_segments  API 返回以下响应： { &quot;_shards&quot;: ... &quot;indices&quot;: { &quot;test&quot;: { &quot;shards&quot;: { &quot;0&quot;: [ { &quot;routing&quot;: { &quot;state&quot;: &quot;STARTED&quot;, &quot;primary&quot;: true, &quot;node&quot;: &quot;zDC_RorJQCao9xf9pg3Fvw&quot; }, &quot;num_committed_segments&quot;: 0, &quot;num_search_segments&quot;: 1, &quot;segments&quot;: { &quot;_0&quot;: { &quot;generation&quot;: 0, &quot;num_docs&quot;: 1, &quot;deleted_docs&quot;: 0, &quot;size_in_bytes&quot;: 3800, &quot;memory_in_bytes&quot;: 1410, &quot;committed&quot;: false, &quot;search&quot;: true, &quot;version&quot;: &quot;7.0.0&quot;, &quot;compound&quot;: true, &quot;attributes&quot;: { } } } } ] } } } }  ","version":"Next","tagName":"h3"},{"title":"详细模式​","type":1,"pageTitle":"索引段 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_segments#详细模式","content":"要添加可用于调试的其他信息，请使用 verbose 标志。 警告 此功能是实验性的，在将来的版本中可能会完全更改或删除。Elastic 将尽最大努力解决任何问题，但实验性功能不受官方 GA 功能支持 SLA 的约束。 GET /test/_segments?verbose=true  API 返回以下响应： { ... &quot;_0&quot;: { ... &quot;ram_tree&quot;: [ { &quot;description&quot;: &quot;postings [PerFieldPostings(format=1)]&quot;, &quot;size_in_bytes&quot;: 2696, &quot;children&quot;: [ { &quot;description&quot;: &quot;format 'Lucene50_0' ...&quot;, &quot;size_in_bytes&quot;: 2608, &quot;children&quot; :[ ... ] }, ... ] }, ... ] } ... }  原文链接 ","version":"Next","tagName":"h3"},{"title":"索引分片存储 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#请求","content":"GET /&lt;target&gt;/_shard_stores GET /_shard_stores ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 monitor 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#描述","content":"索引分片存储 API 返回以下信息： 每个副本分片存在哪个节点每个副本分片分配的 ID每个副本分片唯一 ID打开分片索引时遇到的任何错误或早期故障导致的任何错误 默认情况，API 只返回未分配或有一到多个未分配副本分片的主分片存储信息。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 status （可选，字符串）用于限制请求的，逗号分隔的分片健康状态。 有效值包括： green 主分片和所有副本分片都已分配。 yellow 一个或多个副本分片未分配。 red 主分片未分配。 all 返回所有分片，忽略健康状态。 默认为 yellow,red。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#示例","content":"","version":"Next","tagName":"h2"},{"title":"获取特定数据流或索引的分片存储信息​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#获取特定数据流或索引的分片存储信息","content":"GET /test/_shard_stores  ","version":"Next","tagName":"h3"},{"title":"获取多个数据流和索引的分片存储信息​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#获取多个数据流和索引的分片存储信息","content":"GET /test1,test2/_shard_stores  ","version":"Next","tagName":"h3"},{"title":"获取所有数据流和索引的分片存储信息​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#获取所有数据流和索引的分片存储信息","content":"GET /_shard_stores  ","version":"Next","tagName":"h3"},{"title":"基于集群运行状况获取分片存储信息​","type":1,"pageTitle":"索引分片存储 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_shard_stores#基于集群运行状况获取分片存储信息","content":"你可以使用查询参数 status 来限制基于分片健康的返回信息。 以下的请求只返回已分配的主分片和副本分片信息。 GET /_shard_stores?status=green  API 返回以下响应： { &quot;indices&quot;: { &quot;my-index-00001&quot;: { &quot;shards&quot;: { &quot;0&quot;: { &quot;stores&quot;: [ { &quot;sPa3OgxLSYGvQ4oPs-Tajw&quot;: { &quot;name&quot;: &quot;node_t0&quot;, &quot;ephemeral_id&quot;: &quot;9NlXRFGCT1m8tkvYCMK-8A&quot;, &quot;transport_address&quot;: &quot;local[1]&quot;, &quot;attributes&quot;: {}, &quot;roles&quot;: [...] }, &quot;allocation_id&quot;: &quot;2iNySv_OQVePRX-yaRH_lQ&quot;, &quot;allocation&quot;: &quot;primary|replica|unused&quot;, &quot;store_exception&quot;: ... } ] } } } } }  &quot;0&quot;: { ： 密钥是存储信息的对应分片 id&quot;stores&quot;: [：分片所有副本的存储信息列表&quot;sPa3OgxLSYGvQ4oPs-Tajw&quot;: {： 托管存储副本的节点信息，密钥是唯一的节点 id&quot;allocation_id&quot;: &quot;2iNySv_OQVePRX-yaRH_lQ&quot;,：存储副本的分配 id&quot;allocation&quot;: &quot;primary|replica|unused&quot;： 存储副本的状态，无论它是否用作主副本、副本还是根本未使用&quot;store_exception&quot;: ...：打开分片索引或早期引擎故障时遇到的任何异常 原文链接 ","version":"Next","tagName":"h3"},{"title":"索引恢复 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#请求","content":"GET /&lt;target&gt;/_recovery GET /_recovery ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 monitor 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#描述","content":"使用索引恢复 API 获取有关正在进行和已完成的分片恢复的信息。 分片恢复是从主碎片同步副本碎片的过程。完成后，副本碎片可用于搜索。 在以下过程中自动进行恢复： 节点启动或失败。这种类型的恢复称为本地存储恢复。 主分片复制。 将分片重新定位到同一集群中的不同节点。 快照恢复。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#查询参数","content":"active_only （可选，布尔值）如果为 true，响应仅包括正在进行的分片恢复。默认为 false。 detailed （可选，布尔值）如果为 true，响应包含关于分片恢复的详细信息。默认为 false。 index （可选，字符串）用于限制请求的，逗号分隔的索引名的列表。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#响应体","content":"id （整数）分片 ID type （字符串）恢复类型，返回值包含： STORE 恢复与节点启动或故障有关。这种类型的恢复称为本地存储恢复。 SNAPSHOT 恢复与快照恢复有关。 REPLICA 恢复与主分片复本有关。 RELOCATING 恢复与将分片重新定位到同一集群中的不同节点有关。 STAGE （字符串）恢复阶段。返回值包含： DONE 完成。 FINALIZE 清除。 INDEX 读取索引元数据并将字节从源复制到目标。 INIT 恢复还未开始。 START 启动恢复过程；打开索引以供使用。 TRANSLOG 重放事务日志。 primary （布尔值）如果为 true，分片是主分片。 start_time （时间戳）恢复开始的时间戳。 stop_time （字符串）恢复结束的时间戳。 total_time_in_millis （字符串）以毫秒为单位，恢复分片的总时长。 source （对象）恢复的源。可以包含： 如果从快照恢复，则为存储库描述源节点的描述 target （对象）目标节点。 index （对象）关于物理索引恢复的统计信息。 translog （对象）关于事务日志恢复的统计信息。 start （对象）关于打开和启动索引时间的统计信息。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#示例","content":"","version":"Next","tagName":"h2"},{"title":"获取多个数据流和索引的恢复信息​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#获取多个数据流和索引的恢复信息","content":"GET index1,index2/_recovery?human  ","version":"Next","tagName":"h3"},{"title":"获取集群中所有数据流和索引的段信息​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#获取集群中所有数据流和索引的段信息","content":"GET /_recovery?human  API 返回以下响应： { &quot;index1&quot; : { &quot;shards&quot; : [ { &quot;id&quot; : 0, &quot;type&quot; : &quot;SNAPSHOT&quot;, &quot;stage&quot; : &quot;INDEX&quot;, &quot;primary&quot; : true, &quot;start_time&quot; : &quot;2014-02-24T12:15:59.716&quot;, &quot;start_time_in_millis&quot;: 1393244159716, &quot;stop_time&quot; : &quot;0s&quot;, &quot;stop_time_in_millis&quot; : 0, &quot;total_time&quot; : &quot;2.9m&quot;, &quot;total_time_in_millis&quot; : 175576, &quot;source&quot; : { &quot;repository&quot; : &quot;my_repository&quot;, &quot;snapshot&quot; : &quot;my_snapshot&quot;, &quot;index&quot; : &quot;index1&quot;, &quot;version&quot; : &quot;{version}&quot;, &quot;restoreUUID&quot;: &quot;PDh1ZAOaRbiGIVtCvZOMww&quot; }, &quot;target&quot; : { &quot;id&quot; : &quot;ryqJ5lO5S4-lSFbGntkEkg&quot;, &quot;host&quot; : &quot;my.fqdn&quot;, &quot;transport_address&quot; : &quot;my.fqdn&quot;, &quot;ip&quot; : &quot;10.0.1.7&quot;, &quot;name&quot; : &quot;my_es_node&quot; }, &quot;index&quot; : { &quot;size&quot; : { &quot;total&quot; : &quot;75.4mb&quot;, &quot;total_in_bytes&quot; : 79063092, &quot;reused&quot; : &quot;0b&quot;, &quot;reused_in_bytes&quot; : 0, &quot;recovered&quot; : &quot;65.7mb&quot;, &quot;recovered_in_bytes&quot; : 68891939, &quot;percent&quot; : &quot;87.1%&quot; }, &quot;files&quot; : { &quot;total&quot; : 73, &quot;reused&quot; : 0, &quot;recovered&quot; : 69, &quot;percent&quot; : &quot;94.5%&quot; }, &quot;total_time&quot; : &quot;0s&quot;, &quot;total_time_in_millis&quot; : 0, &quot;source_throttle_time&quot; : &quot;0s&quot;, &quot;source_throttle_time_in_millis&quot; : 0, &quot;target_throttle_time&quot; : &quot;0s&quot;, &quot;target_throttle_time_in_millis&quot; : 0 }, &quot;translog&quot; : { &quot;recovered&quot; : 0, &quot;total&quot; : 0, &quot;percent&quot; : &quot;100.0%&quot;, &quot;total_on_start&quot; : 0, &quot;total_time&quot; : &quot;0s&quot;, &quot;total_time_in_millis&quot; : 0, }, &quot;verify_index&quot; : { &quot;check_index_time&quot; : &quot;0s&quot;, &quot;check_index_time_in_millis&quot; : 0, &quot;total_time&quot; : &quot;0s&quot;, &quot;total_time_in_millis&quot; : 0 } } ] } }  此响应包括有关恢复单个分片的单个索引的信息。恢复的源是快照存储库，恢复的目标是 my_es_node。 响应还包括恢复的文件和字节的数量和百分比。 ","version":"Next","tagName":"h3"},{"title":"获取详细的恢复信息​","type":1,"pageTitle":"索引恢复 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_recovery#获取详细的恢复信息","content":"要获取恢复中的物理文件列表，设置查询参数 detailed 为 true。 GET _recovery?human&amp;detailed=true  API 返回以下响应： { &quot;index1&quot; : { &quot;shards&quot; : [ { &quot;id&quot; : 0, &quot;type&quot; : &quot;STORE&quot;, &quot;stage&quot; : &quot;DONE&quot;, &quot;primary&quot; : true, &quot;start_time&quot; : &quot;2014-02-24T12:38:06.349&quot;, &quot;start_time_in_millis&quot; : &quot;1393245486349&quot;, &quot;stop_time&quot; : &quot;2014-02-24T12:38:08.464&quot;, &quot;stop_time_in_millis&quot; : &quot;1393245488464&quot;, &quot;total_time&quot; : &quot;2.1s&quot;, &quot;total_time_in_millis&quot; : 2115, &quot;source&quot; : { &quot;id&quot; : &quot;RGMdRc-yQWWKIBM4DGvwqQ&quot;, &quot;host&quot; : &quot;my.fqdn&quot;, &quot;transport_address&quot; : &quot;my.fqdn&quot;, &quot;ip&quot; : &quot;10.0.1.7&quot;, &quot;name&quot; : &quot;my_es_node&quot; }, &quot;target&quot; : { &quot;id&quot; : &quot;RGMdRc-yQWWKIBM4DGvwqQ&quot;, &quot;host&quot; : &quot;my.fqdn&quot;, &quot;transport_address&quot; : &quot;my.fqdn&quot;, &quot;ip&quot; : &quot;10.0.1.7&quot;, &quot;name&quot; : &quot;my_es_node&quot; }, &quot;index&quot; : { &quot;size&quot; : { &quot;total&quot; : &quot;24.7mb&quot;, &quot;total_in_bytes&quot; : 26001617, &quot;reused&quot; : &quot;24.7mb&quot;, &quot;reused_in_bytes&quot; : 26001617, &quot;recovered&quot; : &quot;0b&quot;, &quot;recovered_in_bytes&quot; : 0, &quot;percent&quot; : &quot;100.0%&quot; }, &quot;files&quot; : { &quot;total&quot; : 26, &quot;reused&quot; : 26, &quot;recovered&quot; : 0, &quot;percent&quot; : &quot;100.0%&quot;, &quot;details&quot; : [ { &quot;name&quot; : &quot;segments.gen&quot;, &quot;length&quot; : 20, &quot;recovered&quot; : 20 }, { &quot;name&quot; : &quot;_0.cfs&quot;, &quot;length&quot; : 135306, &quot;recovered&quot; : 135306 }, { &quot;name&quot; : &quot;segments_2&quot;, &quot;length&quot; : 251, &quot;recovered&quot; : 251 } ] }, &quot;total_time&quot; : &quot;2ms&quot;, &quot;total_time_in_millis&quot; : 2, &quot;source_throttle_time&quot; : &quot;0s&quot;, &quot;source_throttle_time_in_millis&quot; : 0, &quot;target_throttle_time&quot; : &quot;0s&quot;, &quot;target_throttle_time_in_millis&quot; : 0 }, &quot;translog&quot; : { &quot;recovered&quot; : 71, &quot;total&quot; : 0, &quot;percent&quot; : &quot;100.0%&quot;, &quot;total_on_start&quot; : 0, &quot;total_time&quot; : &quot;2.0s&quot;, &quot;total_time_in_millis&quot; : 2025 }, &quot;verify_index&quot; : { &quot;check_index_time&quot; : 0, &quot;check_index_time_in_millis&quot; : 0, &quot;total_time&quot; : &quot;88ms&quot;, &quot;total_time_in_millis&quot; : 88 } } ] } }  响应包括恢复的所有物理文件及其大小的列表。 响应还包括各个恢复阶段的计时（以毫秒为单位）： 索引检索 音译重播 索引开始时间 此响应表示恢复已完成。所有恢复（无论是正在进行的还是已完成的）都保持在集群状态，并且可以随时报告。 要仅返回有关正在进行的恢复的信息，设置查询参数 active_only 为 true。 原文链接 ","version":"Next","tagName":"h2"},{"title":"索引统计 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#请求","content":"GET /&lt;target&gt;/_stats/&lt;index-metric&gt; GET /&lt;target&gt;/_stats GET /_stats ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 monitor 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#描述","content":"使用索引统计 API 获取一个或多个数据流和索引的高级聚合和统计信息。 默认情况下，返回的统计信息是索引级别的，包含 primaries 和 total 聚合。primaries 是仅主分片的值。total 是主分片和副本分片的累积值。 要获取分片级别统计信息，请将 level 参数设置为 shards。 移动到另一个节点时，将清除分片的碎片级别统计信息。尽管分片不再是节点的一部分，但该节点保留分片所贡献的任何节点级统计信息。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 &lt;index-metric&gt; （可选，字符串）用于限制请求的，逗号分隔的指标。支持的指标有： _all返回所有统计 completion完成建议统计。 docs尚未合并的文档数和已删除的文档数。索引刷新会影响统计。 fielddata字段数据统计。 flushFlush 统计 get获取统计，包括丢失的统计。 indexing索引统计。 merge合并统计。 query_cache查询缓存统计。 refresh刷新统计。 request_cache分片请求缓存统计。 search搜索统计信息，包括建议统计信息。你可以通过添加额外的 groups 参数（搜索操作可以与一个或多个组关联）来包括自定义组的统计信息。groups 参数接受以逗号分隔的组名列表。使用 _all 返回所有组的统计信息。 segments所有开放段的内存使用。 如果 include_segment_file_size 参数为 true，则此度量包括每个 Lucene 索引文件的聚合磁盘使用率。 store字节单位的索引大小。 suggest建议器统计。 translog事务日志统计。 warmerwarmer 统计。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#查询参数","content":"expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 fields （可选，字符串）逗号分隔的包含在统计中的字段列表或通配符表达式。 除非在 completion_fields 或 fielddata_fields 参数中提供了特定字段列表，否则用作默认列表。 completion_fields （可选，字符串）逗号分隔的包含在 fielddata 和 suggest 统计中的字段列表或通配符表达式。 fielddata_fields （可选，字符串）逗号分隔的包含在 fielddata 统计中的字段列表或通配符表达式。 forbid_closed_indices （可选，布尔值）如果为 true，不会从关闭索引统计。默认为 true。 groups （可选，字符串）逗号分隔的包含在 search 统计中的字段列表或通配符表达式。 level （可选，字符串）表明是在群集、索引还是分片级别聚合统计信息。 有效值有： cluster indices shards include_segment_file_sizes （可选，布尔值）如果为 true，该调用报告每个 Lucene 索引文件的聚合磁盘使用情况（仅在请求段统计信息时适用）。默认为 false。 include_unloaded_segments （可选，布尔值）如果为 true，响应包括来自未加载到内存中的段的信息。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#示例","content":"","version":"Next","tagName":"h2"},{"title":"获取多个数据流的统计信息并指示​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#获取多个数据流的统计信息并指示","content":"GET /index1,index2/_stats  ","version":"Next","tagName":"h3"},{"title":"获取群集中所有数据流和索引的统计信息​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#获取群集中所有数据流和索引的统计信息","content":"GET /_stats  ","version":"Next","tagName":"h3"},{"title":"获取指定的统计​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#获取指定的统计","content":"以下请求仅返回所有索引的 merge 和 refresh 统计信息。 GET /_stats/merge,refresh  ","version":"Next","tagName":"h3"},{"title":"获取特定搜索组的统计信息​","type":1,"pageTitle":"索引统计 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/index_stats#获取特定搜索组的统计信息","content":"以下请求仅返回 group1 和 group2 搜索组的搜索统计信息。 GET /_stats/search?groups=group1,group2  原文链接 ","version":"Next","tagName":"h3"},{"title":"列出悬空索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/list_dangling_indices","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"列出悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/list_dangling_indices#请求","content":"GET /_dangling  ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"列出悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/list_dangling_indices#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 manage 集群权限来使用此 API。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"列出悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/list_dangling_indices#描述","content":"如果 Elasticsearch 遇到当前集群状态中缺少的索引数据，则认为这些索引处于悬空状态。例如，如果在 Elasticsearch 节点脱机时删除多个 cluster.index.tombstones.size 索引，则可能会发生这种情况。 使用此 API 列出悬空索引，你就可以导入或删除它们。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"列出悬空索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/list_dangling_indices#示例","content":"API 返回以下响应： { &quot;dangling_indices&quot;: [ { &quot;index_name&quot;: &quot;my-index-000001&quot;, &quot;index_uuid&quot;: &quot;zmM4e0JtBkeUjiHD-MihPQ&quot;, &quot;creation_date_millis&quot;: 1589414451372, &quot;node_ids&quot;: [ &quot;pL47UN3dAb2d5RCWP6lQ3e&quot; ] } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"开启索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#请求","content":"POST /&lt;target&gt;/_open ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#描述","content":"你可以使用开启索引 API 重新打开关闭的索引。如果请求目标是数据流，请求重新打开任何数据流关闭的后备索引。 关闭的索引被阻止进行读/写操作，也不允许开启的索引允许的所有操作。在关闭的索引中无法索引文档或搜索文档。这允许关闭的索引不必维护索引或搜索文档的内部数据结构，以减少集群的开销。 当打开或关闭索引时，主节点负责重新启动索引分片以反映索引的新状态。分片将经过正常的恢复过程。打开的/关闭的索引数据由集群自动复制，以确保始终安全地保留足够的分片副本。 你可以打开和关闭多个索引。如果请求显示引用缺失的索引，会抛出错误。这个行为可以通用 ignore_unavailable=true 参数禁用。 所有索引可以通过 _all 作为索引名字或指定标识所有索引模式（如 *）来一次打开或关闭。 在配置文件中通过设置 action.destructive_requires_name 标识为 true，可以禁用通过通配符或 _all 来定义所有索引。这个设置也可以通过集群更新设置 API 来修改。 关闭的索引会消耗显著数量的硬盘空间，这在托管环境中可能会造成问题。通过集群设置 API 将 cluster.indices.close.enable 设置为 false，可以禁用关闭索引。默认值为 true。 在7.12.0及更早版本中，无法关闭数据流上的当前写入索引。为了关闭当前写索引，数据流必须先被翻转以便创建新的写入索引，这样之前的写入索引能被关闭。此限制从 7.12.1 不再适用。 ","version":"Next","tagName":"h2"},{"title":"等待活动分片​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#等待活动分片","content":"因为打开或关闭索引会分配其分片，在创建索引时，wait_for_active_shards 设置也适用于 _open 和 _close 索引操作。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（*）。 若要以集群中的所有数据流和索引为目标，省略此参数或使用 _all 或 *。 使用 _all 或 * 关闭所有索引。修改 action.destructive_requires_name 集群设置为 true，可以禁用通过 _all 或 * 关闭索引。你可以在文件 elasticsearch.yml 中 或通过 集群更新设置 API 来更新这个设置。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 wait_for_active_shards（可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。值 index-setting 指依据索引设置 index.write.wait_for_active_shards 等待。默认：0，意味着不等待任何分片准备。 参阅活动分片。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"开启索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/open_index#示例","content":"以下请求重新打开名为 my-index-000001 的关闭的索引。 POST /my-index-000001/_open  API 返回以下响应： { &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true }  原文链接 ","version":"Next","tagName":"h2"},{"title":"刷新 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#请求","content":"POST &lt;target&gt;/_refresh GET &lt;target&gt;/_refresh POST /_refresh GET /_refresh ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 maintenance 或 manage 索引权限 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#描述","content":"使用刷新 API 显式地使自上次刷新以来对一个或多个索引执行的所有操作可用于搜索。如果请求目标是数据流，它将刷新数据流的备份索引。 默认情况下，Elasticsearch 每秒定期刷新索引，但仅针对在过去 30 秒内收到一个或多个搜索请求的索引。你可以使用设置 index.refresh_interval 修改默认间隔。 刷新请求是异步的，不会返回响应直到刷新操作完成。 警告 刷新是资源密集型的。为了确保良好的集群性能，我们建议尽可能等待 Elasticsearch 的定期刷新，而不是执行显式刷新。 如果应用程序工作流为文档编制索引，然后运行搜索以检索索引文档，则建议使用索引 API 的 refresh=wait_for 参数选项。此选项确保索引操作在运行搜索之前等待定期刷新。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable （可选，布尔值）如果为 true，丢失或关闭的索引不包含在响应中。 默认为 false。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#示例","content":"","version":"Next","tagName":"h2"},{"title":"刷新多个数据流和索引​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#刷新多个数据流和索引","content":"POST /my-index-000001,my-index-000002/_refresh  ","version":"Next","tagName":"h3"},{"title":"刷新集群中所有数据流和索引​","type":1,"pageTitle":"刷新 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/refresh#刷新集群中所有数据流和索引","content":"POST /_refresh  原文链接 ","version":"Next","tagName":"h3"},{"title":"解析索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/resolve_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"解析索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/resolve_index#请求","content":"GET /_resolve/index/&lt;name&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"解析索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/resolve_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或索引别名必须有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"解析索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/resolve_index#路径参数","content":"&lt;name&gt; （必需，字符串）逗号分隔的待解析的索引、别名及数据流的名字或索引模式。在远程集群上的资源可以通过语法 &lt;cluster&gt;:&lt;name&gt; 指定。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"解析索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/resolve_index#查询参数","content":"expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"解析索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/resolve_index#示例","content":"GET /_resolve/index/f*,remoteCluster1:bar*?expand_wildcards=all  API 返回以下响应： { &quot;indices&quot;: [ { &quot;name&quot;: &quot;foo_closed&quot;, &quot;attributes&quot;: [ &quot;closed&quot; ] }, { &quot;name&quot;: &quot;freeze-index&quot;, &quot;aliases&quot;: [ &quot;f-alias&quot; ], &quot;attributes&quot;: [ &quot;frozen&quot;, &quot;open&quot; ] }, { &quot;name&quot;: &quot;remoteCluster1:bar-01&quot;, &quot;attributes&quot;: [ &quot;open&quot; ] } ], &quot;aliases&quot;: [ { &quot;name&quot;: &quot;f-alias&quot;, &quot;indices&quot;: [ &quot;freeze-index&quot;, &quot;my-index-000001&quot; ] } ], &quot;data_streams&quot;: [ { &quot;name&quot;: &quot;foo&quot;, &quot;backing_indices&quot;: [ &quot;.ds-foo-2099.03.07-000001&quot; ], &quot;timestamp_field&quot;: &quot;@timestamp&quot; } ] }  indices 与提供的名字或表达式匹配的所有索引aliases 与提供的名字或表达式匹配的所有别名data_streams 与提供的名字或表达式匹配的所有数据流 原文链接 ","version":"Next","tagName":"h2"},{"title":"模拟索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"模拟索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index#请求","content":"POST /_index_template/_simulate_index/&lt;index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"模拟索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"模拟索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index#路径参数","content":"&lt;index&gt;（必需，字符串）待模拟的索引名字 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"模拟索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index#查询参数","content":"master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"模拟索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index#响应体","content":"overlapping （数组）也与索引匹配的任意模板，但会被更高优先级模板取代。如果没有重叠（overlapping）模板，则响应包含空数组。 overlapping 属性 name （字符串）被取代模板的名字 index_patterns （数组）被取代模板将会应用的索引模式。 template （对象）将应用于索引的设置、映射和别名。 template 属性 aliases （对象）索引的别名。如果索引模板包含 data_stream，则不支持此参数。 &lt;alias&gt; （必需，对象）键值是别名名称。对象体包含别名的选项。 &lt;alias&gt; 属性 filter （可选，查询 DSL 对象）用于限制别名查询时可以访问的文档。 index_routing （可选，字符串）用于将索引操作路由到特定分片的值。如果指定，这将覆盖索引操作的路由值。 is_hidden （可选，布尔值）如果为 true，别名是隐藏的。默认为 false。别名所有的索引必须有相同的 is_hidden 值。 is_write_index （可选，布尔值）如果为 true，索引是别名的写索引。默认为 false。 routing （可选，字符串）用于将索引和搜索操作路由到特定分片的值。 search_routing （可选，字符串）用于将搜索操作路由到特定分片的值。如果指定，这将覆盖搜索操作的 routing 值。 mappings （可选，映射对象）索引中字段的映射。如果指定，此映射可以包括： 字段名字字段数据类型映射参数 参阅映射。 如果不应用映射，响应中将会忽略。 settings (可选，索引设置对象)索引的配置选项。参阅索引设置。 如果不应用设置，响应将包含一个空对象。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"模拟索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_index#示例","content":"以下示例显示了现有模板将应用于 my-index-000001 的配置。 PUT /_component_template/ct1 { &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 2 } } } PUT /_component_template/ct2 { &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_replicas&quot;: 0 }, &quot;mappings&quot;: { &quot;properties&quot;: { &quot;@timestamp&quot;: { &quot;type&quot;: &quot;date&quot; } } } } } PUT /_index_template/final-template { &quot;index_patterns&quot;: [&quot;my-index-*&quot;], &quot;composed_of&quot;: [&quot;ct1&quot;, &quot;ct2&quot;], &quot;priority&quot;: 5 } POST /_index_template/_simulate_index/my-index-000001  PUT /_component_template/ct1：创建一个组件模板（ct1），设置分片数为 2。PUT /_component_template/ct2：创建第二个组件模板（ct2），设置分片数为 0，并定义映射。PUT /_index_template/final-template：使用模板组件创建索引模板（final-template）。POST /_index_template/_simulate_index/my-index-000001：展示将应用于 my-index-000001 的配置。 响应展示被 final-template 应用的索引设置、映射和别名： { &quot;template&quot; : { &quot;settings&quot; : { &quot;index&quot; : { &quot;number_of_shards&quot; : &quot;2&quot;, &quot;number_of_replicas&quot; : &quot;0&quot; } }, &quot;mappings&quot; : { &quot;properties&quot; : { &quot;@timestamp&quot; : { &quot;type&quot; : &quot;date&quot; } } }, &quot;aliases&quot; : { } }, &quot;overlapping&quot; : [ { &quot;name&quot; : &quot;template_1&quot;, &quot;index_patterns&quot; : [ &quot;my-index-*&quot; ] } ] }  原文链接 ","version":"Next","tagName":"h2"},{"title":"收缩索引 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#请求","content":"POST /&lt;index&gt;/_shrink/&lt;target-index&gt; PUT /&lt;index&gt;/_shrink/&lt;target-index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 manage 索引权限。 在你能收缩一个索引前： 索引必须是只读的索引的所有主分片必须位于同一节点上集群健康状态必须为 green（绿色） 为了使分片分配更容易，我们建议你也移除索引的副本分片。你也可以稍后作为收缩操作的一部分，重新添加副本分片。 你也可以使用以下的更新索引设置 API 请求去移除一个索引副本分片，重分配索引的剩余分片到相同的节点，并让索引只读。 PUT /my_source_index/_settings { &quot;settings&quot;: { &quot;index.number_of_replicas&quot;: 0, &quot;index.routing.allocation.require._name&quot;: &quot;shrink_node_name&quot;, &quot;index.blocks.write&quot;: true } }  &quot;index.number_of_replicas&quot;: 0 移除索引的副本分片&quot;index.routing.allocation.require._name&quot;: &quot;shrink_node_name&quot; 把索引分片重分配给节点 shrink_node_name。参阅索引级分片分配过滤&quot;index.blocks.write&quot;: true 阻止索引的写操作。仍允许元数据变更，如删除索引。 重分配源索引会花一些时间。进度可以通过 _cat recovery API 追踪，或使用 集群健康 API 通过 wait_for_no_relocating_shards 参数等待所有分片重新定位。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#描述","content":"收缩索引 API 允许你收缩一个现有的索引收缩为具有较少主分片的新索引。目标索引中请求的主分片数必须是源索引分片数的一个因子。例如，一个有 8 个主分片的索引可以被缩为 4、2 或 1 主分片，或者一个有 15 个主分片的索引可以缩为 5、3 或 1。如果在索引中的分片数量是质数，则只能将其收缩为单个主分片。在收缩前，索引中的每个分片（主或副本）副本必须存在于同一个节点上。 在数据流的当前写索引不能被收缩。为了收缩当前写索引，这个数据流必须先被翻转，这样一个新的写索引能被创建，这样前一个写索引能被收缩。 ","version":"Next","tagName":"h2"},{"title":"收缩如何工作​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#收缩如何工作","content":"一个收缩操作： 创建一个新的目标索引，其定义与源索引一样的定义，但主分片数量更少将段从源索引硬链接到目标索引。(如果文件系统不支持硬链接，则会将所有段复制到新索引中，这是一个非常耗时的过程。另外，如果使用多个数据路径，不同数据路径上的分片如果不在同一硬盘上，则需要段文件的完整副本，因为硬链接不能跨硬盘工作）恢复目标索引，就像它是刚刚重新打开的关闭索引一样 ","version":"Next","tagName":"h2"},{"title":"收缩一个索引​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#收缩一个索引","content":"为了收缩 my_source_index 成为一个名为 my_target_index 的新索引，发出以下请求： POST /my_source_index/_shrink/my_target_index { &quot;settings&quot;: { &quot;index.routing.allocation.require._name&quot;: null, &quot;index.blocks.write&quot;: null } }  &quot;index.routing.allocation.require._name&quot;: null 清除从源索引复制的分配要求&quot;index.blocks.write&quot;: null 清除从源索引复制的索引写块 一旦将目标索引添加到集群状态，上述请求将立即返回——它不会等待收缩操作开始。 警告 只有满足以下要求，索引才能收缩: 目标索引必须不存在源索引必须有比目标索引更多的主分片目标索引主分片数量必须是源索引主分片数的因子。索引包含所有的分片文档不能超过 2,147,483,519，因为所有分片将缩小为目标索引上的单个分片，而这是可以放入单个分片的最大文档数。处理收缩过程的节点必须有足够的可用硬盘空间来容纳现有索引的第二个副本。 _shrink（收缩） API 类似于创建索引 API，且目标索引接受参数 settings 和 aliases。 POST /my_source_index/_shrink/my_target_index { &quot;settings&quot;: { &quot;index.number_of_replicas&quot;: 1, &quot;index.number_of_shards&quot;: 1, &quot;index.codec&quot;: &quot;best_compression&quot; }, &quot;aliases&quot;: { &quot;my_search_indices&quot;: {} } }  &quot;index.number_of_shards&quot;: 1 目标索引分片数量。必须是源索引的分片数量的因子。&quot;index.codec&quot;: &quot;best_compression&quot; 最佳压缩只有在对索引进行新的写入时才会生效，例如强制将分片合并到单个片段时。 提示 映射可以不在收缩请求中指定。 ","version":"Next","tagName":"h2"},{"title":"监控收缩过程​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#监控收缩过程","content":"收缩过程可以通过 _cat recovery API 监控，或者通过将 wait_for_status 参数设置为 yellow（黄色），使用集群健康 API等待所有主分片分配完毕。 在分配任何分片之前，目标索引一旦被添加到集群状态后，收缩 API 将返回。此时，所有碎片都处于 unassigned（未分配）状态。如果由于任何原因，目标索引无法在收缩节点上分配，则其主分片将保持 unassigned（未分配），直到可以在该节点上分配。 一旦分配了主分片，它就进入 initializing（初始化）状态，且收缩过程开始。收缩操作完成后，分片将变为 active（活动）状态。此时，Elasticsearch 将尝试分配任何副本，并可能决定将主分片重新定位到另一个节点。 ","version":"Next","tagName":"h2"},{"title":"等待活动分片​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#等待活动分片","content":"因为打开或关闭索引会分配其分片，在创建索引时，wait_for_active_shards 设置也适用于 _open 和 _close 索引操作。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#路径参数","content":"&lt;index&gt; （必需的，字符串）收缩的源索引名称 &lt;target-index&gt; （必需的，字符串）创建的目标索引名称 索引名字必须符合以下约定： 只能是小写字符不能包含字符：\\、/、*、?、&quot;、&lt;、&gt;、|、 (空格)、,、#7.0 之前索引可以包含冒号（:），但在 7.0 之后不推荐。不能以 -、_、+ 开头不能是 . 或 ..长度不能超过 255 字节（注意是字节，所以多字节字符会更快达到 255 的限制）名字以 . 开头不推荐，除非由插件管理的隐藏索引和内部索引 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#查询参数","content":"wait_for_active_shards（可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。默认为：1，主分片。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"收缩索引 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/shrink_index#请求体","content":"aliases （可选，别名对象）包含目标索引的索引别名。参阅批量索引别名。 settings （可选，索引设置对象）目标索引配置选项。参阅索引设置。 max_primary_shard_size （可选，字节单位）目标索引最大主分片大小。用于查找目标索引的最佳分片数。设置此参数后，每个分片在目标索引中的存储量将不会大于此参数。目标索引的分片数仍将是源索引分片数的一个因子，但如果该参数小于源索引中的单个分片大小，则目标索引的分数将等于源索引的分片数。例如，当该参数设置为 50gb 时，如果源索引有 60 个主分片，总计 100gb，则目标索引将有 2 个主分片，每个分片大小为 50gb；如果源索引有 60 个主碎片，总计 1000gb，那么目标索引将有 20 个主碎片；如果源索引有 60 个总容量为 4000gb 的主分片，那么目标索引仍将有 60 个主分片。此参数与 settings 中的 number_of_shards 冲突，它们只有一个能被应用。 原文链接 ","version":"Next","tagName":"h2"},{"title":"翻转 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#请求","content":"POST /&lt;rollover-target&gt;/_rollover/ POST /&lt;rollover-target&gt;/_rollover/&lt;target-index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对翻转目标必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#描述","content":"提示 我们推荐使用 ILM 的翻转操作来自动执行翻转。参阅索引生命周期 翻转 API 为数据流或索引别名创建一个新索引。API 的行为依赖翻转的目标。 ","version":"Next","tagName":"h2"},{"title":"翻转数据流​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#翻转数据流","content":"如果你翻转数据流，API 将为数据流创建一个新的写索引。流的前一个写索引会变为常规的协助索引。翻转还会增加数据流的辈分（generation）。 ","version":"Next","tagName":"h3"},{"title":"翻转带有写索引的索引别名​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#翻转带有写索引的索引别名","content":"提示 在 Elasticsearch 7.9 之前，你通常会使用带有写索引的索引别名来管理时序数据。数据流取代了这一功能，需要较少的维护，并自动与数据层集成。 参阅转换索引别名为数据流。 如果一个索引别名指向多个索引，其中一个索引必须为写索引。翻转 API 为别名创建一个新的写索引，并将它的 is_write_index 设置为 true。API 也会将前一个写索引设置 is_write_index 为 false。 ","version":"Next","tagName":"h3"},{"title":"翻转带有一个索引的索引别名​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#翻转带有一个索引的索引别名","content":"如果你翻转仅指向一个索引的索引别名，API 将为别名创建新索引，并从别名移除原始索引。 ","version":"Next","tagName":"h3"},{"title":"为别名增加索引名字​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#为别名增加索引名字","content":"当你翻转索引别名时，你可以为新索引指定名字。如果你不指定名字，且当前索引以 - 和数字结尾，比如 my-index-000001 或 my-index-3，新的索引名字会增加数字。例如，你翻转一个带有当前索引名字为 my-index-000001 的别名，翻转操作会创建一个名为 my-index-000002 的新索引。无论前一个索引名字是什么，这个数字总是 6 个字符并以 0 填充。 将日期数学与索引别名翻转一起使用如果你为时序数据使用索引别名，你可以在索引名字中使用日期数学以追踪翻转日期。例如，你可以创建一个指向索引名为 &lt;my-index-{now/d}-000001&gt; 的别名。如果你在2099年5月6日创建索引，索引名为 my-index-2099.05.06-000001。如果你在2099年5月7日翻转这个别名，新索引的名字为 my-index-2099.05.07-000002。例如，参阅翻转带有写索引的索引别名 ","version":"Next","tagName":"h2"},{"title":"等待活动分片​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#等待活动分片","content":"翻转创建一个新的索引，并受限于设置 wait_for_active_shards。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#路径参数","content":"&lt;rollover-target&gt; （必需的，字符串）待翻转的数据流或索引别名的名字。 &lt;target-index&gt; （可选的，字符串）创建的目标索引名称。支持日期数学。数据流不支持这个参数。 如果别名的当前写索引的名字不以 - 和数字结尾，例如 my-index-000001 或 my-index-3,这个参数是必需的。 索引名字必须符合以下约定： 只能是小写字符不能包含字符：\\、/、*、?、&quot;、&lt;、&gt;、|、 (空格)、,、#7.0 之前索引可以包含冒号（:），但在 7.0 之后不推荐。不能以 -、_、+ 开头不能是 . 或 ..长度不能超过 255 字节（注意是字节，所以多字节字符会更快达到 255 的限制）名字以 . 开头不推荐，除非由插件管理的隐藏索引和内部索引 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#查询参数","content":"dry_run （可选，布尔值）如果为 true，则检查当前索引是否匹配一个或多个指定条件（conditions），但不执行翻转。默认为 false。 include_type_name [7.0.0开始不推荐]（可选，布尔值）如果为 true,映射体中需要映射类型。默认为 false。 wait_for_active_shards （可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。默认为：1，主分片。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#请求体","content":"aliases （可选，别名对象）包含目标索引的索引别名。索引别名名字支持日期数学。 数据流不支持这个参数。 conditions （可选，对象）翻转的条件。如果指定，Elasticsearch 仅在当前索引满足以下一个或多个条件时执行翻转。如果参数未指定，Elasticsearch 无条件执行翻转。 警告 为了触发翻转，当前索引在请求时必须满足这些条件。Elasticsearch 不会在 API 响应后监视索引。要自动化翻转，改用 ILM 的翻转。 conditions 的属性 max_age （可选，时间单位）在达到创建索引所用的最长时间后触发翻转。从索引创建时间开始，始终计算运行的时间，即使索引起始日期配置为自定义日期，例如当使用设置 index.lifecycle.parse_origination_date 或 index.lifecycle.origination_date 。 max_docs （可选，整数）在达到指定的最大文档数后触发翻转。自上次刷新以来添加的文档不包括在文档计数中。文档计数不包括副本分片中的文档。 max_size （可选，字节单位）当索引达到一定大小时触发翻转。这是索引中所有主分片的总大小。副本不会被计算到最大索引大小。 提示 为查看当前索引大小，可以使用 _cat indices API。pri.store.size 值显示所有主分片的组合大小。 max_primary_shard_size （可选，字节单位）当索引中最大的主分片达到一定大小时触发翻转。主分片在索引中的最大值。同 max_size 一样，副本会被忽略。 提示 为了查看当前分片大小，可以使用 [_cat shards] API。store 值展示每个分片大小，prirep 指示一个分片是主分片（p）还是副本（r）。 mappings （可选，映射对象）索引中字段映射。如果指定，映射可以包含： 字段名字字段数据类型映射参数 参阅映射 数据流不支持这个参数。 settings （可选，索引设置对象）索引的配置选项。参阅索引设置 数据流不支持这个参数。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#响应体","content":"acknowledged （布尔值）如果为 true，请求在 timeout 周期内接收来自主节点的响应。 shards_acknowledged （布尔值）如果为 true，请求在 master_timeout 周期内接收来自活动分片的响应。 old_index （字符串）数据流或索引别名的前一个索引。对数据流和有写索引的索引别名，指前一个写索引。 new_index （字符串）翻转创建的索引。对数据洲和有写索引的索引别名，指当前写索引。 rolled_over （布尔值）如果为 true，数据流或索引别名翻转。 dry_run （布尔值）如果为 true，Elasticsearch 不执行翻转。 condition (对象)指定在请求的 conditions 里的每个条件的结果。如果未指定任何条件，这是一个空对象。 condition 的属性 &lt;condition&gt; （布尔值）键是每个条件。值是它的结果。如果为 true，该索引在翻转时满足条件。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#示例","content":"","version":"Next","tagName":"h2"},{"title":"翻转数据流​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#翻转数据流-1","content":"以下请求无条件翻转数据流。 POST my-data-stream/_rollover  如果当前写索引满足一个或多个以下的条件，以下的请求只翻转数据流： 索引在 7 天或更早前创建 索引包含 1,000 或更多的文档 索引最大的主分片是 50GB 或更大 POST my-data-stream/_rollover { &quot;conditions&quot;: { &quot;max_age&quot;: &quot;7d&quot;, &quot;max_docs&quot;: 1000, &quot;max_primary_shard_size&quot;: &quot;50gb&quot; } }  API 返回： { &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;old_index&quot;: &quot;.ds-my-data-stream-2099.05.06-000001&quot;, &quot;new_index&quot;: &quot;.ds-my-data-stream-2099.05.07-000002&quot;, &quot;rolled_over&quot;: true, &quot;dry_run&quot;: false, &quot;conditions&quot;: { &quot;[max_age: 7d]&quot;: false, &quot;[max_docs: 1000]&quot;: true, &quot;[max_primary_shard_size: 50gb]&quot;: false } }  ","version":"Next","tagName":"h3"},{"title":"翻转带有写索引的索引别名​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#翻转带有写索引的索引别名-1","content":"以下请求创建 &lt;my-index-{now/d}-000001&gt;，且将它设置为 my-alias 的写索引。 # PUT &lt;my-index-{now/d}-000001&gt; PUT %3Cmy-index-%7Bnow%2Fd%7D-000001%3E { &quot;aliases&quot;: { &quot;my-alias&quot;: { &quot;is_write_index&quot;: true } } }  如果当前写索引满足一个或多个以下的条件，以下的请求只翻转别名： 索引在 7 天或更早前创建 索引包含 1,000 或更多的文档 索引最大的主分片是 50GB 或更大 POST my-alias/_rollover { &quot;conditions&quot;: { &quot;max_age&quot;: &quot;7d&quot;, &quot;max_docs&quot;: 1000, &quot;max_primary_shard_size&quot;: &quot;50gb&quot; } }  API 返回： { &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;old_index&quot;: &quot;my-index-2099.05.06-000001&quot;, &quot;new_index&quot;: &quot;my-index-2099.05.07-000002&quot;, &quot;rolled_over&quot;: true, &quot;dry_run&quot;: false, &quot;conditions&quot;: { &quot;[max_age: 7d]&quot;: false, &quot;[max_docs: 1000]&quot;: true, &quot;[max_primary_shard_size: 50gb]&quot;: false } }  如果别名的索引名使用日期数学，并且你以固定的间隔翻转索引，则可以使用日期数学缩小搜索范围。例如，以下搜索目标索引是在过去三天创建的。 # GET /&lt;my-index-{now/d}-*&gt;,&lt;my-index-{now/d-1d}-*&gt;,&lt;my-index-{now/d-2d}-*&gt;/_search GET /%3Cmy-index-%7Bnow%2Fd%7D-*%3E%2C%3Cmy-index-%7Bnow%2Fd-1d%7D-*%3E%2C%3Cmy-index-%7Bnow%2Fd-2d%7D-*%3E/_search  ","version":"Next","tagName":"h3"},{"title":"翻转只有一个索引的索引别名​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#翻转只有一个索引的索引别名","content":"以下请求创建 &lt;my-index-{now/d}-000001&gt; 以及它的别名 my-write-alias。 # PUT &lt;my-index-{now/d}-000001&gt; PUT %3Cmy-index-%7Bnow%2Fd%7D-000001%3E { &quot;aliases&quot;: { &quot;my-write-alias&quot;: { } } }  如果当前索引满足一个或多个以下的条件，以下的请求只翻转别名： 索引在 7 天或更早前创建 索引包含 1,000 或更多的文档 索引最大的主分片是 50GB 或更大 POST my-write-alias/_rollover { &quot;conditions&quot;: { &quot;max_age&quot;: &quot;7d&quot;, &quot;max_docs&quot;: 1000, &quot;max_primary_shard_size&quot;: &quot;50gb&quot; } }  API 返回： { &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;old_index&quot;: &quot;my-index-2099.05.06-000001&quot;, &quot;new_index&quot;: &quot;my-index-2099.05.07-000002&quot;, &quot;rolled_over&quot;: true, &quot;dry_run&quot;: false, &quot;conditions&quot;: { &quot;[max_age: 7d]&quot;: false, &quot;[max_docs: 1000]&quot;: true, &quot;[max_primary_shard_size: 50gb]&quot;: false } }  ","version":"Next","tagName":"h3"},{"title":"在翻转时指定设置​","type":1,"pageTitle":"翻转 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/rollover_index#在翻转时指定设置","content":"典型的，你可以使用索引模板在翻转时自动配置索引创建。如果你翻转索引别名，你可以使用翻转 API 添加额外的索引设置或重写在模板中的设置。数据流不支持 settings 参数。  POST my-alias/_rollover { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 2 } }  原文链接 ","version":"Next","tagName":"h3"},{"title":"模拟索引模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#请求","content":"POST /_index_template/_simulate/&lt;index-template&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你使用此 API 必须有 manage_index_templates 或 manage 集群权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#路径参数","content":"&lt;index-template&gt; （可选，字符串）待模拟的索引模板名字。为了在将模板配置添加到集群之前测试模板配置，请省略此参数并在请求体中指定模板配置。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#查询参数","content":"create （可选，布尔值）如果为 true，则仅当没有与相同索引模式匹配的现有模板时，才会使用请求体中传递的模板。如果为 false，模拟将使用具有最高优先级的模板。请注意，无论哪种情况，模板都不会永久添加或更新；它仅用于模拟。默认为 false。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#请求体","content":"data_stream （可选，对象）如果包含此对象，则模板用于创建数据流及其备份索引。支持空对象。 数据流需要与 data_stream 对象匹配的索引模板。请参见创建索引模板。 data_stream 属性 hidden （可选，布尔值）如果为 true，数据流是隐藏的。默认为 false。 index_patterns （必需的，字符串数组）用于在创建时匹配数据流和索引名字的通配符（*）表达式数组。 Elasticsearch 包含几个内置的索引模板。为了避免这些模板的命名冲突，参阅避免索引模式冲突。 _meta （可选，对象）关于索引模板的可选用户元数据。可以有任意内容。Elasticsearch 不会自动生成此信息。 priority （可选，整数）用于在创建新数据流或索引时确定索引模板的优先级。具有最高优先级的索引模板先被选择。如果未指定优先级，则将模板视为优先级为 0（最低优先级）。Elasticsearch 不会自动生成此值。 template （可选，对象）要应用的模板。它可以选择包括别名、映射或设置配置。 template 属性 aliases （可选，对象）索引的别名。如果索引模板包含了 data_stream，此参数不被支持。 aliases 对象属性 &lt;alias&gt; （必需，对象）键值是别名名称。支持日期数学。 对象体包含别名的选项。支持空对象。 &lt;alias&gt; 属性 filter （可选，查询 DSL 对象）用于限制别名查询时可以访问的文档。 index_routing （可选，字符串）用于将索引操作路由到特定分片的值。如果指定，这将覆盖索引操作的路由值。 is_hidden （可选，布尔值）如果为 true，别名是隐藏的。默认为 false。别名所有的索引必须有相同的 is_hidden 值。 is_write_index （可选，布尔值）如果为 true，索引是别名的写索引。默认为 false。 routing （可选，字符串）用于将索引和搜索操作路由到特定分片的值。 search_routing （可选，字符串）用于将搜索操作路由到特定分片的值。如果指定，这将覆盖搜索操作的 routing 值。 mappings （可选，映射对象）索引中字段的映射。如果指定，此映射可以包括： 字段名字字段数据类型映射参数 参阅映射。 version （可选，整数）用于外部管理索引模板的版本号。Elasticsearch 不会自动生成此值。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#响应体","content":"overlapping （数组）被指定模板取代的任何模板。 overlapping 属性 name （字符串）被取代模板的名字 index_patterns （数组）被取代模板将会应用的索引模式。 template （对象）将应用于索引的设置、映射和别名。 template 属性 aliases （必需，对象）索引的别名。如果索引模板包含 data_stream，则不支持此参数。 aliases 对象属性 &lt;alias&gt; （必需，对象）键值是别名名称。支持日期数学。 对象体包含别名的选项。支持一个空对象。 &lt;alias&gt; 属性 filter （可选，查询 DSL 对象）用于限制别名查询时可以访问的文档。 index_routing （可选，字符串）用于将索引操作路由到特定分片的值。如果指定，这将覆盖索引操作的路由值。 is_hidden （可选，布尔值）如果为 true，别名是隐藏的。默认为 false。别名所有的索引必须有相同的 is_hidden 值。 is_write_index （可选，布尔值）如果为 true，索引是别名的写索引。默认为 false。 routing （可选，字符串）用于将索引和搜索操作路由到特定分片的值。 search_routing （可选，字符串）用于将搜索操作路由到特定分片的值。如果指定，这将覆盖搜索操作的 routing 值。 mappings （可选，映射对象）索引中字段的映射。如果指定，此映射可以包括： 字段名字字段数据类型映射参数 参阅映射。 如果不应用映射，响应中将会忽略。 settings (可选，索引设置对象)索引的配置选项。参阅索引设置。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#示例","content":"","version":"Next","tagName":"h2"},{"title":"模拟已有模板​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#模拟已有模板","content":"以下示例创建并模拟一个组合模板： PUT /_component_template/ct1 { &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 2 } } } PUT /_component_template/ct2 { &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_replicas&quot;: 0 }, &quot;mappings&quot;: { &quot;properties&quot;: { &quot;@timestamp&quot;: { &quot;type&quot;: &quot;date&quot; } } } } } PUT /_index_template/final-template { &quot;index_patterns&quot;: [&quot;my-index-*&quot;], &quot;composed_of&quot;: [&quot;ct1&quot;, &quot;ct2&quot;], &quot;priority&quot;: 5 } POST /_index_template/_simulate/final-template  PUT /_component_template/ct1：创建一个组合模板（ct1），设置分片为 2。PUT /_component_template/ct2：创建一个组合模板（ct2），设置复本为 0，并定义一个映射。PUT /_index_template/final-template：创建一个索引模板（final-template），用于组合模板。POST /_index_template/_simulate/final-template：展示应用于 final-template 的配置。 响应显示 final-template 应用的索引设置、映射和别名： { &quot;template&quot; : { &quot;settings&quot; : { &quot;index&quot; : { &quot;number_of_shards&quot; : &quot;2&quot;, &quot;number_of_replicas&quot; : &quot;0&quot; } }, &quot;mappings&quot; : { &quot;properties&quot; : { &quot;@timestamp&quot; : { &quot;type&quot; : &quot;date&quot; } } }, &quot;aliases&quot; : { } }, &quot;overlapping&quot; : [ ] }  &quot;number_of_shards&quot; : &quot;2&quot;：来自 ct1 的分片数量&quot;number_of_replicas&quot; : &quot;0&quot;：来自 ct2 的复本数量&quot;mappings&quot;：来自 ct1 的映射 ","version":"Next","tagName":"h3"},{"title":"模拟任意模板配置​","type":1,"pageTitle":"模拟索引模板 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/simulate_template#模拟任意模板配置","content":"要在将模板添加到集群之前查看模板将应用哪些设置，可以在请求正文中传递模板配置。如果指定的模板的优先级高于现有模板，则该模板将用于模拟。 POST /_index_template/_simulate { &quot;index_patterns&quot;: [&quot;my-index-*&quot;], &quot;composed_of&quot;: [&quot;ct2&quot;], &quot;priority&quot;: 10, &quot;template&quot;: { &quot;settings&quot;: { &quot;index.number_of_replicas&quot;: 1 } } }  响应显示优先级较低的任何重叠模板。 { &quot;template&quot; : { &quot;settings&quot; : { &quot;index&quot; : { &quot;number_of_replicas&quot; : &quot;1&quot; } }, &quot;mappings&quot; : { &quot;properties&quot; : { &quot;@timestamp&quot; : { &quot;type&quot; : &quot;date&quot; } } }, &quot;aliases&quot; : { } }, &quot;overlapping&quot; : [ { &quot;name&quot; : &quot;final-template&quot;, &quot;index_patterns&quot; : [ &quot;my-index-*&quot; ] } ] }  原文链接 ","version":"Next","tagName":"h3"},{"title":"拆分索引","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#请求","content":"POST /&lt;index&gt;/_split/&lt;target-index&gt; PUT /&lt;index&gt;/_split/&lt;target-index&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引必须有 manage 索引权限。 在你能拆分一个索引前： 索引必须是只读的集群健康 状态必须为 green（绿色） 你可以通过以下请求将索引设置为只读： PUT /my_source_index/_settings { &quot;settings&quot;: { &quot;index.blocks.write&quot;: true } }  阻止对索引的写操作，同时仍允许元数据修改（如删除索引） 在数据流的当前写索引不能被拆分。为了拆分当前写索引，这个数据流必须先被翻转，这样一个新的写索引被创建，前一个写索引才能被拆分。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#描述","content":"拆分索引 API 允许你将现有索引拆分为一个新索引，其中每个原始主分片在新索引中会被拆分为两个或更多的主分片。 索引能被拆分的次数（以及原始分片可以被拆分的的分片数量），由设置 index.number_of_routing_shards 决定。路由分片的数量指定内部使用的哈希空间，这个空间用于通过一致的哈希在分片之间分发文档。例如，一个 5 分片的索引，number_of_routing_shards 设置为 30（5 x 2 x 3），可以按因子 2 或 3 拆分。换而言之，它可以按以下方式进行拆分： 5 → 10 → 30 (除以 2, 再除以 3)5 → 15 → 30 (除以 3, 再除以 2)5 → 30 (除以 6) index.number_of_routing_shards 是静态索引设置。你只能在索引创建时或在关闭的索引上设置 index.number_of_routing_shards。 ","version":"Next","tagName":"h2"},{"title":"索引创建示例​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#索引创建示例","content":"以下的索引创建 API 创建了一个名为 my-index-000001 的索引，设置 index.number_of_routing_shards 为 30。 PUT /my-index-000001 { &quot;settings&quot;: { &quot;index&quot;: { &quot;number_of_routing_shards&quot;: 30 } } }  设置 index.number_of_routing_shards 的默认值，依赖于原始索引的主分片数。默认设计下，允许你按 2 的因子拆分到最大 1024 分片。然而，必须要考虑原始的主分片数。例如，一个索引创建时有 5 个主分片，它可以分为 10、20、40、80、160、320 或最大 640 个分片（通过一次拆分操作或多次拆分操作）。 如果原始索引包含一个主分片（或者一个多分片索引被收缩到一个主分片），那这个索引可以被分为大于 1 的任意数量分片。然后，路由分片的默认数量的属性将用于新拆分的索引。 ","version":"Next","tagName":"h3"},{"title":"拆分的原理​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#拆分的原理","content":"一个拆分操作： 创建一个与源索引相同定义的新的目标索引，但是会有更大数量的主分片。从源索引硬连接 segment（段）到目标索引。（如果文件系统不支持硬连接，那么所有的 segment（段）都会复制到新索引中，这是一个非常耗时的过程）在创建低级文件后，再次哈希所有文档，以删除属于不同分片的文档。恢复目标索引，就像刚被重新打开的关闭索引一样。 ","version":"Next","tagName":"h3"},{"title":"为什么 Elasticsearch 不支持增量重分片？​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#为什么-elasticsearch-不支持增量重分片","content":"从 N 个分片增加到 N+1 个分片，也被称为，增量重分片，它确实是所许多键值存储所支持的特性。添加一个新的分片并将新数据推送到这个新分片是不可行的：这可能是一个索引瓶颈，并且通过给定的 _id 确认一个文档属于哪个分片，必须通过查找（get）、删除（delete）和更新（update）请求，这相当复杂。这意味着我们需要通过不同的哈希表重平衡现有数据。 键值存储更高效的执行这个操作的常见方法是使用一致哈希。当碎片数从 N 增加到 N+1 时，一致哈希只需要重新定位第 1/N 个键值。然而 Elasticsearch 的存储单位，分片，是 Lucene 索引。由于他们面向搜索的数据结构，占据了 Lucene 索引的很大一部分，即使只有 5% 的文档，删除它们并索引它们到另一个分片，典型的要比键值存储有更高的成本。当通过上一节中描述的乘法因子来增加分片的数量时，该成本保持在合理的状态：这允许 Elasticsearch 能够在本地执行拆分，这能允许在索引级别执行拆分，而不是需要移动的重索引文档，也可以使用硬连接进行高效的文件复制。 在只追加数据的情况下，可以通过创建新索引并向其中推送新数据来来获得更大的灵活性，同时为读操作添加一个覆盖新旧索引的别名。假设旧索引和新索引分别有 M 和 N 个分片，这种情况与搜索有 M+N 个分片的索引相比没有更多开销。 ","version":"Next","tagName":"h3"},{"title":"拆分一个索引​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#拆分一个索引","content":"为了拆分 my_source_index 为一个名为 my_target_index 的新索引，假定以下操作： POST /my_source_index/_split/my_target_index { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 2 } }  一旦将目标索引添加到集群状态，上述请求将立即返回——它不会等待拆分操作开始。 警告 只有满足以下要求的索引才能拆分： 目标索引不存在源索引的主分片必须比目标索引更少目标索引的分片数必须是源索引分片的倍数处理拆分进程的节点必须有足够的可用磁盘空间来容纳现有索引的第二个副本 _split API 类似创建索引 API，也为目标索引接受参数 settings 和 aliases： POST /my_source_index/_split/my_target_index { &quot;settings&quot;: { &quot;index.number_of_shards&quot;: 5 }, &quot;aliases&quot;: { &quot;my_search_indices&quot;: {} } }  &quot;index.number_of_shards&quot;: 5 目标索引的分片数。必须是源索引分片数的倍数。 在 _split 请求中，不能指定映射（mapping）。 ","version":"Next","tagName":"h3"},{"title":"监控拆分过程​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#监控拆分过程","content":"拆分过程可以通过 _cat recovery API 监控，，或使用 集群健康 API 通过 wait_for_status 参数设置为 yellow（黄色）等待所有主分片成功分配。 _split API 一旦目标索引被添加到集群的状态，在任何分片被分配前，就会返回结果。这时，所有的分片都处于 unassigned（未分配）状态。如果由于任一原因，目标索引不能分配，它的主分片会保持 unassigned 直到它能在节点上分配。 一旦主节点被分配了，它的状态会变为 initializing（初始化中），拆分过程开始。当拆分操作完成，分片会变为 active（激活）。这时，Elasticsearch 会尝试分配任何副本，并可能决定主分片重定位到另一个节点。 ","version":"Next","tagName":"h3"},{"title":"等待活动分片​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#等待活动分片","content":"由于拆分操作创建一个新索引来拆分分片进去，所以在索引创建的设置等待活动分片也应用于拆分索引操作。 ","version":"Next","tagName":"h3"},{"title":"路径参数​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#路径参数","content":"&lt;index&gt; （必需，字符串）待拆分的源索引名字 &lt;target-index&gt; （必需，字符串）创建的目标索引名字 索引名字必须符合以下约定： 只能是小写字符不能包含字符：\\、/、*、?、&quot;、&lt;、&gt;、|、 (空格)、,、#7.0 之前索引可以包含冒号（:），但在 7.0 之后不推荐。不能以 -、_、+ 开头不能是 . 或 ..长度不能超过 255 字节（注意是字节，所以多字节字符会更快达到 255 的限制）名字以 . 开头不推荐，除非由插件管理的隐藏索引和内部索引 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#查询参数","content":"wait_for_active_shards（可选，字符串）在操作执行之前必须活动的分片复制数量。设置为 all 或任何正整数，最大值为索引分片总数（number_of_replicas+1）。默认为：1，主分片。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"拆分索引","url":"/docs/elasticsearch-cn/rest_apis/index_apis/split_index#请求体","content":"aliases （可选，别名对象）包含目标索引的索引别名。参阅批量索引别名。 settings （可选，索引设置对象）目标索引配置选项。参阅索引设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"解冻索引 API [X-Pack]","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/unfreeze_index","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"解冻索引 API [X-Pack]","url":"/docs/elasticsearch-cn/rest_apis/index_apis/unfreeze_index#请求","content":"POST /&lt;index&gt;/_unfreeze ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"解冻索引 API [X-Pack]","url":"/docs/elasticsearch-cn/rest_apis/index_apis/unfreeze_index#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标索引或索引别名必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"解冻索引 API [X-Pack]","url":"/docs/elasticsearch-cn/rest_apis/index_apis/unfreeze_index#描述","content":"当一个冻结索引被解冻，索引会通过正常的恢复过程再次变为可写。参阅已冻结索引和冻结索引。 警告 冻结一个索引会在同一个 API 调用中关闭这个索引并且重新打开它。这将导致在短时间内主分片不被分配，直到再次分配主分片前集群会变为红色（red）。这个限制在未来可能被移除。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"解冻索引 API [X-Pack]","url":"/docs/elasticsearch-cn/rest_apis/index_apis/unfreeze_index#路径参数","content":"&lt;index&gt; （必需，字符串）标识索引。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"解冻索引 API [X-Pack]","url":"/docs/elasticsearch-cn/rest_apis/index_apis/unfreeze_index#示例","content":"以下的示例冻结和解冻一个索引。 POST /my-index-000001/_freeze POST /my-index-000001/_unfreeze  原文链接 ","version":"Next","tagName":"h2"},{"title":"类型存在 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/type_exists","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"类型存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/type_exists#请求","content":"HEAD /&lt;index&gt;/_mapping/&lt;type&gt; ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"类型存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/type_exists#路径参数","content":"&lt;index&gt;（可选，字符串）用于限制请求的，逗号分隔的索引名字列表或通配符。 &lt;type&gt;（可选，字符串）用于限制请求的，逗号分隔类型列表或通配符。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"类型存在 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/type_exists#响应码","content":"200表明所有指定映射类型存在。 404表明一个或多个指定映射类型不存在。 原文链接 ","version":"Next","tagName":"h2"},{"title":"同步冲刷","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#请求","content":"POST /&lt;index&gt;/_flush/synced GET /&lt;index&gt;/_flush/synced POST /_flush/synced GET /_flush/synced ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#描述","content":"","version":"Next","tagName":"h2"},{"title":"使用同步冲刷 API​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#使用同步冲刷-api","content":"使用同步冲刷 API 手动启动同步冲刷。这对于计划中的群集重启非常有用：你可以停止索引，而不想等待 5 分钟，直到所有索引都标记为非活动并自动同步冲刷。 即使有正在进行的索引活动，你也可以请求同步冲刷，Elasticsearch 将在“尽力而为”的基础上执行同步冲刷：没有任何正在进行的索引活动的分片将成功同步冲刷，而其他分片将无法同步冲刷。只要 sync_id 标记没有被后续冲刷删除，成功同步冲刷的分片将有更快的恢复时间。 ","version":"Next","tagName":"h3"},{"title":"同步冲刷概览​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#同步冲刷概览","content":"Elasticsearch 跟踪哪些分片最近收到了索引活动，并认为 5 分钟内未收到任何索引操作的分片处于非活动状态。 当分片变为非活动状态时，Elasticsearch 将执行一种称为同步冲刷（synced flush）的特殊冲刷。同步冲刷对分片的每个副本执行正常冲刷，然后向每个副本添加称为 sync_id 的标记，以指示这些副本具有相同的 Lucene 索引。比较两个副本的 sync_id 标记是检查其内容是否相同的一种非常有效的方法。 分配分片副本时，Elasticsearch 必须确保每个副本包含与主副本相同的数据。如果分片副本已同步冲刷，并且副本与主副本共享一个 sync_id，则 Elasticsearch 知道这两个副本具有相同的内容。这意味着不需要将任何段文件从主文件复制到副本，这在恢复和重新启动期间节省了大量时间。 这对于具有大量很少更新的索引的集群特别有用，例如使用基于时间的索引。如果没有同步冲刷标记，这种集群的恢复速度会慢得多。 ","version":"Next","tagName":"h3"},{"title":"检查 sync_id 标记​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#检查-sync_id-标记","content":"要检查分片是否具有 sync_id 标记，请查找索引统计 API 返回的分片统计的 commit 部分： GET /my-index-000001/_stats?filter_path=**.commit&amp;level=shards  filter_path 用于减少响应的冗长，但完全是可选的 API 返回以下响应： { &quot;indices&quot;: { &quot;my-index-000001&quot;: { &quot;shards&quot;: { &quot;0&quot;: [ { &quot;commit&quot; : { &quot;id&quot; : &quot;3M3zkw2GHMo2Y4h4/KFKCg==&quot;, &quot;generation&quot; : 3, &quot;user_data&quot; : { &quot;translog_uuid&quot; : &quot;hnOG3xFcTDeoI_kvvvOdNA&quot;, &quot;history_uuid&quot; : &quot;XP7KDJGiS1a2fHYiFL5TXQ&quot;, &quot;local_checkpoint&quot; : &quot;-1&quot;, &quot;translog_generation&quot; : &quot;2&quot;, &quot;max_seq_no&quot; : &quot;-1&quot;, &quot;sync_id&quot; : &quot;AVvFY-071siAOuFGEO9P&quot;, &quot;max_unsafe_auto_id_timestamp&quot; : &quot;-1&quot;, &quot;min_retained_seq_no&quot; : &quot;0&quot; }, &quot;num_docs&quot; : 0 } } ] } } } }  &quot;sync_id&quot; : &quot;AVvFY-071siAOuFGEO9P&quot;,：sync id 标记 提示 一旦分片再次冲刷，sync_id 标记就会被删除，如果分片的事务中存在未冲刷的操作，Elasticsearch 可能随时触发分片的自动冲刷。在实践中，这意味着人们应该考虑索引上的任何索引操作，因为已经删除了它的同步标记。 ","version":"Next","tagName":"h3"},{"title":"请求参数​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#请求参数","content":"&lt;index&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。 要同步冲刷所有索引，忽略此参数或使用 * 或 _all。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable （可选，布尔值）如果为 true，丢失或关闭的索引不包含在响应中。 默认为 false。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#响应码","content":"200 所有分片成功同步冲刷。 409 一个副本分片同步冲刷失败。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#示例","content":"","version":"Next","tagName":"h2"},{"title":"同步冲刷一个指定索引​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#同步冲刷一个指定索引","content":"POST /kimchy/_flush/synced  ","version":"Next","tagName":"h3"},{"title":"同步冲刷几个索引​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#同步冲刷几个索引","content":"POST /kimchy,elasticsearch/_flush/synced  ","version":"Next","tagName":"h3"},{"title":"同步冲刷所有索引​","type":1,"pageTitle":"同步冲刷","url":"/docs/elasticsearch-cn/rest_apis/index_apis/synced_flush#同步冲刷所有索引","content":"POST /_flush/synced  响应包含有关成功同步冲刷的分片数量的详细信息以及有关任何失败的信息。 以下响应表示两个分片和一个副本分片已成功同步冲刷： { &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 2, &quot;failed&quot;: 0 }, &quot;my-index-000001&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 2, &quot;failed&quot;: 0 } }  以下响应表示一个分片组由于挂起的操作而失败： { &quot;_shards&quot;: { &quot;total&quot;: 4, &quot;successful&quot;: 2, &quot;failed&quot;: 2 }, &quot;my-index-000001&quot;: { &quot;total&quot;: 4, &quot;successful&quot;: 2, &quot;failed&quot;: 2, &quot;failures&quot;: [ { &quot;shard&quot;: 1, &quot;reason&quot;: &quot;[2] ongoing operations on primary&quot; } ] } }  有时故障特定于分片复制副本。失败的拷贝将不符合快速恢复的条件，但成功的拷贝仍将符合快速恢复的条件。该示例展示如下： { &quot;_shards&quot;: { &quot;total&quot;: 4, &quot;successful&quot;: 1, &quot;failed&quot;: 1 }, &quot;my-index-000001&quot;: { &quot;total&quot;: 4, &quot;successful&quot;: 3, &quot;failed&quot;: 1, &quot;failures&quot;: [ { &quot;shard&quot;: 1, &quot;reason&quot;: &quot;unexpected error&quot;, &quot;routing&quot;: { &quot;state&quot;: &quot;STARTED&quot;, &quot;primary&quot;: false, &quot;node&quot;: &quot;SZNr2J_ORxKTLUCydGX4zA&quot;, &quot;relocating_node&quot;: null, &quot;shard&quot;: 1, &quot;index&quot;: &quot;my-index-000001&quot; } } ] } }  原文链接 ","version":"Next","tagName":"h3"},{"title":"搜索 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"核心搜索​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/#核心搜索","content":"搜索多重搜索异步搜索时间点kNN 搜索建议器词语枚举滚动清除滚动 ","version":"Next","tagName":"h2"},{"title":"搜索测试​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/#搜索测试","content":"解释字段能力分析排序评估搜索分片验证 ","version":"Next","tagName":"h2"},{"title":"搜索模板​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/#搜索模板","content":"搜索模板多搜索模板渲染搜索模板 ","version":"Next","tagName":"h2"},{"title":"地理空间搜索​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/#地理空间搜索","content":"矢量块搜索 原文链接 ","version":"Next","tagName":"h2"},{"title":"更新索引设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#请求","content":"PUT /&lt;target&gt;/_settings ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 flat_settings （可选，布尔值）如果为 true，以平面格式返回设置。默认为 false。 ignore_unavailable （可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 preserve_existing （可选，布尔值）如果为 true，已有的索引设置保持不变。默认为 false。 master_timeout （可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout （可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#请求体","content":"settings （可选，索引设置对象）索引配置选项。参阅索引设置。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#示例","content":"","version":"Next","tagName":"h2"},{"title":"重置索引设置​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#重置索引设置","content":"要将设置还原为默认值，请使用 null。示例： PUT /my-index-000001/_settings { &quot;index&quot; : { &quot;refresh_interval&quot; : null } }  在索引模块中可以找到每个索引设置的列表，这些设置可以在活动索引上动态更新。 要防止更新已有设置，可以将 preserve_existing 请求参数设置为 true。 ","version":"Next","tagName":"h3"},{"title":"批量索引使用​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#批量索引使用","content":"例如，可以使用更新索引 API 动态地更改索引，使其在大容量索引中性能更好，然后将其移动到更实时的索引状态。在开始批量索引之前，请使用： PUT /my-index-000001/_settings { &quot;index&quot; : { &quot;refresh_interval&quot; : &quot;-1&quot; } }  （另一个优化选项是在没有任何副本的情况下启动索引，然后才添加副本，但这实际上取决于用例）。 然后，一旦完成批量索引，就可以更新设置（例如，返回到默认值）： PUT /my-index-000001/_settings { &quot;index&quot; : { &quot;refresh_interval&quot; : &quot;1s&quot; } }  并且，应调用强制合并： POST /my-index-000001/_forcemerge?max_num_segments=5  ","version":"Next","tagName":"h3"},{"title":"更新索引分析​","type":1,"pageTitle":"更新索引设置","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_index_settings#更新索引分析","content":"只能在关闭的索引上定义新的分析器。 要添加分析器，必须关闭索引，定义分析器，然后重新打开索引。 提示 你不能关闭数据流的写索引。 要为数据流的写入索引和将来的备份索引更新分析器，请在流使用的索引模板中更新分析器。然后翻转数据流，将新的分析器应用于流的写索引和未来的备份索引。这会影响滚动更新后添加到流中的搜索和任何新数据。但是，它不会影响数据流的支持索引或其现有数据。 要更改现有备份索引的分析器，必须创建新的数据流并将数据重新索引到其中。参阅使用重索引更改映射或设置。 例如，以下命令将为索引 my-index-000001 添加内容分析器： POST /my-index-000001/_close?wait_for_active_shards=0 PUT /my-index-000001/_settings { &quot;analysis&quot; : { &quot;analyzer&quot;:{ &quot;content&quot;:{ &quot;type&quot;:&quot;custom&quot;, &quot;tokenizer&quot;:&quot;whitespace&quot; } } } } POST /my-index-000001/_open  原文链接 ","version":"Next","tagName":"h3"},{"title":"清除滚动 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/clear_scroll","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"清除滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/clear_scroll#请求","content":"DELETE /_search/scroll/&lt;scroll_id&gt; [7.0.0] DELETE /_search/scroll ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"清除滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/clear_scroll#路径参数","content":"&lt;scroll_id&gt;[7.0.0]（可选，字符串）搜索的滚动 ID。 警告 滚动 ID 可能很长。我们建议仅使用 scroll_id 请求体参数指定滚动 ID。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"清除滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/clear_scroll#查询参数","content":"scroll_id[7.0.0]（可选，字符串）搜索的滚动 ID。 警告 滚动 ID 可能很长。我们建议仅使用 scroll_id 请求体参数指定滚动 ID。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"清除滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/clear_scroll#请求体","content":"scroll_id （必需，字符串）搜索的滚动 ID。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"清除滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/clear_scroll#响应体","content":"succeeded （布尔值）如果为 true，请求成功。这并不表示是否清除了任何滚动搜索请求。 num_freed （整数）已清除的滚动搜索请求数。 原文链接 ","version":"Next","tagName":"h2"},{"title":"解释 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#请求","content":"GET /&lt;index&gt;/_explain/&lt;id&gt; POST /&lt;index&gt;/_explain/&lt;id&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#描述","content":"解释 API 计算查询和特定文档的分数解释。无论文档是否匹配特定查询，这都可以提供有用的反馈。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#路径参数","content":"&lt;id&gt;（必需，整数）定义文档 ID。 &lt;index&gt;（必需，字符串）用于限制请求的索引名字。 此参数只能提供一个索引名字。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#查询参数","content":"analyzer（可选，字符串）用于查询字符串的分析器。 仅当指定了 q 查询字符串参数时，才能使用此参数。 analyze_wildcard（可选，布尔值）如果为 true，通配符和前缀查询将被分析。默认为 false。 仅当 q 查询参数被指定时，此参数可用。 default_operator（可选，字符串）查询字符串查询的默认运算符：AND 或 OR。默认为 OR。 仅当 q 查询参数被指定时，此参数可用。 df（可选，字符串）在查询字符串中未给出字段前缀的情况下，要用作默认值的字段。 仅当 q 查询参数被指定时，此参数可用。 lenient（可选，布尔值）如果为 true，将忽略查询字符串中基于格式的查询失败（例如向数字字段提供文本）。默认为 false。 仅当 q 查询参数被指定时，此参数可用。 preference（可选，字符串）用于执行搜索的节点或分片。默认随机。 q（可选，字符串）使用 Lucene 查询字符串语法进行查询。 stored_fields（可选，字符串）响应返回的，以逗号分隔的存储字段列表。 routing（可选，字符串）用于将索引和搜索操作路由到特定分片的值。 _source（可选，字符串）是否返回 _source 字段或字段列表。 _source_excludes（可选，字符串）逗号分隔的从响应中排除的源字段。 你还可以使用此参数从 _source_includes 查询参数中指定的子集中排除字段。 如果 _source 参数为 false，此参数会被忽略。 _source_includes（可选，字符串）逗号分隔的响应中要包含的源字段。 如果此参数指定，只有这些源字段会返回。你可以使用 _source_excludes 查询参数从该子集中排除字段。 如果 _source 参数为 false，此参数会被忽略。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#请求体","content":"query（可选，查询对象）使用 Query DSL 定义搜索定义。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"解释 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/explain#示例","content":"GET /my-index-000001/_explain/0 { &quot;query&quot; : { &quot;match&quot; : { &quot;message&quot; : &quot;elasticsearch&quot; } } }  API 返回以下响应： { &quot;_index&quot;:&quot;my-index-000001&quot;, &quot;_id&quot;:&quot;0&quot;, &quot;matched&quot;:true, &quot;explanation&quot;:{ &quot;value&quot;:1.6943598, &quot;description&quot;:&quot;weight(message:elasticsearch in 0) [PerFieldSimilarity], result of:&quot;, &quot;details&quot;:[ { &quot;value&quot;:1.6943598, &quot;description&quot;:&quot;score(freq=1.0), computed as boost * idf * tf from:&quot;, &quot;details&quot;:[ { &quot;value&quot;:2.2, &quot;description&quot;:&quot;boost&quot;, &quot;details&quot;:[] }, { &quot;value&quot;:1.3862944, &quot;description&quot;:&quot;idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:&quot;, &quot;details&quot;:[ { &quot;value&quot;:1, &quot;description&quot;:&quot;n, number of documents containing term&quot;, &quot;details&quot;:[] }, { &quot;value&quot;:5, &quot;description&quot;:&quot;N, total number of documents with field&quot;, &quot;details&quot;:[] } ] }, { &quot;value&quot;:0.5555556, &quot;description&quot;:&quot;tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:&quot;, &quot;details&quot;:[ { &quot;value&quot;:1.0, &quot;description&quot;:&quot;freq, occurrences of term within document&quot;, &quot;details&quot;:[] }, { &quot;value&quot;:1.2, &quot;description&quot;:&quot;k1, term saturation parameter&quot;, &quot;details&quot;:[] }, { &quot;value&quot;:0.75, &quot;description&quot;:&quot;b, length normalization parameter&quot;, &quot;details&quot;:[] }, { &quot;value&quot;:3.0, &quot;description&quot;:&quot;dl, length of field&quot;, &quot;details&quot;:[] }, { &quot;value&quot;:5.4, &quot;description&quot;:&quot;avgdl, average length of field&quot;, &quot;details&quot;:[] } ] } ] } ] } }  还有一种更简单的方法可以通过 q 参数指定查询。然后对指定的 q 参数值进行解析，就像使用了查询字符串查询一样。解释 API 中 q 参数的用法示例： GET /my-index-000001/_explain/0?q=message:search  API 返回与之前请求一致的结果。 原文链接 ","version":"Next","tagName":"h3"},{"title":"更新映射 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#请求","content":"PUT /&lt;target&gt;/_mapping ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或索引别名必须有 manage 索引权限。 [7.9开始不推荐] 如果请求以索引或索引别名为目标，你也可以通过索引权限 create、create_doc、index 或 write 来更新它的映射。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#路径参数","content":"&lt;target&gt; （必需，字符串）用于限制请求的，逗号分隔的数据流、索引和别名列表。支持通配符（）。为了标明所有数据流和索引，省略这个参数或者使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#查询参数","content":"allow_no_indices （可选，布尔值）如果为 false，如果任何通配符表达式、索引别名或 _all 值只针对丢失或关闭的索引，则请求返回一个错误。即使请求以其他开放索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，但没有索引以 bar 开头，以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards （可选，字符串）通配符表达式能匹配的索引类型。如果请求目标为数据流，则此参数确定通配符表达式是否匹配隐藏的数据流则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔列表的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 include_type_name[7.0.0开始不推荐] （可选，布尔值）如果为 true，映射体中需要映射类型。 ignore_unavailable（可选，布尔值）如果为 true，请求不存在的索引将返回错误。默认为 false。 master_timeout（可选，时间单位）等待连接到主节点的时间。如果在超时过期前没有收到响应，则请求失败并返回错误。默认为 30s。 timeout（可选，时间单位）等待响应的时间。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为 30s。 write_index_only（可选，布尔值）如果为 true，映射只应用于目标的当前写索引。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#请求体","content":"properties（必需，映射对象）字段的映射。对新字段，映射可以包含： 字段名字字段数据类型映射参数 对已有字段，参阅 变更已有字段的映射。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#示例","content":"","version":"Next","tagName":"h2"},{"title":"单目标示例​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#单目标示例","content":"更新映射 API 必需一个已有的数据流或索引。以下的创建索引 API 请求创建一个无映射的名为 publications 的索引。 PUT /publications  以下更新映射 API 请求，为索引 publications 添加了一个名为 title 的文本（text）字段。 PUT /publications/_mapping { &quot;properties&quot;: { &quot;title&quot;: { &quot;type&quot;: &quot;text&quot;} } }  ","version":"Next","tagName":"h3"},{"title":"多个目标​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#多个目标","content":"更新映射 API 可以通过一个请求应用于多个数据流或索引。例如，你可以同时为索引 my-index-000001 和 my-index-000002 更新映射： # Create the two indices PUT /my-index-000001 PUT /my-index-000002 # Update both mappings PUT /my-index-000001,my-index-000002/_mapping { &quot;properties&quot;: { &quot;user&quot;: { &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } } }  ","version":"Next","tagName":"h3"},{"title":"为现有对象字段添加新属性​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#为现有对象字段添加新属性","content":"你可以使用更新映射 API 为现有对象字段添加属性。为了查看如何运作，试试以下的例子。 通过创建索引 API 创建一个索引，带有名为 name 的对象字段，其中包含 first 文本字段。 PUT /my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;name&quot;: { &quot;properties&quot;: { &quot;first&quot;: { &quot;type&quot;: &quot;text&quot; } } } } } }  通过更新映射 API 向 name 字段中添加一个 last 文本字段。 PUT /my-index-000001/_mapping { &quot;properties&quot;: { &quot;name&quot;: { &quot;properties&quot;: { &quot;last&quot;: { &quot;type&quot;: &quot;text&quot; } } } } }  ","version":"Next","tagName":"h3"},{"title":"为现有字段添加多个字段​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#为现有字段添加多个字段","content":"多字段允许你以不同的方式索引同一字段。你可以通过更新映射 API 来更新 fields 映射参数，且对已有字段也支持多字段。 为了观察如何运作，试试以下例子。 通过创建索引 API 创建一个索引，带有名为 city 的文本（text）字段。 PUT /my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;city&quot;: { &quot;type&quot;: &quot;text&quot; } } } }  虽然全文搜索下文本字段运行良好，但是 keyword 字段不被解析，对排序或聚集中可能效果更好。 通过更新映射 API 为 city 字段启用多字段。这个请求将添加一个 city.raw 关键字多字段，可以用于排序。 PUT /my-index-000001/_mapping { &quot;properties&quot;: { &quot;city&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;raw&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } } }  ","version":"Next","tagName":"h3"},{"title":"变更现有字段支持的映射参数​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#变更现有字段支持的映射参数","content":"每个映射参数的文档指示是否可以使用更新映射 API 为现有字段更新它。例如，你可以使用更新映射 API 来更新 ignore_above 参数。 为了观察如何运作，试试以下例子。 通过创建索引 API 创建一个索引，包含名为 user_id 的 keyword 字段。user_id 字段有一个参数名为 ignore_above，值为 20。 PUT /my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;user_id&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 20 } } } }  通过更新映射 API 变更 ignore_above 参数值为 100。 PUT /my-index-000001/_mapping { &quot;properties&quot;: { &quot;user_id&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 100 } } }  ","version":"Next","tagName":"h3"},{"title":"变更已有字段的映射​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#变更已有字段的映射","content":"除了支持映射参数，你不能变更已有字段的映射或字段类型。变更已有字段可能导致已被索引的数据无效。 如果你需要变更在数据流备份索引中字段映射，参阅为数据流变更映射和设置。 如果你需要变更其他索引的中的字段的映射，创建一个正确映射的新索引，再把数据重索引（reindex）到这个索引。 为了观察如何变更一个索引的已有字段的映射，试试以下例子。 通过创建索引 API 创建一个索引，包含名为 user_id 的字段，字段类型为 long。 PUT /my-index-000001 { &quot;mappings&quot; : { &quot;properties&quot;: { &quot;user_id&quot;: { &quot;type&quot;: &quot;long&quot; } } } }  通过索引 API 索引多个具有 user_id 字段值的文档。 POST /my-index-000001/_doc?refresh=wait_for { &quot;user_id&quot; : 12345 } POST /my-index-000001/_doc?refresh=wait_for { &quot;user_id&quot; : 12346 }  为了变更 user_id 字段为 keyword 字段类型，通过创建索引 API 来创建一个正确映射的新索引。 PUT /my-new-index-000001 { &quot;mappings&quot; : { &quot;properties&quot;: { &quot;user_id&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } }  通过重索引 API 从旧索引复制文档到新索引。 POST /_reindex { &quot;source&quot;: { &quot;index&quot;: &quot;my-index-000001&quot; }, &quot;dest&quot;: { &quot;index&quot;: &quot;my-new-index-000001&quot; } }  ","version":"Next","tagName":"h3"},{"title":"重命名字段​","type":1,"pageTitle":"更新映射 API","url":"/docs/elasticsearch-cn/rest_apis/index_apis/update_mapping#重命名字段","content":"重命名字段会让旧名字下已被索引的数据失效。换个方法，添加一个 alias 字段来创建一个替代的字段名。 例如，通过创建索引 API 创建一个带有 user_identifier 字段的索引。 PUT /my-index-000001 { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;user_identifier&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } }  通过更新映射 API 为已有的 user_identifier 字段添加一个 user_id 字段别名。 PUT /my-index-000001/_mapping { &quot;properties&quot;: { &quot;user_id&quot;: { &quot;type&quot;: &quot;alias&quot;, &quot;path&quot;: &quot;user_identifier&quot; } } }  原文链接 ","version":"Next","tagName":"h3"},{"title":"异步搜索","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/async_search","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"提交异步搜索 API​","type":1,"pageTitle":"异步搜索","url":"/docs/elasticsearch-cn/rest_apis/search_apis/async_search#提交异步搜索-api","content":"异步执行搜索请求。它接受与搜索 API 相同的参数和请求体。 POST /sales*/_async_search?size=0 { &quot;sort&quot;: [ { &quot;date&quot;: { &quot;order&quot;: &quot;asc&quot; } } ], &quot;aggs&quot;: { &quot;sale_date&quot;: { &quot;date_histogram&quot;: { &quot;field&quot;: &quot;date&quot;, &quot;calendar_interval&quot;: &quot;1d&quot; } } } }  响应包含正在执行的搜索的标识符。你可以使用此 ID 稍后检索搜索的最终结果。当前可用的搜索结果将作为响应对象的一部分返回。 { &quot;id&quot; : &quot;FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=&quot;, &quot;is_partial&quot; : true, &quot;is_running&quot; : true, &quot;start_time_in_millis&quot; : 1583945890986, &quot;expiration_time_in_millis&quot; : 1584377890986, &quot;response&quot; : { &quot;took&quot; : 1122, &quot;timed_out&quot; : false, &quot;num_reduce_phases&quot; : 0, &quot;_shards&quot; : { &quot;total&quot; : 562, &quot;successful&quot; : 3, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 }, &quot;hits&quot; : { &quot;total&quot; : { &quot;value&quot; : 157483, &quot;relation&quot; : &quot;gte&quot; }, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] } } }  &quot;id&quot; : &quot;FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=&quot;：异步搜索的标识符，可用于监视其进度、检索其结果和/或删除它&quot;is_partial&quot; : true： 当查询不再运行时，指示在所有分片上搜索是失败还是成功完成。执行查询时，is_partial 始终设置为 true&quot;is_running&quot; : true：搜索是否仍在执行或已完成&quot;total&quot; : 562：总共有多少个分片将被执行搜索&quot;successful&quot; : 3：有多少分片成功完成了搜索&quot;value&quot; : 157483：当前有多少文档与查询匹配，这些文档属于已完成搜索的分片 提示 虽然查询不再运行，因此 is_running 设置为 false，但结果可能是部分的。如果某些分片返回结果后搜索失败，或者协调异步搜索的节点死亡，就会发生这种情况。 通过提供 wait_for_completion_timeout 参数（默认为 1 秒），可以阻止并等待搜索完成，直到达到某个超时。当异步搜索在这样的超时内完成时，响应将不包括ID，因为结果不存储在集群中。keep_on_completion 参数（默认为 false）可以设置为 true，以请求存储结果，以便在 wait_for_completion_timeout 内搜索完成时，也可以进行后续检索。 你还可以通过 keep_alive 参数指定异步搜索需要多长时间可用，该参数默认为 5d（五天）。在此期间之后，将删除正在进行的异步搜索和任何保存的搜索结果。 提示 当结果的主要排序是索引字段时，分片将根据其为该字段保留的最小值和最大值进行排序，因此部分结果将根据请求的排序标准可用。 提交异步搜索 API 支持与搜索 API 相同的[参数]((/rest_apis/search_apis/search#查询参数)，尽管有些参数具有不同的默认值： batched_reduce_size 默认为 5：这会影响部分结果可用的频率，这会在碎片结果减少时发生。每次协调节点收到一定数量的新碎片响应（默认情况下为 5）时，都会执行部分减少。 request_cache 默认为 true pre_filter_shard_size 默认为 1 且不能被修改：这是为了强制执行预筛选往返，以从每个切分中检索统计信息，从而跳过那些肯定不包含任何与查询匹配的文档的切分。 ccs_minimize_roundtrips 默认为 false，且是唯一支持的值。 警告 异步搜索不支持仅包含建议部分的滚动或搜索请求。仅当 ccs_minimize_roundtrips 设置为 false 时，才支持跨群集搜索。 提示 默认情况下，7.x 版本 Elasticsearch 不会限制存储的异步搜索响应的大小。存储大量异步响应可能会破坏集群的稳定性。如果要设置最大允许大小的限制，请更改搜 search.max_async_search_response_size 集群级设置。之后，尝试存储大于此设置的异步响应将导致错误。 ","version":"Next","tagName":"h2"},{"title":"获取异步搜索​","type":1,"pageTitle":"异步搜索","url":"/docs/elasticsearch-cn/rest_apis/search_apis/async_search#获取异步搜索","content":"获取异步搜索 API 根据之前提交的异步搜索请求的 id 检索其结果。如果启用了 Elasticsearch 安全功能，则对特定异步搜索结果的访问仅限于提交该请求的用户或 API 密钥。 GET /_async_search/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=  { &quot;id&quot; : &quot;FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=&quot;, &quot;is_partial&quot; : true, &quot;is_running&quot; : true, &quot;start_time_in_millis&quot; : 1583945890986, &quot;expiration_time_in_millis&quot; : 1584377890986, &quot;response&quot; : { &quot;took&quot; : 12144, &quot;timed_out&quot; : false, &quot;num_reduce_phases&quot; : 46, &quot;_shards&quot; : { &quot;total&quot; : 562, &quot;successful&quot; : 188, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 }, &quot;hits&quot; : { &quot;total&quot; : { &quot;value&quot; : 456433, &quot;relation&quot; : &quot;eq&quot; }, &quot;max_score&quot; : null, &quot;hits&quot; : [ ] }, &quot;aggregations&quot; : { &quot;sale_date&quot; : { &quot;buckets&quot; : [] } } } }  &quot;is_partial&quot; : true：当查询不再运行时，指示在所有分片上搜索是失败还是成功完成。执行查询时，is_partial 始终设置为 true&quot;is_running&quot; : true：搜索是否仍在执行或已完成&quot;expiration_time_in_millis&quot; : 1584377890986：异步搜索将在何时过期&quot;num_reduce_phases&quot; : 46：表示已执行了多少次结果缩减。如果与上次检索的结果相比，这个数字增加了，那么你可以期望搜索响应中包含更多的结果&quot;successful&quot; : 188：指示已执行查询的分片数。请注意，为了将碎片结果包含在搜索响应中，需要首先减少分片结果。&quot;aggregations&quot; ：部分聚合结果，来自已完成查询执行的分片。 调用获取异步搜索 API 时，还可以提供 wait_for_completion_timeout 参数，以便在提供的超时之前等待搜索完成。如果在超时过期之前可用，将返回最终结果，否则在超时过期后将返回当前可用的结果。默认情况下，未设置超时，这意味着将返回当前可用的结果，而无需任何额外等待。 keep_alive 参数指定异步搜索在集群中的可用时间。未指定时，将使用带有相应提交异步请求的 keep_alive 集。否则，可以覆盖该值并扩展请求的有效性。此期限到期后，如果搜索仍在运行，将取消搜索。如果搜索完成，其保存的结果将被删除。 ","version":"Next","tagName":"h2"},{"title":"获取异步搜索状态​","type":1,"pageTitle":"异步搜索","url":"/docs/elasticsearch-cn/rest_apis/search_apis/async_search#获取异步搜索状态","content":"获取异步搜索状态 API 不检索搜索结果，只显示之前提交的异步搜索请求的状态（给定其 id）。如果启用了 Elasticsearch 安全功能，则对获取异步搜索状态 API 的访问仅限于监视用户（monitoring_user）角色。 GET /_async_search/status/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=  { &quot;id&quot; : &quot;FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=&quot;, &quot;is_running&quot; : true, &quot;is_partial&quot; : true, &quot;start_time_in_millis&quot; : 1583945890986, &quot;expiration_time_in_millis&quot; : 1584377890986, &quot;_shards&quot; : { &quot;total&quot; : 562, &quot;successful&quot; : 188, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 } }  &quot;successful&quot; : 188：指示到目前为止已执行查询的分片数。 对于已完成的异步搜索，状态响应有一个额外的 completion_status 字段，显示已完成异步搜索的状态代码。 { &quot;id&quot; : &quot;FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=&quot;, &quot;is_running&quot; : false, &quot;is_partial&quot; : false, &quot;start_time_in_millis&quot; : 1583945890986, &quot;expiration_time_in_millis&quot; : 1584377890986, &quot;_shards&quot; : { &quot;total&quot; : 562, &quot;successful&quot; : 562, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 }, &quot;completion_status&quot; : 200 }  &quot;completion_status&quot; : 200：指示异步搜索已成功完成。 { &quot;id&quot; : &quot;FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=&quot;, &quot;is_running&quot; : false, &quot;is_partial&quot; : true, &quot;start_time_in_millis&quot; : 1583945890986, &quot;expiration_time_in_millis&quot; : 1584377890986, &quot;_shards&quot; : { &quot;total&quot; : 562, &quot;successful&quot; : 450, &quot;skipped&quot; : 0, &quot;failed&quot; : 112 }, &quot;completion_status&quot; : 503 }  &quot;completion_status&quot; : 503：指示异步搜索已完成，但出现错误。 ","version":"Next","tagName":"h2"},{"title":"删除异步搜索​","type":1,"pageTitle":"异步搜索","url":"/docs/elasticsearch-cn/rest_apis/search_apis/async_search#删除异步搜索","content":"你可以使用删除异步搜索 API 按 ID 手动删除异步搜索。如果搜索仍在运行，搜索请求将被取消。否则，保存的搜索结果将被删除。 DELETE /_async_search/FmRldE8zREVEUzA2ZVpUeGs2ejJFUFEaMkZ5QTVrSTZSaVN3WlNFVmtlWHJsdzoxMDc=  如果启用了 Elasticsearch 安全功能，则特定异步搜索的删除仅限于：*， 提交原始搜索请求的经过身份验证的用户。* 具有 cancel_task 集群权限的用户。 原文链接 ","version":"Next","tagName":"h2"},{"title":"kNN 搜索 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#请求","content":"GET &lt;target&gt;/_knn_search POST &lt;target&gt;/_knn_search ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#描述","content":"kNN 搜索 API 在 dense_vector 字段上执行 k-最近邻（kNN）搜索。给定一个查询向量，它会找到 k 个最接近的向量，并将这些文档作为搜索结果返回。 Elasticsearch 使用 HNSW 算法来支持高效的 kNN 搜索。与大多数 kNN 算法一样，HNSW 是一种近似方法，它牺牲了结果的准确性以提高搜索速度。这意味着返回的结果并不总是真正的 k 近邻。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#路径参数","content":"&lt;target&gt; （可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 警告 kNN 搜索还不能处理过滤的别名。对过滤后的别名运行 kNN 搜索可能会错误地导致少于 k 次点击。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#查询参数","content":"routing （可选，字符串）用于路由操作到指定分片的自定义值。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#请求体","content":"knn （必需，对象）定义运行的 kNN 查询。 knn 对象属性 field （必需，字符串）要搜索的向量字段的名称。必须是启用索引的 dense_vector。 query_vector （必需，浮点数组）查询向量。必须与要搜索的向量场具有相同的维数。 k （必需，整数）作为优先命中返回的最近邻居数。值必须小于 num_candidates。 num_candidates （必需，整数）每个分片要考虑的最近邻候选数。不能超过 10,000。Elasticsearch 从每个分片中收集 num_candidates 个结果，然后合并它们以找到前 k 个结果。增加 num_candidates 往往会提高最终 k结果的准确性。 docvalue_fields （可选，字符串和对象数组）通配符（*）模式数组。该请求返回响应的 hits.fields 属性中与这些模式匹配的字段名的文档值。 你可以在数组中指定字符串或对象。参阅文档值字段。 docvalue_fields 对象属性 field （必需，字符串）通配符模式。请求返回与此模式匹配的字段名的文档值。 format （可选，字符串）返回文档值的格式。 对于日期字段，你可以指定日期的日期格式。对于数字字段，你可以指定十进制模式。 对于其他字段数据类型，此参数不支持。 fields （可选，字符串和对象数组）通配符（*）模式数组。该请求返回响应的 hits.fields 属性中与这些模式匹配的字段名的文档值。 你可以在数组中指定字符串或对象。 fields 对象属性 field （必需，字符串）返回的字段。支持通配符（*）。 format （可选，字符串）日期和地理空间字段的格式。其他字段数据类型不支持此参数。 date 和 date_nanos 字段接受日期格式。geo_point 和 geo_shape 字段接受： geojson（默认） GeoJSON wkt Well Known Text/知名文本 mvt(&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;@&lt;extent&gt;) or mvt(&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;) 地图盒矢量块。此 API 返回的块是 base64 编码的字符串。 mvt 参数 &lt;zoom&gt; （必需，整数）块的缩放级别。支持 0-29。 &lt;x&gt; （必需，整数）块的 X 坐标。 &lt;y&gt; （必需，整数）块的 Y 坐标。 &lt;extent&gt; （可选，整数）平铺一侧的大小（以像素为单位）。矢量平铺是等边的正方形。默认为 4,096。 _source （可选）指示为匹配文档返回的源字段。这些字段将在搜索响应的属性 hits._source 中返回。默认为 true。 _source 有效值 true （布尔值）全部文档源返回。 false （布尔值）文档源不返回。 &lt;string&gt; （字符串）逗号分隔的待返回的源字段列表。支持通配符（*）。 stored_fields （可选，字符串）以逗号分隔的存储字段列表，作为命中的一部分返回。如果未指定字段，则响应中不包括存储的字段。 如果指定了此字段，则 _source 参数默认为 false。你可以传递 _source:true 以返回搜索响应中的源字段和存储字段。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"kNN 搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/knn_search#响应体","content":"kNN 搜索响应的结构与搜索 API 响应的结构完全相同。但是，某些部分对 kNN 搜索有特定的含义： 文档 _score由查询和文档向量之间的相似性决定。参阅相似性。 hits.total 对象包含考虑的最近邻候选总数，即 num_candidates * num_shards。hits.total.relation 总是 eq，表示精确的值。 原文链接 ","version":"Next","tagName":"h2"},{"title":"字段能力 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#请求","content":"GET /_field_caps?fields=&lt;fields&gt; POST /_field_caps?fields=&lt;fields&gt; GET /&lt;target&gt;/_field_caps?fields=&lt;fields&gt; POST /&lt;target&gt;/_field_caps?fields=&lt;fields&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须对目标数据流、索引或别名有 view_index_metadata、read 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#描述","content":"字段能力 API 在多个索引中返回有关字段功能的信息。 字段能力 API 像任何其他字段一样返回运行时字段。例如，具有 keyword 类型的运行时字段将作为属于 keyword 族的任何其他字段返回。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#路径参数","content":"&lt;target&gt;（可选，字符串）限制请求的逗号分隔的数据流、索引和别名的列表。支持通配符（）。要以所有数据流和索引为目标，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#查询参数","content":"fields（必需，字符串）以逗号分隔的待返回能力的字段列表，用于检索功能。支持通配符（*）表达式。 allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，缺少或关闭的索引不包括在响应中。默认为 false。 include_unmapped（可选，布尔值）如果为 true，响应中包含未映射的字段。默认为 false。 filters（可选，字符串）用于响应的逗号分隔过滤器列表。 filters 有效值： +metadata仅包含 metadata 字段 -metadata排除 metadata 字段 -parent排除 parent 字段 -nested排除 nested 字段 -multifield排除 multifield 字段 types（可选，字符串）逗号分隔的要包含的字段类型的列表。任何与这些类型之一不匹配的字段都将从结果中排除。默认为空，表示返回所有字段类型。参阅此处，了解有关字段能力请求和响应中字段类型的更多信息。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#请求体","content":"index_filter（可选，查询对象）如果提供的查询重写为在每个分片上 match_none，则允许筛选索引。 runtime_mappings（可选，对象）在请求中定义临时运行时字段，类似于在搜索请求中执行的方式。这些字段仅作为查询的一部分存在，并且优先于在索引映射中使用相同名称定义的字段。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#响应体","content":"响应中使用的类型描述了字段类型族（families）。通常，类型族与映射中声明的字段类型相同，但为了简化问题，某些行为相同的字段类型使用类型族进行描述。例如，keyword、constant_keyword 和 wildcard 字段类型都被描述为 keyword 类型族。 metadata_field该字段是否注册为 metadata 字段 searchable该字段是否在所有索引中都可搜索 aggregatable该字段是否在所有索引中都可聚合 time_series_dimension[预览]该字段是否为时序维度 time_series_metric[预览]如果此字段用作时序度量，则包含度量类型；如果此字段未用作度量，则不包含。 indices此字段具有相同类型族的索引列表，如果所有索引都具有该字段的相同类型族，则为 null。 non_searchable_indices此字段不可搜索的索引列表，如果所有索引对该字段具有相同的定义，则为 null。 non_aggregatable_indices此字段不可聚合的索引列表，如果所有索引对该字段具有相同的定义，则为 null。 non_dimension_indices[预览]此字段不可聚合的索引列表，如果所有索引对该字段具有相同的定义，则为null。如果有此列表作为响应，则某些索引将字段标记为维度，而其他索引（此列表中的索引）则没有。 metric_conflicts_indices[预览]如果此字段的索引没有相同的 time_series_metric 值，则显示此字段的索引列表。 meta将所有索引中的元数据合并为字符串键到值数组的映射。值长度为1表示所有索引对此键具有相同的值，而长度为 2 或更多表示并非所有索引对此键具有相同的值。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"字段能力 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/field_capabilities#示例","content":"请求可以限制为特定的数据流和索引： GET my-index-000001/_field_caps?fields=rating  下一个示例 API 调用请求有关 rating 和 title 字段的信息： GET _field_caps?fields=rating,title  此 API 返回以下响应： { &quot;indices&quot;: [ &quot;index1&quot;, &quot;index2&quot;, &quot;index3&quot;, &quot;index4&quot;, &quot;index5&quot; ], &quot;fields&quot;: { &quot;rating&quot;: { &quot;long&quot;: { &quot;metadata_field&quot;: false, &quot;searchable&quot;: true, &quot;aggregatable&quot;: false, &quot;indices&quot;: [ &quot;index1&quot;, &quot;index2&quot; ], &quot;non_aggregatable_indices&quot;: [ &quot;index1&quot; ] }, &quot;keyword&quot;: { &quot;metadata_field&quot;: false, &quot;searchable&quot;: false, &quot;aggregatable&quot;: true, &quot;indices&quot;: [ &quot;index3&quot;, &quot;index4&quot; ], &quot;non_searchable_indices&quot;: [ &quot;index4&quot; ] } }, &quot;title&quot;: { &quot;text&quot;: { &quot;metadata_field&quot;: false, &quot;searchable&quot;: true, &quot;aggregatable&quot;: false } } } }  &quot;rating&quot;: {：字段 rating 在 index1 和 index2 中定义为长，在 index3 和 index4 中定义为 keyword。&quot;non_aggregatable_indices&quot;: [ &quot;index1&quot; ] ：字段 rating 在索引 index1 中无聚合。&quot;non_searchable_indices&quot;: [ &quot;index4&quot; ] ：字段 rating 在索引 index4 中无法搜索。&quot;title&quot;: { ：字段 title 在所有索引中定义为 text。 默认情况下，将忽略未映射的字段。通过在请求中添加一个名为 include_unmapped 的参数，可以将它们包括在响应中： GET _field_caps?fields=rating,title&amp;include_unmapped  在这种情况下，响应将包含某些索引（但不是所有索引）中存在的每个字段的条目： { &quot;indices&quot;: [ &quot;index1&quot;, &quot;index2&quot;, &quot;index3&quot; ], &quot;fields&quot;: { &quot;rating&quot;: { &quot;long&quot;: { &quot;metadata_field&quot;: false, &quot;searchable&quot;: true, &quot;aggregatable&quot;: false, &quot;indices&quot;: [ &quot;index1&quot;, &quot;index2&quot; ], &quot;non_aggregatable_indices&quot;: [ &quot;index1&quot; ] }, &quot;keyword&quot;: { &quot;metadata_field&quot;: false, &quot;searchable&quot;: false, &quot;aggregatable&quot;: true, &quot;indices&quot;: [ &quot;index3&quot;, &quot;index4&quot; ], &quot;non_searchable_indices&quot;: [ &quot;index4&quot; ] }, &quot;unmapped&quot;: { &quot;metadata_field&quot;: false, &quot;indices&quot;: [ &quot;index5&quot; ], &quot;searchable&quot;: false, &quot;aggregatable&quot;: false } }, &quot;title&quot;: { &quot;text&quot;: { &quot;metadata_field&quot;: false, &quot;indices&quot;: [ &quot;index1&quot;, &quot;index2&quot;, &quot;index3&quot;, &quot;index4&quot; ], &quot;searchable&quot;: true, &quot;aggregatable&quot;: false }, &quot;unmapped&quot;: { &quot;metadata_field&quot;: false, &quot;indices&quot;: [ &quot;index5&quot; ], &quot;searchable&quot;: false, &quot;aggregatable&quot;: false } } } }  第一个 &quot;unmapped&quot;: { ：字段 rating 在索引 index5 中无映射。第二个 &quot;unmapped&quot;: { ：字段 title 在索引 index5 中无映射。 还可以通过查询过滤索引： POST my-index-*/_field_caps?fields=rating { &quot;index_filter&quot;: { &quot;range&quot;: { &quot;@timestamp&quot;: { &quot;gte&quot;: &quot;2018&quot; } } } }  在这种情况下的索引，将从响应中筛选提供的过滤器，在每个分片上重写为 match_none。 警告 过滤是在尽力而为的基础上完成的，它使用索引统计信息和映射来重写查询为 match_none，而不是完全执行请求。例如，如果分片中的所有文档（包括已删除的文档）都不在提供的范围内，则对 date 字段的 range 查询可以重写为 match_none。但是，并非所有查询都可以重写为 match_none，因此即使提供的筛选器不匹配任何文档，该 API 也可能返回索引。 原文链接 ","version":"Next","tagName":"h2"},{"title":"多搜索 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#请求","content":"GET &lt;target&gt;/_msearch/template GET _msearch/template POST &lt;target&gt;/_msearch/template POST _msearch/template ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 索引权限。对于跨集群搜索，参阅配置跨集群搜索权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#路径参数","content":"&lt;target&gt;（可选，字符串）逗号分隔的用于搜索的数据流、索引和别名列表。 如果请求正文中的搜索未指定 index 目标，此列表将用作备份。 支持通配符（）。为了在集群中搜索所有数据流和索引，忽略此参数或者使用 _all 或 ``。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#查询参数","content":"ccs_minimize_roundtrips（可选，布尔值）如果为 true，在执行跨集群搜索（CCS）请求时，协调节点和远程集群之间的网络往返行程最小化。参阅 跨群集搜索如何处理网络延迟。默认为 true。 max_concurrent_searches（可选，整数）多重搜索 API 可以执行的最大并发搜索数。默认为 max(1, (# of 数据节点 * min(搜索线程池大小, 10)))。 rest_total_hits_as_int(可选，布尔值)指示是否 hits.total 应在搜索响应中呈现为整数或对象。默认为 false，返回一个对象。 search_type（可选，字符串）搜索操作类型。可用选项： query_then_fetchdfs_query_then_fetch typed_keys（可选，布尔值）如果为 true，响应在聚合和建议器名称前加上各自的类型。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#请求体","content":"请求正文必须是以下格式的换行分隔 JSON（NDJSON）： &lt;header&gt;\\n &lt;body&gt;\\n &lt;header&gt;\\n &lt;body&gt;\\n  每个 &lt;header&gt; 和 &lt;body&gt;，一对代表一个搜索请求。 &lt;header&gt; 支持与 多搜索 API 的 &lt;header&gt; 相同的参数。&lt;body&gt; 支持与 搜索模板 API 的请求体相同的参数。 &lt;header&gt;（必需，对象）用于限制或更改搜索的参数。 每个搜索正文都需要此对象，但可以为空（{}）或空行。 &lt;header&gt; 对象的属性 allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 此参数也适用于指向缺失索引或索引的别名。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 index（可选，字符串或字符串数组）用于搜索的数据流、索引和别名。支持通配符（*）。可将多个目标指定为一个数组。 如果此参数未指定，&lt;target&gt; 请求路径参数将用于备选。 preference（可选，字符串）用于执行搜索的节点或分片。默认随机。 request_cache（可选，布尔值）如果为 true，请求缓存可用于此搜索。默认为索引级设置。参阅分片请求缓存设置。 routing（可选，字符串）用于搜索操作路由到特定分片的自定义路由值。 search_type（可选，字符串）指示在对返回的文档进行评分时是否应使用全局词语和文档频率。 选项有： query_then_fetch（默认）使用切分的本地词语和文档频率对文档进行评分。这通常更快，但更不准确。dfs_query_then_fetch在所有分片中使用全局词语和文档频率对文档进行评分。这通常较慢，但更准确。 &lt;body&gt;（必需，对象）用于搜索的参数。 explain（可选，布尔值）如果为 true，作为命中的一部分返回有关分数计算的详细信息。默认为 false。 id（必需，字符串）用于搜索的模板 ID。如果没有指定 source，此参数必需。 params（可选，对象）用于替换模板中Mustache变量的键值对。关键是变量名。该值是可变值。 profile（可选，布尔值）如果为 true，查询执行的是已优化的。默认为 false。 source（必需，对象）内联搜索模板。支持与 搜索 API的请求正文相同的参数。还支持 Mustache 变量。 如果 id 未指定，此参数必需。 ","version":"Next","tagName":"h2"},{"title":"响应码​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#响应码","content":"只有当请求本身失败时，API 才会返回 400 状态代码。如果请求中的一个或多个搜索失败，API 将为响应中的每个失败搜索返回一个 200 状态代码和一个错误对象。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#响应体","content":"responses（对象数组）每次搜索的结果，按提交的顺序返回。每个对象使用与搜索 API 响应相同的属性。 如果搜索失败，则响应包括包含错误消息的错误对象。 ","version":"Next","tagName":"h2"},{"title":"curl 请求​","type":1,"pageTitle":"多搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search_template#curl-请求","content":"如果为 curl 提供文本文件或文本输入，请使用标志 --data-binary 而不是 -d 来保留换行符。 $ cat requests { &quot;index&quot;: &quot;my-index&quot; } { &quot;id&quot;: &quot;my-search-template&quot;, &quot;params&quot;: { &quot;query_string&quot;: &quot;hello world&quot;, &quot;from&quot;: 0, &quot;size&quot;: 10 }} { &quot;index&quot;: &quot;my-other-index&quot; } { &quot;id&quot;: &quot;my-other-search-template&quot;, &quot;params&quot;: { &quot;query_type&quot;: &quot;match_all&quot; }} $ curl -H &quot;Content-Type: application/x-ndjson&quot; -XGET localhost:9200/_msearch/template --data-binary &quot;@requests&quot;; echo  原文链接 ","version":"Next","tagName":"h2"},{"title":"多重搜索 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#请求","content":"GET /&lt;target&gt;/_msearch ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 索引权限。对于跨集群搜索，参阅配置跨集群搜索权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#描述","content":"多重搜索 API 通过单个 API 请求执行多个搜索。请求的格式类似于批量 API 格式，并使用换行符分隔的JSON（NDJSON）格式。 结构如下： header\\n body\\n header\\n body\\n  此结构经过专门优化，以在特定搜索最终重定向到另一个节点时减少解析。 警告 数据的最后一行必须以换行符 \\n 结尾。每个换行符前面可以有一个回车符 \\r。向该终端发送请求时，Content-Type 头应设置为 application/x-ndjson。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#路径参数","content":"&lt;target&gt;（可选，字符串）逗号分隔的用于搜索的数据流、索引和别名列表。 如果请求正文中的搜索未指定 index 目标，此列表将用作备份。 支持通配符（）。为了在集群中搜索所有数据流和索引，忽略此参数或者使用 _all 或 ``。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#查询参数","content":"allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 ccs_minimize_roundtrips（可选，布尔值）如果为 true，在执行跨集群搜索（CCS）请求时，协调节点和远程集群之间的网络往返行程最小化。参阅 跨群集搜索如何处理网络延迟。默认为 true。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_throttled（可选，布尔值）如果为 true，当冻结时，将忽略具体索引、扩展的或别名索引。默认为 true。 ignore_unavailable（可选，布尔值）如果为 true，缺少或关闭的索引不包括在响应中。默认为 false。 max_concurrent_searches（可选，整数）多重搜索 API 可以执行的最大并发搜索数。默认为 max(1, (# of 数据节点 * min(搜索线程池大小, 10)))。 max_concurrent_shard_requests（可选，整数）定义此搜索并发执行的每个节点的并发分片请求数。此值应用于限制搜索对集群的影响，以限制并发分片请求的数量。默认为 5。 你可以使用此参数防止请求过载群集。例如，默认请求会命中集群中的所有数据流和索引。如果每个节点的分片数很高，这可能会导致分片请求被拒绝。 在某些场景中，并行性不是通过并发请求实现的。在这些情况下，此参数中的低值可能会导致性能不佳。例如，在预期并发搜索请求数量非常少的环境中，此参数中的较高值可能会提高性能。 pre_filter_shard_size（可选，整数）定义一个阈值，如果搜索请求扩展到的碎片数超过阈值，则该阈值将基于查询重写强制预筛选搜索碎片的预筛选往返。例如，如果一个分片无法根据其重写方法匹配任何文档，即如果日期筛选器必须匹配，但分片边界和查询不相交，则此筛选器往返可以显著限制分片的数量。未指定时，如果满足以下任何条件，则执行预过滤阶段： 该请求针对 128 个以上的分片。该请求以一个或多个只读索引为目标。查询的主要排序以索引字段为目标。 rest_total_hits_as_int(可选，布尔值)指示是否 hits.total 应在搜索响应中呈现为整数或对象。默认为 false，返回一个对象。 routing（可选，字符串）用于将搜索操作路由到特定分片的自定义路由值。 search_type（可选，字符串）如何为相关性评分计算分布式词语频率。 search_type 有效值 query_then_fetch（默认）对于运行搜索的每个分片，本地计算分布式词语频率。我们建议使用此选项进行更快的搜索，但评分可能不太准确。dfs_query_then_fetch使用从运行搜索的所有分片收集的信息，全局计算分布式术语频率。虽然此选项提高了评分的准确性，但它为每个分片添加了一个往返，这可能会导致搜索速度变慢。 typed_keys（可选，布尔值）如果为 true，聚合名和建议名在响应中以各自的类型作为前缀。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#请求体","content":"请求正文包含以换行符分隔的搜索 &lt;header&gt; 和搜索 &lt;body&gt; 对象列表。 &lt;header&gt;（必需，对象）用于限制或更改搜索的参数。 每个搜索正文都需要此对象，但可以为空（{}）或空行。 &lt;header&gt; 对象的属性 allow_no_indices（可选，布尔值）如果为 true，则如果通配符表达式或 _all 值仅检索缺少的或闭合的索引，则请求不会返回错误。 此参数也适用于指向缺失索引或闭合索引的别名。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 index（可选，字符串或字符串数组）用于搜索的数据流、索引和别名。支持通配符（*）。指定多个目标作为数组。 如果此参数未指定，&lt;target&gt; 请求路径参数用作备份。 preference（可选，字符串）用于执行搜索的节点或分片。默认随机。 request_cache（可选，布尔值）如果为 true，请求缓存可用于此搜索。默认为索引级设置。参阅分片请求缓存设置。 routing（可选，字符串）用于将搜索操作路由到特定分片的自定义路由值。 search_type（可选，字符串）指示在对返回的文档进行评分时是否应使用全局术语和文档频率。 可选项为： query_then_fetch（默认）使用切分的本地词语语和文档频率对文档进行评分。这通常更快，但精确度较低。dfs_query_then_fetch在所有分片中使用全局术语和文档频率对文档进行评分。这通常较慢，但更准确。 &lt;body&gt;（可选，对象）包含用于搜索请求的参数。 &lt;body&gt; 的属性 aggregations（可选，聚合对象）你希望在搜索过程中运行的聚合。参见聚合。 query（可选，查询 DSL 对象）你希望在搜索过程中运行的查询。与此查询匹配的命中将在响应中返回。 from（可选，整数）返回命中的起始偏移量。默认为 0。 size（可选，整数）返回的命中数量。默认为 10。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#响应体","content":"responses（数组）包括与原始多搜索请求中的顺序相匹配的每个搜索请求的搜索响应和状态代码。如果特定搜索请求完全失败，将返回带有 error 消息和相应状态代码的对象来代替实际的搜索响应。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#示例","content":"头包括待搜索的数据流、索引和别名。头还指示 search_type、preference 和 routing。正文包括典型的搜索正文请求（包括 query、aggregations、from、size 等）。 $ cat requests {&quot;index&quot; : &quot;test&quot;} {&quot;query&quot; : {&quot;match_all&quot; : {}}, &quot;from&quot; : 0, &quot;size&quot; : 10} {&quot;index&quot; : &quot;test&quot;, &quot;search_type&quot; : &quot;dfs_query_then_fetch&quot;} {&quot;query&quot; : {&quot;match_all&quot; : {}}} {} {&quot;query&quot; : {&quot;match_all&quot; : {}}} {&quot;query&quot; : {&quot;match_all&quot; : {}}} {&quot;search_type&quot; : &quot;dfs_query_then_fetch&quot;} {&quot;query&quot; : {&quot;match_all&quot; : {}}}  $ curl -H &quot;Content-Type: application/x-ndjson&quot; -XGET localhost:9200/_msearch --data-binary &quot;@requests&quot;; echo  注意，上面包括一个空头的示例（也可以没有任何内容），它也受支持。 端点还允许你搜索请求路径中的数据流、索引和别名。在这种情况下，除非在头的 index 参数中明确指定，否则它将用作默认目标。例如： GET my-index-000001/_msearch {} {&quot;query&quot; : {&quot;match_all&quot; : {}}, &quot;from&quot; : 0, &quot;size&quot; : 10} {} {&quot;query&quot; : {&quot;match_all&quot; : {}}} {&quot;index&quot; : &quot;my-index-000002&quot;} {&quot;query&quot; : {&quot;match_all&quot; : {}}}  上面将针对 my-index-000001 索引执行搜索，搜索未在请求正文中定义索引目标的所有请求。最后一次搜索将针对 my-index-000002 索引执行。 search_type 可以以类似的方式设置，以全局应用于所有搜索请求。 ","version":"Next","tagName":"h2"},{"title":"安全​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#安全","content":"参阅基于 URL 的访问控制。 ","version":"Next","tagName":"h2"},{"title":"部分响应​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#部分响应","content":"为了确保快速响应，如果一个或多个分片失败，多搜索 API 将响应部分结果。有关更多信息，参阅分片故障。 ","version":"Next","tagName":"h2"},{"title":"取消搜索​","type":1,"pageTitle":"多重搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/multi_search#取消搜索","content":"可以使用标准的任务取消机制取消多重搜索，并且当客户端关闭用于执行请求的 http 连接时，也会自动取消多次搜索。当请求超时或中止时，发送请求的 http 客户端必须关闭连接。取消多重搜索请求也将取消所有相应的子搜索请求。 原文链接 ","version":"Next","tagName":"h2"},{"title":"时间点 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/point_in_time","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"前置条件​","type":1,"pageTitle":"时间点 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/point_in_time#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 read 索引权限。 要在时间点（PIT）中搜索别名，必须对别名数据流或索引有 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"时间点 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/point_in_time#示例","content":"在用于搜索请求之前，必须明确打开时间点。keep_alive 参数告诉 Elasticsearch 一个时间点应该保持活动多长时间，例如，?keep_alive=5m。 POST /my-index-000001/_pit?keep_alive=1m  上述请求的结果包括一个 id，该 id 应传递给搜索请求的 pit 参数的 id。 POST /_search { &quot;size&quot;: 100, &quot;query&quot;: { &quot;match&quot; : { &quot;title&quot; : &quot;elasticsearch&quot; } }, &quot;pit&quot;: { &quot;id&quot;: &quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot;, &quot;keep_alive&quot;: &quot;1m&quot; } }  POST /_search：带有 pit 参数的搜索请求不能指定 index、routing 和 preference，因为这些参数是从时间点复制的。 &quot;id&quot;: &quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot;：id 参数告诉 Elasticsearch 使用该时间点的上下文执行请求。 &quot;keep_alive&quot;: &quot;1m&quot;：keep_alive 参数告诉 Elasticsearch 它应该延长时间点的生存时间。 警告 开放时间点请求和每个后续搜索请求可以返回不同的 id；因此，在下一个搜索请求中始终使用最近收到的 id。 ","version":"Next","tagName":"h2"},{"title":"保持时间点活动​","type":1,"pageTitle":"时间点 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/point_in_time#保持时间点活动","content":"keep_alive 参数传递给打开的时间点请求和搜索请求，它延长了相应时间点的生存时间。该值（例如，1m，参见时间单位）不需要足够长的时间来处理所有数据 — 它只需要足够长的时间来满足下一个请求。 通常情况下，后台合并过程通过合并较小的段来创建新的较大段，从而优化索引。一旦不再需要较小的片段，它们就会被删除。但是，开放时间点防止删除旧段，因为它们仍在使用中。 提示 使较旧的段保持活动状态意味着需要更多的磁盘空间和文件句柄。确保已将节点配置为具有足够的空闲文件句柄。参阅文件描述符。 此外，如果某个段包含已删除或更新的文档，则时间点必须跟踪该段中的每个文档在初始搜索请求时是否处于活动状态。如果索引上有很多打开点，并且需要进行删除或更新，请确保节点有足够的堆空间。请注意，时间点不会阻止删除其关联的索引。 你可以使用节点统计 API 检查打开了多少时间点（即搜索上下文）： GET /_nodes/stats/indices/search  ","version":"Next","tagName":"h2"},{"title":"关闭时间点 API​","type":1,"pageTitle":"时间点 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/point_in_time#关闭时间点-api","content":"时间点在其 keep_alive 已过时自动关闭。然而，如前一节所讨论的，保持时间点是有代价的。一旦搜索请求中不再使用时间点，时间点应立即关闭。 DELETE /_pit { &quot;id&quot; : &quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot; }  API 返回以下响应： { &quot;succeeded&quot;: true, &quot;num_freed&quot;: 3 }  &quot;succeeded&quot;: true：如果为 true，则与时间点 id 关联的所有搜索上下文都将成功关闭&quot;num_freed&quot;: 3：已成功关闭的搜索上下文数 ","version":"Next","tagName":"h2"},{"title":"搜索切片​","type":1,"pageTitle":"时间点 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/point_in_time#搜索切片","content":"GET /_search { &quot;slice&quot;: { &quot;id&quot;: 0, &quot;max&quot;: 2 }, &quot;query&quot;: { &quot;match&quot;: { &quot;message&quot;: &quot;foo&quot; } }, &quot;pit&quot;: { &quot;id&quot;: &quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot; } } GET /_search { &quot;slice&quot;: { &quot;id&quot;: 1, &quot;max&quot;: 2 }, &quot;pit&quot;: { &quot;id&quot;: &quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot; }, &quot;query&quot;: { &quot;match&quot;: { &quot;message&quot;: &quot;foo&quot; } } }  &quot;id&quot;: 0：切片 id&quot;max&quot;: 2：切片最大数量 在对大量文档进行分页时，将搜索拆分为多个片段以独立使用它们可能会有所帮助： 第一个请求的结果返回属于第一个切片（id:0）的文档，第二个请求的结果返回第二个切片中的文档。由于最大切片数设置为2，因此两个请求结果的并集相当于不进行切片的时间点搜索的结果。默认情况下，首先在碎片上进行拆分，然后在每个碎片上进行本地拆分。本地拆分基于Lucene文档ID将碎片划分为连续范围。 例如，如果分片的数量等于2，并且用户请求了4个碎片，那么将碎片0和2分配给第一个碎片，将碎片1和3分配给第二个碎片。 警告 所有切片都应使用相同的时间点 ID。如果使用不同的时间点 ID，则切片可能会重叠并丢失文档。这是因为拆分标准基于 Lucene 文档 ID，这些 ID 在索引更改期间不稳定。 原文链接 ","version":"Next","tagName":"h2"},{"title":"渲染搜索模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/render_search_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"渲染搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/render_search_template#请求","content":"GET _render/template GET _render/template/&lt;template-id&gt; POST _render/template POST _render/template/&lt;template-id&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"渲染搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/render_search_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你对至少一个索引模型必须有 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"渲染搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/render_search_template#路径参数","content":"&lt;template-id&gt;（必需，字符串）待渲染的搜索模板 ID。如果 source 未指定，此参数或请求体中的 id 将是必需的。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"渲染搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/render_search_template#请求体","content":"id（必需，字符串）待渲染的搜索模板的 ID。如果 source 未指定，则此参数或请求路径参数 &lt;template-id&gt; 是必需的。如果同时指定此参数和 &lt;template id&gt; 参数，则 API 仅使用 &lt;template id&gt;。 params(可选，对象)用于替换模板中 Mustache 变量的键值对。键是变量名。值是可变值。 source（必需，对象）内联搜索模板。支持与搜索 API 的请求体相同的参数。这些参数还支持 Mustache 变量。如果未指定 id 或 &lt;templated id&gt;，则此参数是必需的。 原文链接 ","version":"Next","tagName":"h2"},{"title":"滚动 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#请求","content":"GET /_search/scroll/&lt;scroll_id&gt; [7.0.0] GET /_search/scroll POST /_search/scroll/&lt;scroll_id&gt; [7.0.0] POST /_search/scroll ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须对目标数据流、索引或别名有 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#描述","content":"你可以使用滚动 API 从单个滚动搜索请求中检索大量结果。 滚动 API 需要滚动 ID。要获取滚动 ID，请提交包含滚动查询参数的搜索 API请求。scroll 参数指示 Elasticsearch 应为请求保留搜索上下文的时间。 搜索响应在响应体参数 _scroll_id 中返回一个滚动 ID。然后，你可以使用滚动 ID 和滚动 API 来检索请求的下一批结果。如果 Elasticsearch 安全功能已启用，则对特定滚动 ID 的结果的访问仅限于提交搜索的用户或 API 密钥。 你还可以使用scroll API指定新的滚动参数，以延长或缩短搜索上下文的保留期。 参阅滚动搜索结果。 警告 滚动搜索的结果反映了初始搜索请求时索引的状态。后续的索引或文档更改只会影响以后的搜索和滚动请求。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#路径参数","content":"&lt;scroll_id&gt;[7.0.0]（可选，字符串）搜索的滚动 ID。 警告 滚动 ID 可能很长。我们建议仅使用 scroll_id 请求体参数指定滚动 ID。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#查询参数","content":"scroll （可选，时间值）保留用于滚动的搜索上下文的期间。参阅滚动搜索结果。 该值覆盖原始搜索 API 请求的 scroll 参数设置的持续时间。 默认情况下，此值不能超过 1d（24小时）。你可以通过 search.max_keep_alive 集群设置修改些限制。 警告 你还可以通过请求体参数 scroll 指定该值。如果同时指定了这两个参数，则只使用查询参数。 scroll_id [7.0.0]（可选，字符串）搜索的滚动 ID。 警告 滚动 ID 可能很长。我们建议仅使用 scroll_id 请求体参数指定滚动 ID。 rest_total_hits_as_int (可选，布尔值)如果为 true，API 响应的 hits.total 属性以整数返回。如果为 false，API 响应的 hits.total 属性以对象返回。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#请求体","content":"scroll （可选，时间值）保留用于滚动的搜索上下文的期间。参阅滚动搜索结果。 该值覆盖原始搜索 API 请求的 scroll 参数设置的持续时间。 默认情况下，此值不能超过 1d（24小时）。你可以通过 search.max_keep_alive 集群设置修改些限制。 警告 你还可以通过查询参数 scroll 指定该值。如果同时指定了这两个参数，则只使用查询参数。 scroll_id （必需，字符串）搜索的滚动 ID。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"滚动 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/scroll#响应体","content":"滚动 API 返回与搜索 API 相同的响应体。参阅搜索 API 的响应体参数。 原文链接 ","version":"Next","tagName":"h2"},{"title":"搜索分片 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"搜索分片 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards#请求","content":"GET /&lt;target&gt;/_search_shards ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"搜索分片 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须对目标数据流、索引或别名有 view_index_metadata 或 manage 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"搜索分片 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards#描述","content":"搜索分片 API 返回将针对其执行搜索请求的索引和碎片。这可以为解决问题或规划具有路由和分片首选项的优化提供有用的反馈。使用过滤别名时，过滤器将作为索引部分的一部分返回。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"搜索分片 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards#路径参数","content":"&lt;target&gt;（可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（）。为了搜索所有数据流和索引，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"搜索分片 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards#查询参数","content":"allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 local（可选，布尔值）如果为 true，请求只从本地节点获取信息。默认为 false，意味着信息从主节点获取。 preference（可选，字符串）用于执行搜索的节点或分片。默认随机。 routing（可选，字符串）用于路由操作到指定分片的自定义值。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"搜索分片 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_shards#示例","content":"GET /my-index-000001/_search_shards  此 API 返回以下结果： { &quot;nodes&quot;: ..., &quot;indices&quot; : { &quot;my-index-000001&quot;: { } }, &quot;shards&quot;: [ [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;node&quot;: &quot;JklnKbD7Tyqi9TP3_Q_tBg&quot;, &quot;primary&quot;: true, &quot;shard&quot;: 0, &quot;state&quot;: &quot;STARTED&quot;, &quot;allocation_id&quot;: {&quot;id&quot;:&quot;0TvkCyF7TAmM1wHP4a42-A&quot;}, &quot;relocating_node&quot;: null } ], [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;node&quot;: &quot;JklnKbD7Tyqi9TP3_Q_tBg&quot;, &quot;primary&quot;: true, &quot;shard&quot;: 1, &quot;state&quot;: &quot;STARTED&quot;, &quot;allocation_id&quot;: {&quot;id&quot;:&quot;fMju3hd1QHWmWrIgFnI4Ww&quot;}, &quot;relocating_node&quot;: null } ], [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;node&quot;: &quot;JklnKbD7Tyqi9TP3_Q_tBg&quot;, &quot;primary&quot;: true, &quot;shard&quot;: 2, &quot;state&quot;: &quot;STARTED&quot;, &quot;allocation_id&quot;: {&quot;id&quot;:&quot;Nwl0wbMBTHCWjEEbGYGapg&quot;}, &quot;relocating_node&quot;: null } ], [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;node&quot;: &quot;JklnKbD7Tyqi9TP3_Q_tBg&quot;, &quot;primary&quot;: true, &quot;shard&quot;: 3, &quot;state&quot;: &quot;STARTED&quot;, &quot;allocation_id&quot;: {&quot;id&quot;:&quot;bU_KLGJISbW0RejwnwDPKw&quot;}, &quot;relocating_node&quot;: null } ], [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;node&quot;: &quot;JklnKbD7Tyqi9TP3_Q_tBg&quot;, &quot;primary&quot;: true, &quot;shard&quot;: 4, &quot;state&quot;: &quot;STARTED&quot;, &quot;allocation_id&quot;: {&quot;id&quot;:&quot;DMs7_giNSwmdqVukF7UydA&quot;}, &quot;relocating_node&quot;: null } ] ] }  由于指定的路由值，搜索只针对两个分片执行。 原文链接 ","version":"Next","tagName":"h2"},{"title":"搜索 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#请求","content":"GET /&lt;target&gt;/_search GET /_search POST /&lt;target&gt;/_search POST /_search ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须有 read 索引权限来向目标数据流、索引或别名使用此 API。对于跨集群搜索，参阅配置跨集群搜索权限。 要在时间点（PIT）中搜索别名，必须对别名数据流或索引有 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#描述","content":"允许你执行搜索查询并返回与查询匹配的搜索命中。你可以使用 q 查询字符串参数或请求体提供搜索查询。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#路径参数","content":"&lt;target&gt; （可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（）。为了搜索所有数据流和索引，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#查询参数","content":"警告 可以使用查询参数或请求体参数指定此 API 的多个选项。如果同时使用了这两种参数，则仅使用查询参数。 allow_no_indices （可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 allow_partial_search_results （可选，布尔值）如果为 true，则在存在分片请求超时或分片失败时返回部分结果。如果为 false，则返回没有部分结果的错误。默认为 true。 为了覆盖此字段的默认值，将集群设置 search.default_allow_partial_results 设为 false。 analyzer （可选，字符串）用于查询字符串的分析器。 仅当 q 查询参数被指定时，此参数可用。 analyze_wildcard （可选，布尔值）如果为 true，通配符和前缀查询将被分析。默认为 false。 仅当 q 查询参数被指定时，此参数可用。 batched_reduce_size （可选，整数）协调节点上应立即减少的分片数。如果请求中可能存在大量分片，则应将此值用作保护机制，以减少每个搜索请求的内存开销。默认为 512。 ccs_minimize_roundtrips （可选，布尔值）如果为 true，在执行跨集群搜索（CCS）请求时，协调节点和远程集群之间的网络往返行程最小化。参阅 跨群集搜索如何处理网络延迟。默认为 true。 default_operator （可选，字符串）查询字符串查询的默认运算符：AND 或 OR。默认为 OR。 仅当 q 查询参数被指定时，此参数可用。 df （可选，字符串）在查询字符串中未给出字段前缀的情况下，要用作默认值的字段。 仅当 q 查询参数被指定时，此参数可用。 docvalue_fields （可选，字符串）以逗号分隔的字段列表，用于返回每个命中字段的 docvalue 表示形式。 expand_wildcards （可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 explain （可选，布尔值）如果为 true，作为命中的一部分返回有关分数计算的详细信息。默认为 false。 from （可选，整数）文档偏移的开始值。默认为 0。 默认情况下，使用 from 和 size 参数不能翻阅超过 10,000 次命中。要翻阅更多命中，请使用 search_after 参数。 ignore_throttled （可选，布尔值）如果为 true，当冻结时，将忽略具体索引、扩展的或别名索引。默认为 true。 ignore_unavailable （可选，布尔值）如果为 true，缺少或关闭的索引不包括在响应中。默认为 false。 lenient （可选，布尔值）如果为 true，将忽略查询字符串中基于格式的查询失败（例如向数字字段提供文本）。默认为 false。 仅当 q 查询参数被指定时，此参数可用。 max_concurrent_shard_requests （可选，整数）定义此搜索并发执行的每个节点的并发分片请求数。此值应用于限制搜索对集群的影响，以限制并发分片请求的数量。默认为 5。 pre_filter_shard_size （可选，整数）定义一个阈值，如果搜索请求扩展到的碎片数超过阈值，则该阈值将基于查询重写强制预筛选搜索碎片的预筛选往返。例如，如果一个分片无法根据其重写方法匹配任何文档，即如果日期筛选器必须匹配，但分片边界和查询不相交，则此筛选器往返可以显著限制分片的数量。未指定时，如果满足以下任何条件，则执行预过滤阶段： 该请求针对 128 个以上的分片。该请求以一个或多个只读索引为目标。查询的主要排序以索引字段为目标。 preference （可选，字符串）用于搜索的节点和分片。默认情况下，Elasticsearch 使用自适应副本选择从符合条件的节点和分片中进行选择，以考虑分配感知。 preference 合法值 _only_local 仅在本地节点上的分片上运行搜索。 _local 如果可能，在本地节点上的分片上运行搜索。如果没有，请使用默认方法选择分片。 _only_nodes:&lt;node-id&gt;,&lt;node-id&gt; 仅在指定的节点 ID 上运行搜索。如果在多个选定节点上存在合适的分片，请使用默认方法在这些节点上使用分片。如果指定的节点都不可用，请使用默认方法从任何可用节点中选择分片。 _prefer_nodes:&lt;node-id&gt;,&lt;node-id&gt; 如果可能，请在指定的节点 ID 上运行搜索。如果没有，请使用默认方法选择分片。 _shards:&lt;shard&gt;,&lt;shard&gt; 仅在指定的分片上运行搜索。你可以将此值与其他 preference 值组合，不包括 &lt;custom-string&gt;。但是 _shards 值必须放在第一位。例如：_shards:2,3|_local。 &lt;custom-string&gt; 如果可能，请在指定的节点 ID 上运行搜索。如果没有，请使用默认方法选择分片。 q （可选，字符串）Lucene 查询字符串语法中的查询。 你可以使用 q 参数来运行查询参数搜索。查询参数搜索不支持完整的 Elasticsearch 查询 DSL，但便于测试。 警告 q 参数覆盖请求正文中的查询参数。如果同时指定了这两个参数，则不会返回与查询请求正文参数匹配的文档。 request_cache （可选，布尔值）如果为 true，对 size 为 0 的请求启用搜索结果缓存。参阅分片请求缓存设置。默认为索引级设置。 rest_total_hits_as_int (可选，布尔值)指示是否 hits.total 应在搜索响应中呈现为整数或对象。默认为 false。 routing （可选，字符串）用于将操作路由到特定分片的自定义值。 scroll （可选，时间值）保留用于滚动的搜索上下文的期间。参阅滚动搜索结果。 默认情况下，此值不能超过 1d（24小时）。你可以通过 search.max_keep_alive 集群设置修改些限制。 search_type （可选，字符串）如何为相关性评分计算分布式词语频率。 search_type 有效值 query_then_fetch （默认）对于运行搜索的每个分片，本地计算分布式词语频率。我们建议使用此选项进行更快的搜索，但评分可能不太准确。 dfs_query_then_fetch 使用从运行搜索的所有分片收集的信息，全局计算分布式术语频率。虽然此选项提高了评分的准确性，但它为每个分片添加了一个往返，这可能会导致搜索速度变慢。 seq_no_primary_term （可选，布尔值）如果为 true，返回每个命中的最后一次修改的序列号和主项。参阅乐观并发控制。 size （可选，整数）定义返回的命中数。默认为 10。 默认情况下，使用 from 和 size 参数不能翻页浏览超过 10,000 次点击。要浏览更多点击，请使用 search_after参数。 sort （可选，字符串）逗号分隔的 &lt;field&gt;:&lt;direction&gt; 列表。 _source （可选）指示为匹配文档返回的源字段。这些字段将在搜索响应的属性 hits._source 中返回。默认为 true。 _source 有效值 true （布尔值）全部文档源返回。 false （布尔值）文档源不返回。 &lt;string&gt; （字符串）逗号分隔的待返回的源字段列表。支持通配符（*）。 _source_excludes （可选，字符串）逗号分隔的从响应中排除的源字段。 你还可以使用此参数从 _source_includes 查询参数中指定的子集中排除字段。 如果 _source 参数为 false，此参数会被忽略。 _source_includes （可选，字符串）逗号分隔的响应中要包含的源字段。 如果此参数指定，只有这些源字段会返回。你可以使用 _source_excludes 查询参数从该子集中排除字段。 如果 _source 参数为 false，此参数会被忽略。 stats （可选，字符串）用于日志记录和统计目的的请求的指定 tag。 stored_fields （可选，字符串）以逗号分隔的存储字段列表，作为命中的一部分返回。如果未指定字段，则响应中不包括存储的字段。 如果指定了此字段，则 _source 参数默认为 false。你可以传递 _source:true 以返回搜索响应中的源字段和存储字段。 suggest_field （可选，字符串）指定哪个字段用于建议。 suggest_mode （可远，字符串）指定建议模式。默认为 missing。可用选项为： alwaysmissingpopular 仅当指定了 suggest_field 和 suggest_text 查询字符串参数时，此参数才可用。 suggest_size （可选，整数）待返回的建议数量。 仅当指定了 suggest_field 和 suggest_text 查询字符串参数时，此参数才可用。 terminate_after （可选，整数）为每个分片收集的最大文档数。如果查询达到此限制，Elasticsearch 会提前终止查询。Elasticsearch 在排序之前收集文档。 警告 使用要小心。Elasticsearch 将此参数应用于处理请求的每个分片。如果可能，让 Elasticsearch 自动执行提前终止。避免为针对跨多个数据层具有备份索引的数据流的请求指定此参数。 默认值为 0，这不会提前终止查询执行。 timeout （可选，时间单位）指定等待每个分片响应的时间段。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为无超时。 track_scores （可选，布尔值）如果为 true，计算并返回文档分数，即使分数不用于排序。默认为 false。 track_total_hits （可选，整数或布尔值）匹配查询以准确计数的命中数。默认为 10,000。 如果为 true，返回准确的点击数是以牺牲一些性能为代价的。如果为 false，响应不包括与查询匹配的命中总数。 typed_keys （可选，布尔值）如果为 true，聚合名和建议名在响应中以各自的类型作为前缀。默认为 false。 version （可选，布尔值）如果为 true，作为命中的一部分返回文档版本。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#请求体","content":"docvalue_fields （可选，字符串和对象数组）通配符（*）模式数组。该请求返回响应的 hits.fields 属性中与这些模式匹配的字段名的文档值。 你可以在数组中指定字符串或对象。参阅文档值字段。 docvalue_fields 对象属性 field （必需，字符串）通配符模式。请求返回与此模式匹配的字段名的文档值。 format （可选，字符串）返回文档值的格式。 对于日期字段，你可以指定日期的日期格式。对于数字字段，你可以指定十进制模式。 对于其他字段数据类型，此参数不支持。 fields （可选，字符串和对象数组）通配符（*）模式数组。该请求返回响应的 hits.fields 属性中与这些模式匹配的字段名的文档值。 你可以在数组中指定字符串或对象。 fields 对象属性 field （必需，字符串）返回的字段。支持通配符（*）。 format （可选，字符串）日期和地理空间字段的格式。其他字段数据类型不支持此参数。 date 和 date_nanos 字段接受日期格式。geo_point 和 geo_shape 字段接受： geojson（默认） GeoJSON wkt Well Known Text/知名文本 mvt(&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;@&lt;extent&gt;) or mvt(&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;) 地图盒矢量块。此 API 返回的块是 base64 编码的字符串。 mvt 参数 &lt;zoom&gt; （必需，整数）块的缩放级别。支持 0-29。 &lt;x&gt; （必需，整数）块的 X 坐标。 &lt;y&gt; （必需，整数）块的 Y 坐标。 &lt;extent&gt; （可选，整数）平铺一侧的大小（以像素为单位）。矢量平铺是等边的正方形。默认为 4,096。 explain （可选，布尔值）如果为 true，作为命中的一部分返回有关分数计算的详细信息。默认为 false。 from （可选，整数）开始文档的偏移量。默认为 0。 默认情况下，使用 from和 size 参数不能翻页浏览超过 10,000 次点击。要浏览更多点击，请使用 search_after 参数。 indices_boost （可选，对象数组）提高指定索引中文档的 _score。 indices_boost 对象属性 &lt;index&gt;: &lt;boost-value&gt; （必需，浮点数）&lt;index&gt; 是索引的名字或索引别名。支持通配符（*）。 &lt;boost-value&gt; 是分数乘以的系数。 提升值大于 1.0 会增加分数。介于 0 和 1.0 之间的提升值会降低分数。 min_score （可选，浮点数）匹配文档的最低 _score。搜索结果中不包括 _score 较低的文档。 pit （可选，对象）限制搜索时间点（PIT），如果你提供了一个 pit，你在请求路径中不能指定 &lt;target&gt; 。 pit 属性 id （必需*，字符串）搜索的 PIT 的 ID。如果你提供了 pit 对象，此参数就是必需的。 keep_alive （可选，时间值）用于延长 PIT 生存周期。 query （可选，查询对象）使用 Query DSL 定义搜索定义。 runtime_mappings （可选，对象）在搜索请求中定义一个或多个运行时字段。这些字段优先于具有相同名称的映射字段。 runtime_mappings 对象属性 &lt;field-name&gt; （必需，对象）配置运行时字段。键（key）是字段名字。 &lt;field-name&gt; 属性 type （必需，字符串）字段类型，可以是以下任一种： boolean compositedatedoublegeo_pointipkeywordlong script （可选，字符串）查询时执行的 Plainless Script。脚本可以访问文档的整个上下文，包括原始 _source 和任何映射字段及其值。 此脚本必须包含 emit 以返回计算值。例如： &quot;script&quot;: &quot;emit(doc['@timestamp'].value.dayOfWeekEnum.toString())&quot; seq_no_primary_term （可选，布尔值）如果为 true，返回每个命中的最后一次修改的序列号和主项。参阅乐观并发控制。 size （可选，整数）定义返回的命中数。默认为 10。 默认情况下，使用 from 和 size 参数不能翻页浏览超过 10,000 次点击。要浏览更多点击，请使用 search_after参数。 _source （可选）指示为匹配文档返回的源字段。这些字段将在搜索响应的属性 hits._source 中返回。默认为 true。 _source 有效值 true （布尔值）全部文档源返回。 false （布尔值）文档源不返回。 &lt;string&gt; （字符串）逗号分隔的待返回的源字段列表。支持通配符（*）。 stats （可选，字符串数组）要与搜索关联的统计组。每个组为其关联的搜索维护一个统计聚合。你可以使用索引统计 API 检索这些统计信息。 terminate_after （可选，整数）为每个分片收集的最大文档数。如果查询达到此限制，Elasticsearch 会提前终止查询。Elasticsearch 在排序之前收集文档。 警告 使用要小心。Elasticsearch 将此参数应用于处理请求的每个分片。如果可能，让 Elasticsearch 自动执行提前终止。避免为针对跨多个数据层具有备份索引的数据流的请求指定此参数。 默认值为 0，这不会提前终止查询执行。 timeout （可选，时间单位）指定等待每个分片响应的时间段。如果在超时过期之前没有收到响应，则请求失败并返回错误。默认为无超时。 version （可选，布尔值）如果为 true，作为命中的一部分返回文档版本。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"响应体​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#响应体","content":"_scroll_id （字符串）搜索及其搜索上下文的标识符。 你可以将此滚动 ID 与滚动 API 一起使用，以检索请求的下一批搜索结果。参阅滚动搜索结果。 只有在请求中指定了查询参数 scroll 时，才会返回此参数。 took (整数)Elasticsearch 执行请求花费的毫秒数。 该值是通过测量协调节点上收到请求与协调节点准备发送响应之间经过的时间来计算的。 花费时间包括： 协调节点和数据节点之间的通信时间请求在搜索线程池中排队等待执行的时间实际执行时间 花费时间不包括： 将请求发送到 Elasticsearch 所需的时间序列化 JSON 响应所需的时间将响应发送到客户端所需的时间 timed_out （布尔值）如果为 true，请求在完成之前超时；返回的结果可能是部分或空的。 _shards （对象）包含用于请求的分片数。 _shards 属性 total （整数）需要查询的分片总数，包括未分配的分片。 successful （整数）成功执行请求的分片数。 skipped （整数）跳过请求的分片数，因为轻量级检查帮助意识到没有文档可能与此分片匹配。这种情况通常发生在搜索请求包含范围筛选器，并且分片只有超出该范围的值时。 failed （整数）无法执行请求的分片数。请注意，未分配的分片将被视为既不成功也不失败。因此，failed+successful 少于 total 表示未分配部分分片。 hits （对象）包含返回的文档和元数据。 hits 属性 total （对象）有关返回文档数量的元数据。 total 属性 value （整数）返回文档的总数。 relation （字符串）指示 value 参数中返回的文档数是准确的还是下限。 relation 值： eq 精确。 gte 下限，包括返回的文档 max_score （浮点数）返回的文档的最高 _score。 对于不按 _score 排序的请求，此值为 null。 hits （对象数组）返回的文档对象数组。 hits 对象属性 _index （字符串）包含返回文档的索引的名称。 _type （字符串）返回文档的映射类型。 _id （字符串）返回文档的唯一标识符。此ID仅在返回的索引中是唯一的。 _score （浮点数）用于确定返回文档相关性的 32 位正浮点数。 _source （对象）索引时为文档传递的原始 JSON 正文。 你可以使用 _source 参数从响应中排除此属性，或指定要返回的源字段。 fields （对象）包含文档的字段值。必须使用以下一个或多个请求参数在请求中指定这些字段： docvalue_fieldsscript_fieldsstored_fields 仅当设置了其中一个或多个参数时，才会返回此属性。 fields 属性 &lt;field&gt; （数组）键是字段名。值是字段的值。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search#示例","content":"GET /my-index-000001/_search?from=40&amp;size=20 { &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: &quot;kimchy&quot; } } }  此 API 返回以下响应： { &quot;took&quot;: 5, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: { &quot;value&quot;: 20, &quot;relation&quot;: &quot;eq&quot; }, &quot;max_score&quot;: 1.3862942, &quot;hits&quot;: [ { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot;: &quot;0&quot;, &quot;_score&quot;: 1.3862942, &quot;_source&quot;: { &quot;@timestamp&quot;: &quot;2099-11-15T14:12:12&quot;, &quot;http&quot;: { &quot;request&quot;: { &quot;method&quot;: &quot;get&quot; }, &quot;response&quot;: { &quot;status_code&quot;: 200, &quot;bytes&quot;: 1070000 }, &quot;version&quot;: &quot;1.1&quot; }, &quot;source&quot;: { &quot;ip&quot;: &quot;127.0.0.1&quot; }, &quot;message&quot;: &quot;GET /search HTTP/1.1 200 1070000&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;kimchy&quot; } } }, ... ] } }  原文链接 ","version":"Next","tagName":"h2"},{"title":"搜索模板 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_template","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_template#请求","content":"GET &lt;target&gt;/_search/template GET _search/template POST &lt;target&gt;/_search/template POST _search/template ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_template#前置条件","content":"如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 read 索引权限。对于跨集群搜索，参阅配置跨集群搜索权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_template#路径参数","content":"&lt;target&gt;（可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（）。为了搜索所有数据流和索引，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_template#查询参数","content":"allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 ccs_minimize_roundtrips（可选，布尔值）如果为 true，在执行跨集群搜索（CCS）请求时，协调节点和远程集群之间的网络往返行程最小化。参阅 跨群集搜索如何处理网络延迟。默认为 true。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 explain（可选，布尔值）如果为 true，作为命中的一部分返回有关分数计算的详细信息。默认为 false -ignore_throttled（可选，布尔值）如果为 true，具体、展开或别名索引在冻结时将忽略。默认值为 true。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 preference（可选，字符串）用于执行搜索的节点或分片。默认随机。 rest_total_hits_as_int(可选，布尔值)指示是否 hits.total 应在搜索响应中呈现为整数或对象。默认为 false，返回一个对象。 routing（可选，字符串）用于路由操作到指定分片的自定义值。 scroll（可选，时间值）指定滚动搜索时索引的一致视图应保持多长时间。 search_type（可选，字符串）搜索操作的类型。可选项： query_then_fetchdfs_query_then_fetch typed_keys（可选，布尔值）如果为 true，则响应会在聚合和建议器名称前加上它们各自的类型。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"搜索模板 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/search_template#请求体","content":"explain（可选，布尔值）如果为 true，作为命中的一部分返回有关分数计算的详细信息。默认为 false。 如果你同时指定了此参数和查询参数中的 explain，API 仅使用查询参数。 id（必需，字符串）要使用的搜索模板的ID。如果未指定 source，则需要此参数。 params（可选，对象）用于替换模板中的 Mustache 变量的键值对。键是变量名，值是变量值。 profile（可选，布尔值）如果为 true，查询执行是已优化的。默认为 false。 source（必需，对象）内联搜索模板。支持与 搜索 API的请求正文相同的参数。还支持 Mustache 变量。 如果 id 未指定，此参数必需。 原文链接 ","version":"Next","tagName":"h2"},{"title":"排序评估 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#请求","content":"GET /&lt;target&gt;/_rank_eval POST /&lt;target&gt;/_rank_eval ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须对目标数据流、索引或别名有 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#描述","content":"排序评估 API 允许你评估一组典型搜索查询中排名搜索结果的质量。给定这组查询和手动分级的文档列表，_rank_eval 端点计算并返回典型的信息检索指标，如平均倒数排名、精度或折扣累积增益。 搜索质量评估从查看搜索应用程序的用户以及他们正在搜索的内容开始。用户有特定的信息需求；例如，他们正在网上商店寻找礼物，或者想预订下一个假期的航班。他们通常在搜索框或其他web表单中输入一些搜索词。所有这些信息以及有关用户的元信息（例如浏览器、位置、早期首选项等）然后被转换为对底层搜索系统的查询。 搜索工程师面临的挑战是调整这种从用户输入到具体查询的转换过程，使搜索结果包含与用户信息需求相关的最相关信息。只有在典型用户查询的代表性测试套件中不断评估搜索结果质量，以便某个特定查询的排名改进不会对其他类型查询的排名产生负面影响时，才能做到这一点。 为了开始搜索质量评估，你需要三件基本的事情： 要评估查询性能的文档集合，通常是一个或多个数据流或索引。用户输入系统的典型搜索请求的集合。一组文档分级，表示文档与搜索请求的相关性。 需要注意的是，每个测试查询需要一组文档评级，相关性判断是基于输入查询的用户的信息需求。 排序评估 API 提供了一种方便的方法，可以在排名评估请求中使用此信息来计算不同的搜索评估指标。这为你提供了总体搜索质量的第一个估计，以及在微调应用程序中查询生成的各个方面时要进行优化的度量。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#路径参数","content":"&lt;target&gt;（可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（）。为了搜索所有数据流和索引，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#查询参数","content":"allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 默认为 true。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#示例","content":"在最基本的形式中，对 _rank_eval 端点的请求有两个部分： GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ ... ], &quot;metric&quot;: { &quot;mean_reciprocal_rank&quot;: { ... } } }  &quot;requests&quot;: [ ... ]：一组典型的搜索请求及其提供的评级&quot;metric&quot;：要计算的评估指标的定义&quot;mean_reciprocal_rank&quot;: { ... }：特定度量及其参数 请求部分包含应用程序典型的几个搜索请求，以及每个特定搜索请求的文档评级。 GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ { &quot;id&quot;: &quot;amsterdam_query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match&quot;: { &quot;text&quot;: &quot;amsterdam&quot; } } }, &quot;ratings&quot;: [ { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;doc1&quot;, &quot;rating&quot;: 0 }, { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;doc2&quot;, &quot;rating&quot;: 3 }, { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;doc3&quot;, &quot;rating&quot;: 1 } ] }, { &quot;id&quot;: &quot;berlin_query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match&quot;: { &quot;text&quot;: &quot;berlin&quot; } } }, &quot;ratings&quot;: [ { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;doc1&quot;, &quot;rating&quot;: 1 } ] } ] }  &quot;id&quot;: &quot;amsterdam_query&quot;：搜索请求的 ID，用于稍后对结果详细信息进行分组。&quot;request&quot;: {：正在计算的查询。&quot;ratings&quot;: [：文档分级列表。每个条目都包含以下参数： _index：文档的索引。对于数据流，这应该是文档的支持索引。_id：文档 ID。rating：文档与此搜索请求的相关性。 文档 rating 可以是在用户定义的范围内表示文档相关性的任何整数值。对于某些度量，只给出一个二进制评级（例如 0 表示无关，1 表示相关）就足够了，而其他度量可以使用更细粒度的尺度。 ","version":"Next","tagName":"h2"},{"title":"基于模板的排名评估​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#基于模板的排名评估","content":"除了必须为每个测试请求提供单个查询之外，还可以在评估请求中指定查询模板，然后再引用它们。这样，只有参数不同的类似结构的查询就不必在 requests 部分一直重复。在典型的搜索系统中，用户输入通常被填充到一小组查询模板中，这有助于使评估请求更加简洁。 GET /my-index-000001/_rank_eval { [...] &quot;templates&quot;: [ { &quot;id&quot;: &quot;match_one_field_query&quot;, &quot;template&quot;: { &quot;inline&quot;: { &quot;query&quot;: { &quot;match&quot;: { &quot;{{field}}&quot;: { &quot;query&quot;: &quot;{{query_string}}&quot; }} } } } } ], &quot;requests&quot;: [ { &quot;id&quot;: &quot;amsterdam_query&quot;, &quot;ratings&quot;: [ ... ], &quot;template_id&quot;: &quot;match_one_field_query&quot;, &quot;params&quot;: { &quot;query_string&quot;: &quot;amsterdam&quot;, &quot;field&quot;: &quot;text&quot; } }, [...] }  &quot;id&quot;: &quot;match_one_field_query&quot;：模板 id&quot;template&quot;: {：定义要使用的模板&quot;template_id&quot;: &quot;match_one_field_query&quot;：引用预定义的模板&quot;params&quot;: {：用于填充模板的参数 你也可使用存储的模板。 GET /my_index/_rank_eval { [...] &quot;templates&quot;: [ { &quot;id&quot;: &quot;match_one_field_query&quot;, &quot;template&quot;: { &quot;id&quot;: &quot;match_one_field_query&quot; } } ], &quot;requests&quot;: [...] }  &quot;id&quot;: &quot;match_one_field_query&quot;：用于请求的模板 id&quot;template&quot;: {：存储在集群状态中的模板 id ","version":"Next","tagName":"h3"},{"title":"可用的评估指标​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#可用的评估指标","content":"metric 部分确定将使用哪些可用的评估度量。支持以下指标： K 精度（P@k）​ 此指标衡量前 k 个搜索结果中相关结果的比例。这是一种众所周知的精度度量，它只查看前k个文档。它是前k个结果中相关文档的分数。精度为 10(P@10)值为 0.6 意味着 10个 热门搜索中有 6 个与用户的信息需求相关。 P@k 作为一种简单的评估指标，其优点是易于理解和解释。集合中的文档需要被评定为与当前查询相关或不相关。P@k 是一个基于集合的度量，并且没有考虑相关文档在前 k 个结果中的位置，因此，在位置 10 中包含一个相关结果的十个结果的排名与在位置 1 中包含一个相关结果的十个结果的排名一样好。 GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ { &quot;id&quot;: &quot;JFK query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match_all&quot;: {} } }, &quot;ratings&quot;: [] } ], &quot;metric&quot;: { &quot;precision&quot;: { &quot;k&quot;: 20, &quot;relevant_rating_threshold&quot;: 1, &quot;ignore_unlabeled&quot;: false } } }  precision 指标采用以下可选参数： 参数\t描述k\t设置每个查询检索的最大文档数。此值将替代查询中的常规 size 参数。默认值为 10。 relevant_rating_threshold\t设置文档被视为“相关”的评级阈值。默认值为 1。 ignore_unlabeled\t控制搜索结果中未标记文档的计数方式。如果设置为 true，则忽略未标记的文档，并且两者都不视为相关或无关。如果设置为 false（默认值），它们将被视为不相关。 k 召回（R@k）​ 此指标衡量前 k 个搜索结果中相关结果的总数。这是一种众所周知的召回指标。它是前 k 个结果中相关文档相对于所有可能相关结果的分数。10 召回(R@10)如果值为 0.5，则表示在 10 个热门搜索中检索到了 8 个与用户信息需求相关的文档中的 4 个。 R@k 作为一种简单的评估指标，其优点是易于理解和解释。集合中的文档需要被评定为与当前查询相关或不相关。R@k 是一个基于集合的度量，并且没有考虑相关文档在前 k 个结果中的位置，因此，在位置 10 中包含一个相关结果的十个结果的排名与在位置 1 中包含一个相关结果的十个结果的排名一样好。 GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ { &quot;id&quot;: &quot;JFK query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match_all&quot;: {} } }, &quot;ratings&quot;: [] } ], &quot;metric&quot;: { &quot;recall&quot;: { &quot;k&quot;: 20, &quot;relevant_rating_threshold&quot;: 1 } } }  recall 指标采用以下可选参数 参数\t描述k\t设置每个查询检索的最大文档数。此值将替代查询中的常规大小参数。默认值为 10。 relevant_rating_threshold\t设置文档被视为“相关”的评级阈值。默认值为 1。 平均倒数排序​ 对于测试套件中的每个查询，此度量计算第一个相关文档的排名的倒数。例如，在位置 3 找到第一个相关结果意味着倒数排名为 1/3。每个查询的倒数排名是测试套件中所有查询的平均值，以给出平均倒数排序。 GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ { &quot;id&quot;: &quot;JFK query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match_all&quot;: {} } }, &quot;ratings&quot;: [] } ], &quot;metric&quot;: { &quot;mean_reciprocal_rank&quot;: { &quot;k&quot;: 20, &quot;relevant_rating_threshold&quot;: 1 } } }  mean_reciprocal_rank 度量采用以下可选参数 参数\t描述k\t设置每个查询检索的最大文档数。此值将替代查询中的常规 size 参数。默认值为 10。 relevant_rating_threshold\t设置文档被视为“相关”的评级阈值。默认值为 1。 折损累积增益（Discounted cumulative gain，DCG）​ 与上述两个指标相比，折损累积增益同时考虑了搜索结果的排名和评级。 假设高度相关的文档出现在结果列表的顶部时对用户更有用。因此，DCG 公式减少了搜索级别较低的文档的高评级对总体 DCG 指标的贡献。 GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ { &quot;id&quot;: &quot;JFK query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match_all&quot;: {} } }, &quot;ratings&quot;: [] } ], &quot;metric&quot;: { &quot;dcg&quot;: { &quot;k&quot;: 20, &quot;normalize&quot;: false } } }  dcg 度量采用以下可选参数 参数\t描述k\t设置每个查询检索的最大文档数。此值将替代查询中的常规大小参数。默认值为 10。 normalize\t如果设置为 true，此度量将计算归一化DCG。 期望倒数排序（ERR）​ 期望倒数排序（ERR）是分级关联案例中经典互易等级的扩展（Olivier Chapelle、Donald Metzler、Ya Zhang和Pierre Grinspan，2009。期望倒数排序互易等级。） 它基于搜索级联模型的假设，在该模型中，用户按顺序扫描排名的搜索结果，并在满足信息需求的第一个文档处停止。因此，对于问答和导航查询来说，它是一个很好的衡量标准，但对于面向调查的信息需求来说，它就不是那么好了，因为用户希望在前k个结果中找到许多相关文档。 该度量对用户停止读取结果列表的位置的倒数的期望进行建模。这意味着排名靠前的相关文档对总分的贡献很大。然而，如果同一份文件的排名较低，那么它对分数的贡献就会小得多；如果前面有一些相关（但可能不太相关）的文档，则更是如此。这样，ERR度量将折扣显示在非常相关的文档之后的文档。这在相关文档的排序中引入了依赖性的概念，例如精度或DCG没有考虑到这一点。 GET /my-index-000001/_rank_eval { &quot;requests&quot;: [ { &quot;id&quot;: &quot;JFK query&quot;, &quot;request&quot;: { &quot;query&quot;: { &quot;match_all&quot;: {} } }, &quot;ratings&quot;: [] } ], &quot;metric&quot;: { &quot;expected_reciprocal_rank&quot;: { &quot;maximum_relevance&quot;: 3, &quot;k&quot;: 20 } } }  expected_reciprocal_rank 度量采用以下可选参数 参数\t描述maximum_relevance\t强制参数。用户提供的相关性判断中使用的最高相关性等级。 k\t设置每个查询检索的最大文档数。此值将替代查询中的常规 size 参数。默认值为 10。 ","version":"Next","tagName":"h3"},{"title":"响应格式​","type":1,"pageTitle":"排序评估 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/ranking_evaluation#响应格式","content":"_rank_eval 端点的响应包含定义的质量指标的总体计算结果、包含测试套件中每个查询结果细分的 details 部分以及显示单个查询潜在错误的可选 failures 部分。响应的格式如下： { &quot;rank_eval&quot;: { &quot;metric_score&quot;: 0.4, &quot;details&quot;: { &quot;my_query_id1&quot;: { &quot;metric_score&quot;: 0.6, &quot;unrated_docs&quot;: [ { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_id&quot;: &quot;1960795&quot; }, ... ], &quot;hits&quot;: [ { &quot;hit&quot;: { &quot;_index&quot;: &quot;my-index-000001&quot;, &quot;_type&quot;: &quot;page&quot;, &quot;_id&quot;: &quot;1528558&quot;, &quot;_score&quot;: 7.0556192 }, &quot;rating&quot;: 1 }, ... ], &quot;metric_details&quot;: { &quot;precision&quot;: { &quot;relevant_docs_retrieved&quot;: 6, &quot;docs_retrieved&quot;: 10 } } }, &quot;my_query_id2&quot;: { [... ] } }, &quot;failures&quot;: { [... ] } } }  &quot;details&quot;: {：通过定义的指标计算的总体评估质量&quot;my_query_id1&quot;: {：details 部分包含原始请求部分中每个查询的一个条目，由搜索请求id键入&quot;metric_score&quot;: 0.6：details 部分中的 metric_score 显示此查询对全局质量度量分数的贡献&quot;unrated_docs&quot;: [：unrated_docs 部分包含此查询的搜索结果中没有评级值的每个文档的 _index 和 _id 条目。这可用于要求用户提供这些文档的评级&quot;hit&quot;: {：hits 部分显示搜索结果的分组及其提供的评级&quot;metric_details&quot;: {：metric_details 提供了有关计算质量指标的其他信息（例如，检索到的文档中有多少是相关的）。每个指标的内容各不相同，但可以更好地解释结果 原文链接 ","version":"Next","tagName":"h3"},{"title":"词语枚举 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/terms_enum","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"词语枚举 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/terms_enum#请求","content":"GET /&lt;target&gt;/_terms_enum ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"词语枚举 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/terms_enum#描述","content":"词语枚举 API 可用于发现索引中以提供的字符串开头的词语。它是为自动完成场景中使用的低延迟查找而设计的。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"词语枚举 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/terms_enum#路径参数","content":"&lt;target&gt;（可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（）。为了搜索所有数据流和索引，忽略此参数或使用 `或_all`。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"词语枚举 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/terms_enum#请求体","content":"field（强制，字符串）要匹配的字段 string（可选，字符串）要在索引项开头匹配的字符串。如果未提供，所有字段中的词语都要考虑。 size（可选，整数）返回的匹配词语数量。默认为 10。 timeout（可选，时间单位）用于收集结果的最长时间。默认为“1s”（一秒）。如果超过超时，则响应中的 complete 标志设置为 false，结果可能是部分或空的。 case_insensitive（可选，布尔值）如果为 true，则提供的搜索字符串与索引项匹配，不区分大小写。默认为 false。 index_filter（可选，查询对象）如果所提供的查询被重写为不匹配，则允许过滤索引碎片。 search_after（可选，字符串）在索引中的词语之后返回的字符串。如果一个请求的最后一个结果作为后续请求的 search_after 参数传递，则允许一种分页形式。 原文链接 ","version":"Next","tagName":"h2"},{"title":"验证 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#请求","content":"GET /&lt;target&gt;/_validate/&lt;query&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#前置条件","content":"如果 Elasticsearch 安全特性启用，你必须对目标数据流、索引或别名有 read 索引权限。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#描述","content":"验证 API 允许你在不执行查询的情况下验证潜在的昂贵查询。查询可以作为路径参数或在请求正文中发送。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#路径参数","content":"&lt;target&gt;（可选，字符串）用于限制请求的，逗号分隔的数据流、索引。也支持通配符表达式（）。为了搜索所有数据流和索引，忽略此参数或使用 `或_all`。 query（可选，查询对象）使用 Query DSL 定义搜索定义。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#查询参数","content":"all_shards（可选，布尔值）如果为 true，对所有分片执行验证，而不是对每个索引执行一个随机分片。 allow_no_indices（可选，布尔值）如果为 false，任何通配符、索引别名或 _all 值只针对丢失或关闭的索引，请求将返回一个错误。即使请求以其他开启索引为目标，此行为也适用。例如，如果一个索引以 foo 开头，而没有索引以 bar 开头，则以 foo*,bar* 为目标的请求将返回错误。 default_operator（可选，字符串）查询字符串查询的默认运算符：AND 或 OR。默认为 OR。 仅当 q 查询参数被指定时，此参数可用。 df（可选，字符串）在查询字符串中未给出字段前缀的情况下，要用作默认值的字段。 仅当 q 查询参数被指定时，此参数可用。 expand_wildcards（可选，字符串）通配符表达式可以匹配的索引类型。如果请求可以数据流为目标，则此参数确定通配符表达式是否匹配隐藏的数据流。支持逗号分隔的值，如 open,hidden。有效的值有： all匹配任何数据流或索引，包括 hidden（隐藏的）。open匹配 open（开启）、非隐藏的索引。也匹配任何非隐藏的数据流。closed匹配 closed（关闭）、非隐藏的索引。也匹配任何非隐藏的数据流。数据流不能关闭。hidden匹配隐藏数据流和隐藏索引。必须与 open、closed 或一起使用。none不接受通配符表达式。 默认为 open。 explain（可选，布尔值）如果为 true，作为命中的一部分返回有关分数计算的详细信息。默认为 false。 ignore_unavailable（可选，布尔值）如果为 true，丢失的或关闭的索引不包含在响应中。默认为 false。 lenient（可选，布尔值）如果为 true，将忽略查询字符串中基于格式的查询失败（例如向数字字段提供文本）。默认为 false。 rewrite（可选，布尔值）如果为 true，则返回显示将执行的实际 Lucene 查询的更详细解释。默认为 false。 q（可选，字符串）Lucene 查询字符串语法中的查询。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#示例","content":"PUT my-index-000001/_bulk?refresh {&quot;index&quot;:{&quot;_id&quot;:1}} {&quot;user&quot; : { &quot;id&quot;: &quot;kimchy&quot; }, &quot;@timestamp&quot; : &quot;2099-11-15T14:12:12&quot;, &quot;message&quot; : &quot;trying out Elasticsearch&quot;} {&quot;index&quot;:{&quot;_id&quot;:2}} {&quot;user&quot; : { &quot;id&quot;: &quot;kimchi&quot; }, &quot;@timestamp&quot; : &quot;2099-11-15T14:12:13&quot;, &quot;message&quot; : &quot;My user ID is similar to kimchy!&quot;}  当发送验证请求时： GET my-index-000001/_validate/query?q=user.id:kimchy  响应包含 valid:true： {&quot;valid&quot;:true,&quot;_shards&quot;:{&quot;total&quot;:1,&quot;successful&quot;:1,&quot;failed&quot;:0}}  查询也可以在请求正文中发送： GET my-index-000001/_validate/query { &quot;query&quot; : { &quot;bool&quot; : { &quot;must&quot; : { &quot;query_string&quot; : { &quot;query&quot; : &quot;*:*&quot; } }, &quot;filter&quot; : { &quot;term&quot; : { &quot;user.id&quot; : &quot;kimchy&quot; } } } } }  提示 在正文中发送的查询必须嵌套在查询键中，这与 搜索 API的工作原理相同 如果查询无效，valid 将为 false。这里的查询无效，因为 Elasticsearch 知道 post_date 字段应该是动态映射的日期，而 foo 不能正确解析为日期： GET my-index-000001/_validate/query { &quot;query&quot;: { &quot;query_string&quot;: { &quot;query&quot;: &quot;@timestamp:foo&quot;, &quot;lenient&quot;: false } } }  {&quot;valid&quot;:false,&quot;_shards&quot;:{&quot;total&quot;:1,&quot;successful&quot;:1,&quot;failed&quot;:0}}  ","version":"Next","tagName":"h2"},{"title":"explain 参数​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#explain-参数","content":"可以指定 explain 参数以获取有关查询失败原因的更详细信息： GET my-index-000001/_validate/query?explain=true { &quot;query&quot;: { &quot;query_string&quot;: { &quot;query&quot;: &quot;@timestamp:foo&quot;, &quot;lenient&quot;: false } } }  API 返回以下响应： { &quot;valid&quot; : false, &quot;_shards&quot; : { &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;failed&quot; : 0 }, &quot;explanations&quot; : [ { &quot;index&quot; : &quot;my-index-000001&quot;, &quot;valid&quot; : false, &quot;error&quot; : &quot;my-index-000001/IAEc2nIXSSunQA_suI0MLw] QueryShardException[failed to create query:...failed to parse date field [foo]&quot; } ] }  ","version":"Next","tagName":"h3"},{"title":"rewrite 参数​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#rewrite-参数","content":"当查询有效时，解释默认为该查询的字符串表示形式。当 rewrite 设置为 true 时，说明将更详细地显示将执行的实际 Lucene 查询。 GET my-index-000001/_validate/query?rewrite=true { &quot;query&quot;: { &quot;more_like_this&quot;: { &quot;like&quot;: { &quot;_id&quot;: &quot;2&quot; }, &quot;boost_terms&quot;: 1 } } }  API 返回以下响应： { &quot;valid&quot;: true, &quot;_shards&quot;: { &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;explanations&quot;: [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;valid&quot;: true, &quot;explanation&quot;: &quot;((user:terminator^3.71334 plot:future^2.763601 plot:human^2.8415773 plot:sarah^3.4193945 plot:kyle^3.8244398 plot:cyborg^3.9177752 plot:connor^4.040236 plot:reese^4.7133346 ... )~6) -ConstantScore(_id:2)) #(ConstantScore(_type:_doc))^0.0&quot; } ] }  ","version":"Next","tagName":"h2"},{"title":"rewrite 和 all_shards 参数​","type":1,"pageTitle":"验证 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/validate#rewrite-和-all_shards-参数","content":"默认情况下，请求仅在随机选择的单个分片上执行。查询的详细解释可能取决于命中的分片，因此可能因请求而异。因此，在查询重写的情况下，应该使用 all_shards 参数从所有可用的分片获取响应。 GET my-index-000001/_validate/query?rewrite=true&amp;all_shards=true { &quot;query&quot;: { &quot;match&quot;: { &quot;user.id&quot;: { &quot;query&quot;: &quot;kimchy&quot;, &quot;fuzziness&quot;: &quot;auto&quot; } } } }  API 返回以下响应： { &quot;valid&quot;: true, &quot;_shards&quot;: { &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;explanations&quot;: [ { &quot;index&quot;: &quot;my-index-000001&quot;, &quot;shard&quot;: 0, &quot;valid&quot;: true, &quot;explanation&quot;: &quot;(user.id:kimchi)^0.8333333 user.id:kimchy&quot; } ] }  原文链接 ","version":"Next","tagName":"h3"},{"title":"分析 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"描述​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#描述","content":"分析 API 让用户能够深入了解搜索请求是如何在较低级别执行的，这样用户就可以理解某些请求速度慢的原因，并采取措施加以改进。请注意，配置文件 API 并没有测量网络延迟、请求在队列中花费的时间或在协调节点上合并分片响应所花费的时间。 分析 API 的输出非常冗长，尤其是对于跨多个碎分执行的复杂请求。建议打印响应以帮助理解输出。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#示例","content":"可以通过添加顶级 profile 参数来分析任何 _search 请求： GET /my-index-000001/_search { &quot;profile&quot;: true, &quot;query&quot; : { &quot;match&quot; : { &quot;message&quot; : &quot;GET /search&quot; } } }  &quot;profile&quot;: true,： 将顶层 profile 参数设置为 true 将启用搜索分析。 此 API 返回以下结果： { &quot;took&quot;: 25, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: { &quot;value&quot;: 5, &quot;relation&quot;: &quot;eq&quot; }, &quot;max_score&quot;: 0.17402273, &quot;hits&quot;: [...] }, &quot;profile&quot;: { &quot;shards&quot;: [ { &quot;id&quot;: &quot;[2aE02wS1R8q_QFnYu6vDVQ][my-index-000001][0]&quot;, &quot;searches&quot;: [ { &quot;query&quot;: [ { &quot;type&quot;: &quot;BooleanQuery&quot;, &quot;description&quot;: &quot;message:get message:search&quot;, &quot;time_in_nanos&quot; : 11972972, &quot;breakdown&quot; : { &quot;set_min_competitive_score_count&quot;: 0, &quot;match_count&quot;: 5, &quot;shallow_advance_count&quot;: 0, &quot;set_min_competitive_score&quot;: 0, &quot;next_doc&quot;: 39022, &quot;match&quot;: 4456, &quot;next_doc_count&quot;: 5, &quot;score_count&quot;: 5, &quot;compute_max_score_count&quot;: 0, &quot;compute_max_score&quot;: 0, &quot;advance&quot;: 84525, &quot;advance_count&quot;: 1, &quot;score&quot;: 37779, &quot;build_scorer_count&quot;: 2, &quot;create_weight&quot;: 4694895, &quot;shallow_advance&quot;: 0, &quot;create_weight_count&quot;: 1, &quot;build_scorer&quot;: 7112295 }, &quot;children&quot;: [ { &quot;type&quot;: &quot;TermQuery&quot;, &quot;description&quot;: &quot;message:get&quot;, &quot;time_in_nanos&quot;: 3801935, &quot;breakdown&quot;: { &quot;set_min_competitive_score_count&quot;: 0, &quot;match_count&quot;: 0, &quot;shallow_advance_count&quot;: 3, &quot;set_min_competitive_score&quot;: 0, &quot;next_doc&quot;: 0, &quot;match&quot;: 0, &quot;next_doc_count&quot;: 0, &quot;score_count&quot;: 5, &quot;compute_max_score_count&quot;: 3, &quot;compute_max_score&quot;: 32487, &quot;advance&quot;: 5749, &quot;advance_count&quot;: 6, &quot;score&quot;: 16219, &quot;build_scorer_count&quot;: 3, &quot;create_weight&quot;: 2382719, &quot;shallow_advance&quot;: 9754, &quot;create_weight_count&quot;: 1, &quot;build_scorer&quot;: 1355007 } }, { &quot;type&quot;: &quot;TermQuery&quot;, &quot;description&quot;: &quot;message:search&quot;, &quot;time_in_nanos&quot;: 205654, &quot;breakdown&quot;: { &quot;set_min_competitive_score_count&quot;: 0, &quot;match_count&quot;: 0, &quot;shallow_advance_count&quot;: 3, &quot;set_min_competitive_score&quot;: 0, &quot;next_doc&quot;: 0, &quot;match&quot;: 0, &quot;next_doc_count&quot;: 0, &quot;score_count&quot;: 5, &quot;compute_max_score_count&quot;: 3, &quot;compute_max_score&quot;: 6678, &quot;advance&quot;: 12733, &quot;advance_count&quot;: 6, &quot;score&quot;: 6627, &quot;build_scorer_count&quot;: 3, &quot;create_weight&quot;: 130951, &quot;shallow_advance&quot;: 2512, &quot;create_weight_count&quot;: 1, &quot;build_scorer&quot;: 46153 } } ] } ], &quot;rewrite_time&quot;: 451233, &quot;collector&quot;: [ { &quot;name&quot;: &quot;SimpleTopScoreDocCollector&quot;, &quot;reason&quot;: &quot;search_top_hits&quot;, &quot;time_in_nanos&quot;: 775274 } ] } ], &quot;aggregations&quot;: [], &quot;fetch&quot;: { &quot;type&quot;: &quot;fetch&quot;, &quot;description&quot;: &quot;&quot;, &quot;time_in_nanos&quot;: 660555, &quot;breakdown&quot;: { &quot;next_reader&quot;: 7292, &quot;next_reader_count&quot;: 1, &quot;load_stored_fields&quot;: 299325, &quot;load_stored_fields_count&quot;: 5 }, &quot;debug&quot;: { &quot;stored_fields&quot;: [&quot;_id&quot;, &quot;_routing&quot;, &quot;_source&quot;] }, &quot;children&quot;: [ { &quot;type&quot;: &quot;FetchSourcePhase&quot;, &quot;description&quot;: &quot;&quot;, &quot;time_in_nanos&quot;: 20443, &quot;breakdown&quot;: { &quot;next_reader&quot;: 745, &quot;next_reader_count&quot;: 1, &quot;process&quot;: 19698, &quot;process_count&quot;: 5 }, &quot;debug&quot;: { &quot;fast_path&quot;: 5 } } ] } } ] } }  &quot;hits&quot;: [...]：将返回搜索结果，但为了简洁起见，此处省略了搜索结果。 即使对于一个简单的查询，响应也相对复杂。在转到更复杂的示例之前，让我们将其逐一分解。 分析响应的总体结构如下： { &quot;profile&quot;: { &quot;shards&quot;: [ { &quot;id&quot;: &quot;[2aE02wS1R8q_QFnYu6vDVQ][my-index-000001][0]&quot;, &quot;searches&quot;: [ { &quot;query&quot;: [...], &quot;rewrite_time&quot;: 51443, &quot;collector&quot;: [...] } ], &quot;aggregations&quot;: [...], &quot;fetch&quot;: {...} } ] } }  &quot;id&quot;: &quot;[2aE02wS1R8q_QFnYu6vDVQ][my-index-000001][0]&quot;：将为参与响应的每个分片返回一个分析，并由唯一 ID 标识。&quot;query&quot;: [...]：查询计时和其他调试信息。&quot;rewrite_time&quot;: 51443：累计重写时间。&quot;collector&quot;: [...]：每个收集器的名称和调用计时。&quot;aggregations&quot;: [...]：聚合计时、调用计数和调试信息。&quot;fetch&quot;: {...} ：获取计时和调试信息。 因为搜索请求可以针对索引中的一个或多个分片执行，并且搜索可以覆盖一个或多个索引，所以概要文件响应中的顶级元素是 shard 对象的数组。每个分片对象列出其唯一标识分片的 id。ID 格式为 [nodeID][indexName][shardID]。 概要文件本身可能包含一个或多个“搜索”，其中搜索是针对基础 Lucene 索引执行的查询。用户提交的大多数搜索请求只会对 Lucene 索引执行一次 search。但有时会执行多个搜索，例如包括全局聚合（需要对全局上下文执行辅助“match_all”查询）。 在每个搜索对象中，将有两个概要信息数组：一个 query 数组和一个 collector 数组。search 对象旁边是一个 aggregations 对象，其中包含聚合的概要信息。将来，可能会添加更多的部分，如 suggest、highlight 等。 还将有一个 rewrite 度量，显示重写查询所花费的总时间（以纳秒为单位）。 提示 与其他统计 API 一样，分析 API支持人类可读的输出。可以通过给查询字符串添加 ?human=true。在这种情况下，输出包含包含四舍五入的人类可读定时信息的附加 time 字段（如：&quot;time&quot;: &quot;391,9ms&quot;, &quot;time&quot;: &quot;123.3micros&quot;）。 ","version":"Next","tagName":"h2"},{"title":"分析查询​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#分析查询","content":"提示 分析 API 提供的细节直接公开了 Lucene 类名和概念，这意味着对结果的完整解释需要相当高级的 Lucene 知识。本页试图提供 Lucene 如何执行查询的速成课程，以便你可以使用分析 API 成功诊断和调试查询，但这只是一个概述。要完全理解，请参阅Lucene的文档和代码。 尽管如此，修复缓慢的查询通常不需要完全理解。例如，只需看到查询的某个特定组件运行缓慢，而不必了解该查询的高级阶段是什么原因，这通常就足够了。 ","version":"Next","tagName":"h2"},{"title":"query 部分​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#query-部分","content":"query 部分包含 Lucene 在特定切分上执行查询树的详细计时。此查询树的整体结构将类似于你原来的 Elasticsearch 查询，但可能略有不同（有时非常不同）。它还将使用类似但并不总是相同的命名。使用前面的 match 查询示例，让我们分析 query 部分： &quot;query&quot;: [ { &quot;type&quot;: &quot;BooleanQuery&quot;, &quot;description&quot;: &quot;message:get message:search&quot;, &quot;time_in_nanos&quot;: &quot;11972972&quot;, &quot;breakdown&quot;: {...}, &quot;children&quot;: [ { &quot;type&quot;: &quot;TermQuery&quot;, &quot;description&quot;: &quot;message:get&quot;, &quot;time_in_nanos&quot;: &quot;3801935&quot;, &quot;breakdown&quot;: {...} }, { &quot;type&quot;: &quot;TermQuery&quot;, &quot;description&quot;: &quot;message:search&quot;, &quot;time_in_nanos&quot;: &quot;205654&quot;, &quot;breakdown&quot;: {...} } ] } ]  &quot;breakdown&quot;: {...},：为了简单起见，省略了细化计时。 根据概要文件结构，我们可以看到我们的 match 查询被 Lucene 重写为一个带有两个子句的 BooleanQuery（都包含一个 TermQuery）。type 字段显示 Lucene 类名，并且通常与 Elasticsearch 中的等效名称对齐。description 字段显示查询的 Lucene 解释文本，并可用于帮助区分查询的各个部分（例如，message:get 和 message:search 都是 TermQuery 的，否则会完全相同。 time_in_nanos 字段显示，整个 BooleanQuery 执行此查询大约需要11.9ms。记录的时间包括所有子代。 breakdown 字段将提供有关时间花费情况的详细统计信息，我们稍后将对此进行研究。最后，children 数组列出可能存在的所有子查询。因为我们搜索了两个值（“get search”），所以 BooleanQuery 包含两个子项 TermQuery。它们具有相同的信息（类型、时间、故障等）。子代可以有自己的子代。 ","version":"Next","tagName":"h3"},{"title":"细化计时​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#细化计时","content":"breakdown 组件列出了有关低级别 Lucene 执行的详细计时统计信息： &quot;breakdown&quot;: { &quot;set_min_competitive_score_count&quot;: 0, &quot;match_count&quot;: 5, &quot;shallow_advance_count&quot;: 0, &quot;set_min_competitive_score&quot;: 0, &quot;next_doc&quot;: 39022, &quot;match&quot;: 4456, &quot;next_doc_count&quot;: 5, &quot;score_count&quot;: 5, &quot;compute_max_score_count&quot;: 0, &quot;compute_max_score&quot;: 0, &quot;advance&quot;: 84525, &quot;advance_count&quot;: 1, &quot;score&quot;: 37779, &quot;build_scorer_count&quot;: 2, &quot;create_weight&quot;: 4694895, &quot;shallow_advance&quot;: 0, &quot;create_weight_count&quot;: 1, &quot;build_scorer&quot;: 7112295 }  计时以挂钟纳秒为单位列出，完全不规范化。所有关于全部 time_in_nanos 的警告都适用于此处。分解的目的是让你感觉 A）Lucene 中的什么机器实际上在消耗时间，B）不同组件之间的时间差异的大小。与总时间一样，细分也包括所有子时间。 统计数据的含义如下： 所有参数：||| |--|--| |create_weight|Lucene 中的查询必须能够跨多个索引搜索器重用（将其视为针对特定 Lucene 索引执行搜索的引擎）。这让 Lucene 陷入了一个棘手的境地，因为许多查询需要积累与它所针对的索引相关联的临时状态/统计信息，但查询契约要求它必须是不可变的。 为了解决这个问题，Lucene 要求每个查询生成一个权重对象，该对象充当临时上下文对象，以保存与这个特定（IndexSearcher，query）元组关联的状态。weight 指标显示此过程所需的时间| |build_scorer|此参数显示为查询构建记分器所需的时间。记分器是一种在匹配的文档上迭代并为每个文档生成分数的机制（例如，“foo” 与文档的匹配程度如何？）。注意，这记录了生成记分器对象所需的时间，而不是对文档进行实际记分。有些查询的记分器初始化速度更快或更慢，具体取决于优化、复杂性等。 如果对查询启用和/或适用，这还可能显示与缓存相关的计时| |next_doc|Lucene 方法 next_doc 返回与查询匹配的下一个文档的文档ID。此统计信息显示了确定下一个匹配的文档所需的时间，这一过程根据查询的性质有很大的不同。Next_doc 是 advance() 的一种特殊形式，对于 Lucene 中的许多查询更方便。相当于 advance(docId()+1)| |advance|advance是 next_doc 的“低级”版本：它的作用与查找下一个匹配的文档相同，但需要调用查询执行额外的任务，例如识别和移动跳过的内容等。然而，并非所有查询都可以使用next\\u doc，因此advance也会对这些查询进行计时。 |advance|advance是 next_doc 的“低级”版本：它的作用与查找下一个匹配的文档相同，但需要调用查询执行额外的任务，例如识别和移动跳过的内容等。然而，并非所有查询都可以使用 ，因此 advance 也会对这些查询进行计时。 连接词（例如布尔值中的must子句）是 advance 的典型使用者| |match|有些查询（如短语查询）使用“两阶段”过程匹配文档。首先，文档是“大致”匹配的，如果它大致匹配，则会使用更严格（且更昂贵）的过程再次检查它。第二阶段验证是 match 统计度量的内容。 例如，短语查询首先通过确保短语中的所有术语都存在于文档中来大致检查文档。如果所有术语都存在，则执行第二阶段验证，以确保术语能够形成短语，这比仅检查术语的存在相对更昂贵。 由于这两个阶段的过程仅由少数查询使用，因此 match 统计信息通常为零| |score|这记录了通过特定文档的记分器对其进行记分所需的时间| |*_count|记录特定方法的调用次数。例如，&quot;next_doc_count&quot;: 2 表示对两个不同的文档调用了 nextDoc() 方法。通过比较不同查询组件之间的计数，这可以帮助判断查询的选择性。| ","version":"Next","tagName":"h2"},{"title":"collectors 部分​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#collectors-部分","content":"响应的收集器部分显示高级执行详细信息。Lucene 的工作方式是定义一个“收集器”，负责协调匹配文档的遍历、评分和收集。收集器也是单个查询记录聚合结果、执行非范围“全局”查询、执行查询后过滤器等的方式。 查看前面的示例： &quot;collector&quot;: [ { &quot;name&quot;: &quot;SimpleTopScoreDocCollector&quot;, &quot;reason&quot;: &quot;search_top_hits&quot;, &quot;time_in_nanos&quot;: 775274 } ]  我们看到一个名为 SimpleTopScoreDocCollector 的收集器包装到 CancelableCollector 中。SimpleTopScoreDocCollector 是 Elasticsearch 使用的默认“评分和排序” Collector。reason 字段尝试提供类名的纯英语描述。time_in_nanos 类似于查询树中的时间：包含所有子级的挂钟时间。类似地，children 列出所有子收集器。Elasticsearch 使用包装 SimpleTopScoreDocCollector 的 CancelableCollector 来检测当前搜索是否已取消，并在当前搜索发生时立即停止收集文档。 应该注意的是，收集器时间独立于查询时间。它们是独立计算、组合和归一化的！由于 Lucene 执行的性质，不可能将采集器中的时间“合并”到查询部分，因此它们会显示在单独的部分中。 作为参考，各种收集原因如下： \tsearch_sorted\t对文档进行评分和排序的收集器。这是最常见的收集器，将在最简单的搜索中看到。 search_count\t一种收集器，只统计与查询匹配的文档数，而不提取源。当指定 size: 0 时，会看到这种情况。 search_terminate_after_count\t在找到 n 个匹配文档后终止搜索执行的收集器。当指定了查询参数 terminate_after_count 时，就会看到这种情况。 search_min_score\t仅返回得分大于 n 的匹配文档的收集器。当指定了顶级参数 min_score 时，就会看到这种情况。 search_multi\t包装其他几个收集器的收集器。当搜索、聚合、全局聚合和 post_filters 组合在一个搜索中时，就会看到这种情况。 search_timeout\t在指定时间段后停止执行的收集器。当指定了 timeout 顶级参数时，就会看到这种情况。 aggregation\tElasticsearch 用于对查询范围运行聚合的收集器。单个 aggregation 收集器用于收集所有聚合的文档，因此你将看到名称中的聚合列表。 global_aggregation\t针对全局查询范围而不是指定查询执行聚合的收集器。由于全局范围必然不同于已执行的查询，因此它必须执行自己的match\\u all查询（你将看到该查询已添加到查询部分）以收集整个数据集 ","version":"Next","tagName":"h3"},{"title":"rewrite 部分​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#rewrite-部分","content":"Lucene 中的所有查询都会经历一个“重写”过程。查询（及其子查询）可能会被重写一次或多次，并且该过程将继续，直到查询停止更改为止。此过程允许 Lucene 执行优化，例如删除冗余子句，替换一个查询以获得更高效的执行路径，等等。例如 Boolean → Boolean → TermQuery 可以重写为 TermQuery，因为在这种情况下，所有布尔值都是不必要的。 重写过程很复杂，很难显示，因为查询可能会发生剧烈的变化。总重写时间只显示为一个值（以纳秒为单位），而不是显示中间结果。该值是累积的，包含所有查询被重写的总时间。 ","version":"Next","tagName":"h3"},{"title":"一个更复杂的例子​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#一个更复杂的例子","content":"为了演示稍微复杂一点的查询和关联结果，我们可以分析以下查询： GET /my-index-000001/_search { &quot;profile&quot;: true, &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: { &quot;value&quot;: &quot;elkbee&quot; } } }, &quot;aggs&quot;: { &quot;my_scoped_agg&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;http.response.status_code&quot; } }, &quot;my_global_agg&quot;: { &quot;global&quot;: {}, &quot;aggs&quot;: { &quot;my_level_agg&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;http.response.status_code&quot; } } } } }, &quot;post_filter&quot;: { &quot;match&quot;: { &quot;message&quot;: &quot;search&quot; } } }  此例子有这些东西： 一个查询一个范围聚合一个全局聚合一个 post_filter 此 API 返回以下响应： { ... &quot;profile&quot;: { &quot;shards&quot;: [ { &quot;id&quot;: &quot;[P6-vulHtQRWuD4YnubWb7A][my-index-000001][0]&quot;, &quot;searches&quot;: [ { &quot;query&quot;: [ { &quot;type&quot;: &quot;TermQuery&quot;, &quot;description&quot;: &quot;message:search&quot;, &quot;time_in_nanos&quot;: 141618, &quot;breakdown&quot;: { &quot;set_min_competitive_score_count&quot;: 0, &quot;match_count&quot;: 0, &quot;shallow_advance_count&quot;: 0, &quot;set_min_competitive_score&quot;: 0, &quot;next_doc&quot;: 0, &quot;match&quot;: 0, &quot;next_doc_count&quot;: 0, &quot;score_count&quot;: 0, &quot;compute_max_score_count&quot;: 0, &quot;compute_max_score&quot;: 0, &quot;advance&quot;: 3942, &quot;advance_count&quot;: 4, &quot;score&quot;: 0, &quot;build_scorer_count&quot;: 2, &quot;create_weight&quot;: 38380, &quot;shallow_advance&quot;: 0, &quot;create_weight_count&quot;: 1, &quot;build_scorer&quot;: 99296 } }, { &quot;type&quot;: &quot;TermQuery&quot;, &quot;description&quot;: &quot;user.id:elkbee&quot;, &quot;time_in_nanos&quot;: 163081, &quot;breakdown&quot;: { &quot;set_min_competitive_score_count&quot;: 0, &quot;match_count&quot;: 0, &quot;shallow_advance_count&quot;: 0, &quot;set_min_competitive_score&quot;: 0, &quot;next_doc&quot;: 2447, &quot;match&quot;: 0, &quot;next_doc_count&quot;: 4, &quot;score_count&quot;: 4, &quot;compute_max_score_count&quot;: 0, &quot;compute_max_score&quot;: 0, &quot;advance&quot;: 3552, &quot;advance_count&quot;: 1, &quot;score&quot;: 5027, &quot;build_scorer_count&quot;: 2, &quot;create_weight&quot;: 107840, &quot;shallow_advance&quot;: 0, &quot;create_weight_count&quot;: 1, &quot;build_scorer&quot;: 44215 } } ], &quot;rewrite_time&quot;: 4769, &quot;collector&quot;: [ { &quot;name&quot;: &quot;MultiCollector&quot;, &quot;reason&quot;: &quot;search_multi&quot;, &quot;time_in_nanos&quot;: 1945072, &quot;children&quot;: [ { &quot;name&quot;: &quot;FilteredCollector&quot;, &quot;reason&quot;: &quot;search_post_filter&quot;, &quot;time_in_nanos&quot;: 500850, &quot;children&quot;: [ { &quot;name&quot;: &quot;SimpleTopScoreDocCollector&quot;, &quot;reason&quot;: &quot;search_top_hits&quot;, &quot;time_in_nanos&quot;: 22577 } ] }, { &quot;name&quot;: &quot;MultiBucketCollector: [[my_scoped_agg, my_global_agg]]&quot;, &quot;reason&quot;: &quot;aggregation&quot;, &quot;time_in_nanos&quot;: 867617 } ] } ] } ], &quot;aggregations&quot;: [...], &quot;fetch&quot;: {...} } ] } }  &quot;aggregations&quot;: [...]：“aggregations（聚合）”部分已被省略，因为它将在下一节中介绍。 如你所见，输出比以前要详细得多。查询的所有主要部分都表示为： 第一个 TermQuery（user.id:elkbee）表示主 term 查询。第二个 TermQuery（message:search）表示 post_filter 查询。 收集器树非常简单，它显示了单个 CancelableCollector 如何包装多个收集器，多个收集器也包装 FilteredCollector 以执行 post_filter （并反过来包装正常的评分 SimpleCollector），BucketCollector 如何运行所有范围的聚合。 ","version":"Next","tagName":"h3"},{"title":"了解 MultiTermQuery 的输出​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#了解-multitermquery-的输出","content":"需要特别注意 MultiTermQuery 查询类。这包括通配符、正则表达式和模糊查询。这些查询发出非常详细的响应，并且没有过度结构化。 从本质上讲，这些查询在每个段的基础上重写自己。如果你设想通配符查询 b*，从技术上讲，它可以匹配以字母“b”开头的任何标记。不可能枚举所有可能的组合，因此 Lucene 会在被评估段的上下文中重写查询，例如，一个段可能包含标记 [bar，baz]，因此查询会重写为“bar”和“baz”的布尔查询组合。另一段可能只有标记 [bakery]，因此查询将重写为“bakery”的单个 TermQuery。 由于这种动态的逐段重写，干净的树结构变得扭曲，不再遵循显示一个查询如何重写到下一个查询的干净“沿袭”。目前，我们所能做的就是道歉，如果太令人困惑，建议你折叠查询子项的详细信息。幸运的是，所有的计时统计信息都是正确的，只是响应中的物理布局不正确，因此，如果你发现细节太复杂而无法解释，只分析顶级 MultiTermQuery 并忽略其子项就足够了。 希望这将在未来的迭代中得到修复，但这是一个需要解决的棘手问题，仍在进行中。:) ","version":"Next","tagName":"h3"},{"title":"分析聚合​","type":1,"pageTitle":"分析 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/profile#分析聚合","content":"aggregations 部分​ aggregations 部分包含由特定分片执行的聚合树的详细计时。此聚合树的总体结构类似于你最初的 Elasticsearch 请求。让我们再次执行前面的查询，并查看这次的聚合配置文件： GET /my-index-000001/_search { &quot;profile&quot;: true, &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: { &quot;value&quot;: &quot;elkbee&quot; } } }, &quot;aggs&quot;: { &quot;my_scoped_agg&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;http.response.status_code&quot; } }, &quot;my_global_agg&quot;: { &quot;global&quot;: {}, &quot;aggs&quot;: { &quot;my_level_agg&quot;: { &quot;terms&quot;: { &quot;field&quot;: &quot;http.response.status_code&quot; } } } } }, &quot;post_filter&quot;: { &quot;match&quot;: { &quot;message&quot;: &quot;search&quot; } } }  这将产生以下聚合分析输出： { &quot;profile&quot;: { &quot;shards&quot;: [ { &quot;aggregations&quot;: [ { &quot;type&quot;: &quot;NumericTermsAggregator&quot;, &quot;description&quot;: &quot;my_scoped_agg&quot;, &quot;time_in_nanos&quot;: 79294, &quot;breakdown&quot;: { &quot;reduce&quot;: 0, &quot;build_aggregation&quot;: 30885, &quot;build_aggregation_count&quot;: 1, &quot;initialize&quot;: 2623, &quot;initialize_count&quot;: 1, &quot;reduce_count&quot;: 0, &quot;collect&quot;: 45786, &quot;collect_count&quot;: 4, &quot;build_leaf_collector&quot;: 18211, &quot;build_leaf_collector_count&quot;: 1, &quot;post_collection&quot;: 929, &quot;post_collection_count&quot;: 1 }, &quot;debug&quot;: { &quot;total_buckets&quot;: 1, &quot;result_strategy&quot;: &quot;long_terms&quot;, &quot;built_buckets&quot;: 1 } }, { &quot;type&quot;: &quot;GlobalAggregator&quot;, &quot;description&quot;: &quot;my_global_agg&quot;, &quot;time_in_nanos&quot;: 104325, &quot;breakdown&quot;: { &quot;reduce&quot;: 0, &quot;build_aggregation&quot;: 22470, &quot;build_aggregation_count&quot;: 1, &quot;initialize&quot;: 12454, &quot;initialize_count&quot;: 1, &quot;reduce_count&quot;: 0, &quot;collect&quot;: 69401, &quot;collect_count&quot;: 4, &quot;build_leaf_collector&quot;: 8150, &quot;build_leaf_collector_count&quot;: 1, &quot;post_collection&quot;: 1584, &quot;post_collection_count&quot;: 1 }, &quot;debug&quot;: { &quot;built_buckets&quot;: 1 }, &quot;children&quot;: [ { &quot;type&quot;: &quot;NumericTermsAggregator&quot;, &quot;description&quot;: &quot;my_level_agg&quot;, &quot;time_in_nanos&quot;: 76876, &quot;breakdown&quot;: { &quot;reduce&quot;: 0, &quot;build_aggregation&quot;: 13824, &quot;build_aggregation_count&quot;: 1, &quot;initialize&quot;: 1441, &quot;initialize_count&quot;: 1, &quot;reduce_count&quot;: 0, &quot;collect&quot;: 61611, &quot;collect_count&quot;: 4, &quot;build_leaf_collector&quot;: 5564, &quot;build_leaf_collector_count&quot;: 1, &quot;post_collection&quot;: 471, &quot;post_collection_count&quot;: 1 }, &quot;debug&quot;: { &quot;total_buckets&quot;: 1, &quot;result_strategy&quot;: &quot;long_terms&quot;, &quot;built_buckets&quot;: 1 } } ] } ] } ] } }  从分析结构中，我们可以看到 my_scoped_agg 在内部作为 NumericTermsAggregator 运行（因为它正在聚合的字段 http.response.status_code 是一个数字字段）。在同一级别，我们看到一个来自 my_global_agg 的 GlobalAggregator。然后，该聚合有一个子 NumericTermsAggregator，它来自 http.response.status_code 上第二个词语的聚合。 time_in_nanos 字段显示每个聚合执行的时间，并包含所有子级。虽然总时间很有用，但 breakdown 字段将提供有关时间花费情况的详细统计信息。 一些聚合可能会返回专家 debug 信息，这些信息描述了聚合底层执行的功能，这些功能“对入侵聚合的人有用，但我们不希望在其他方面有用”。它们在版本、聚合和聚合执行策略之间可能存在很大差异。 细化计时​ breakdown 组件列出了有关低级执行的详细统计信息： &quot;breakdown&quot;: { &quot;reduce&quot;: 0, &quot;build_aggregation&quot;: 30885, &quot;build_aggregation_count&quot;: 1, &quot;initialize&quot;: 2623, &quot;initialize_count&quot;: 1, &quot;reduce_count&quot;: 0, &quot;collect&quot;: 45786, &quot;collect_count&quot;: 4, &quot;build_leaf_collector&quot;: 18211, &quot;build_leaf_collector_count&quot;: 1 }  breakdown 组件中的每个属性对应于聚合的内部方法。例如，build_leaf_collector 属性测量运行聚合的 getLeafCollector() 方法所花费的纳秒数。以 _count 结尾的属性记录特定方法的调用次数。例如， &quot;collect_count&quot;: 2 表示对两个不同文档调用 collect() 的聚合。reduce 属性保留供将来使用，并始终返回 0。 计时以挂钟纳秒为单位列出，完全不规范化。关于总 time 的所有注意事项均适用于此处。分解的目的是让你了解 A）Elasticsearch 中的哪些机制实际上在消耗时间，以及 B）不同组件之间时间差异的大小。与总时间一样，细分也包括所有子时间。 分析获取​ 提取的文档的所有分片在配置文件中都有一个 fetch 部分。让我们执行一个小搜索，并查看提取分析： GET /my-index-000001/_search?filter_path=profile.shards.fetch { &quot;profile&quot;: true, &quot;query&quot;: { &quot;term&quot;: { &quot;user.id&quot;: { &quot;value&quot;: &quot;elkbee&quot; } } } }  以下是提取的分析： { &quot;profile&quot;: { &quot;shards&quot;: [ { &quot;fetch&quot;: { &quot;type&quot;: &quot;fetch&quot;, &quot;description&quot;: &quot;&quot;, &quot;time_in_nanos&quot;: 660555, &quot;breakdown&quot;: { &quot;next_reader&quot;: 7292, &quot;next_reader_count&quot;: 1, &quot;load_stored_fields&quot;: 299325, &quot;load_stored_fields_count&quot;: 5 }, &quot;debug&quot;: { &quot;stored_fields&quot;: [&quot;_id&quot;, &quot;_routing&quot;, &quot;_source&quot;] }, &quot;children&quot;: [ { &quot;type&quot;: &quot;FetchSourcePhase&quot;, &quot;description&quot;: &quot;&quot;, &quot;time_in_nanos&quot;: 20443, &quot;breakdown&quot;: { &quot;next_reader&quot;: 745, &quot;next_reader_count&quot;: 1, &quot;process&quot;: 19698, &quot;process_count&quot;: 5 }, &quot;debug&quot;: { &quot;fast_path&quot;: 4 } } ] } } ] } }  由于这是关于 Elasticsearch 执行获取方式的调试信息，因此它可以在不同的请求和版本之间进行更改。即使是补丁版本也可能会更改此处的输出。这种不一致性使得它对调试非常有用。 无论如何 time_in_nanos 测量提取阶段的总时间。breakdown 计数和我们在 next_reader 中的每段准备时间，以及在 load_stored_fields 字段中加载存储字段所花费的时间。Debug 包含各种非计时信息，特别是 stored_fields 列出了提取所必须加载的存储字段。如果是空列表，则提取将完全跳过加载存储字段。 children 部分列出了执行实际提取工作的子阶段，breakdown 中包含了 next_reader 中每段准备和每文档提取 process 的计数和计时。 提示 我们努力加载前期提取所需的所有存储字段。这往往会使 _source 阶段每次命中几微秒。在这种情况下，_source 阶段的真实成本隐藏在细分的 load_stored_fields 组件中。通过设置 &quot;_source&quot;: false, &quot;stored_fields&quot;: [&quot;_none_&quot;] ，可以完全跳过加载存储字段。 分析注意事项​ 与任何探查器一样，分析 API 为搜索执行带来了不可忽视的开销。插装低级方法调用（如 collect、advance 和 next_doc）的行为可能相当昂贵，因为这些方法是在紧密循环中调用的。因此，默认情况下，不应在生产设置中启用分析，也不应与未分析的查询时间进行比较。分析只是一种诊断工具。 还有一些情况下，特殊的 Lucene 优化被禁用，因为它们不适合评测。这可能会导致某些查询报告的相对时间比未分析的查询报告的相对时间要长，但与分析的查询中的其他组件相比，通常不会产生太大的影响。 限制​ 分析当前无法测量网络开销。分析也不考虑在队列中花费的时间、在协调节点上合并分片响应或其他工作，例如构建全局序号（用于加快搜索的内部数据结构）。分析统计信息当前不可用于建议、突出显示、dfs_query_then_fetch。聚合的收缩（reduce）阶段的分析目前不可用。探查器正在检测可以在不同版本之间更改的内部构件。产生的json应该被认为是最不稳定的，尤其是在 debug 部分。 原文链接 ","version":"Next","tagName":"h3"},{"title":"search_shard_routing","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/search_your_data/the_search_api/search_shard_routing","content":"search_shard_routing","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"设置 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"支持的平台​","type":1,"pageTitle":"设置 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/#支持的平台","content":"官方支持的操作系统的 JVM 列表见：支持列表。Elasticsearch 在列出的平台上进行了测试，但它也可能在其他平台运行。 ","version":"Next","tagName":"h2"},{"title":"Java (JVM) 版本​","type":1,"pageTitle":"设置 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/#java-jvm-版本","content":"Elasticsearch 使用 Java构建，在每个发行版本中都包含 JDK 维护者（GPLv2+CE）提供的 OpenJDK 捆绑版本。捆绑的 JVM 是推荐的 JVM，位于 Elasticsearch 主目录中的 jdk 目录中。 要使用你自己版本的 Java，设置 JAVA_HOME 环境变量。如果你必须使用不同于捆绑 JVM 的 Java 版本，我们推荐你使用受支持的 LTS 版本的 Java。如果使用已知的坏版本 Java，Elasticsearch 会拒绝启动。使用你的自己的 JVM时，捆绑 JVM 目录 可能被删除。 原文链接 ","version":"Next","tagName":"h2"},{"title":"行为分析事件参考","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"字段概述​","type":1,"pageTitle":"行为分析事件参考","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference#字段概述","content":"通用事件字段搜索事件字段搜索点击事件字段页面浏览事件字段 ","version":"Next","tagName":"h2"},{"title":"通用事件字段​","type":1,"pageTitle":"行为分析事件参考","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference#通用事件字段","content":"@timestamp事件的时间戳event.action事件类型。可能的值包括搜索、搜索点击和页面浏览。event.source事件的来源。可能的值是客户端和服务器。session.id会话的唯一标识符。user.id用户的唯一标识符。_id文件 ID。_index索引名称。_score文件的得分。 ","version":"Next","tagName":"h2"},{"title":"搜索事件字段​","type":1,"pageTitle":"行为分析事件参考","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference#搜索事件字段","content":"search.filters应用于搜索查询的筛选器。search.query搜索查询。search.results.items.document.id搜索结果中文档的 ID。search.results.items.document.index搜索结果中文件的索引。search.results.items.page.url.domain搜索结果中页面的 URL 域。search.results.items.page.url.original搜索结果中页面的原始 URL。search.results.items.page.url.path搜索结果中页面的 URL 路径。search.results.items.page.url.scheme搜索结果中页面的 URL 方案。search.results.total_results搜索查询返回的结果总数。search.search_application用于执行搜索查询的搜索应用程序。search.sort.name应用于搜索查询的排序名称。 ","version":"Next","tagName":"h2"},{"title":"搜索点击事件字段​","type":1,"pageTitle":"行为分析事件参考","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference#搜索点击事件字段","content":"document.id被点击文档的 ID。document.index包含被点击文档的索引。page.url.domain被点击页面的 URL 域。page.url.original被点击页面的原始 URL。page.url.path被点击页面的 URL 路径。page.url.scheme被点击页面的 URL 方案。search.filters应用于搜索查询的筛选器。search.query搜索查询。search.results.items.document.id搜索结果中文档的 ID。search.results.items.document.index搜索结果中文件的索引。search.results.items.page.url.domain搜索结果中页面的 URL 域。search.results.items.page.url.original搜索结果中页面的原始 URL。search.results.items.page.url.path搜索结果中页面的 URL 路径。search.results.items.page.url.scheme搜索结果中页面的 URL 方案。search.results.total_results搜索查询返回的结果总数。search.search_application用于执行搜索查询的搜索应用程序。search.sort.name应用于搜索查询的排序名称。session.location.country_iso_code搜索点击所在国家的 ISO 代码。session.location.country_name出现搜索点击的国家名称。 ","version":"Next","tagName":"h2"},{"title":"页面浏览事件字段​","type":1,"pageTitle":"行为分析事件参考","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference#页面浏览事件字段","content":"document.id已查看文件的 ID。document.index包含已查看文件的索引。page.referrer.domain指向已浏览页面的页面的 URL 域。page.referrer.original引用所浏览页面的原始 URL。page.referrer.path指向所浏览页面的页面路径。page.referrer.scheme指向所浏览页面的页面的 URL 方案。page.title浏览页面的标题。page.url.domain浏览页面的 URL 域。page.url.original浏览页面的原始 URL。page.url.path浏览页面的 URL 路径。page.url.scheme浏览页面的 URL 方案。session.location.country_iso_code页面浏览所在国家的 ISO 代码。session.location.country_name页面浏览所在国家的名称。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"行为分析事件参考","url":"/docs/elasticsearch-cn/search_your_data/search_analytics/events_reference#示例","content":"查看 search 事件数据对象的完整示例： { &quot;@timestamp&quot;: [ &quot;2023-05-16T12:52:29.003Z&quot; ], &quot;event.action&quot;: [ &quot;search&quot; ], &quot;event.source&quot;: [ &quot;client&quot; ], &quot;search.filters&quot;: [ { &quot;color&quot;: [ &quot;silver&quot; ], &quot;brand&quot;: [ &quot;Robel, Klocko and Ziemann&quot;, &quot;McClure, Marks and Mertz&quot; ] } ], &quot;search.query&quot;: [ &quot;transformation&quot; ], &quot;search.results.items.document.id&quot;: [ &quot;045a164b-229e-40b5-ba66-b2ebabd2a251&quot; ], &quot;search.results.items.document.index&quot;: [ &quot;products&quot; ], &quot;search.results.items.page.url.domain&quot;: [ &quot;fancy-overcoat.org&quot; ], &quot;search.results.items.page.url.original&quot;: [ &quot;http://fancy-overcoat.org/happy/pancakes/deals&quot; ], &quot;search.results.items.page.url.path&quot;: [ &quot;/happy/pancakes/deals&quot; ], &quot;search.results.items.page.url.scheme&quot;: [ &quot;http&quot; ], &quot;search.results.total_results&quot;: [ 67 ], &quot;search.search_application&quot;: [ &quot;search-ui&quot; ], &quot;search.sort.name&quot;: [ &quot;relevance&quot; ], &quot;session.id&quot;: [ &quot;2bc31b08-d443-4b7a-81ea-65edf3dd82e7&quot; ], &quot;user.id&quot;: [ &quot;42704a4b-692b-4654-bb67-a65eb0c72f15&quot; ], &quot;_id&quot;: &quot;y3IBBogBWHKTU-4a543S&quot;, &quot;_index&quot;: &quot;.ds-behavioral_behavioral-analytics-event-website-2023.05.10-000001&quot;, &quot;_score&quot;: null }  查看 search_click 事件数据对象的完整示例： { &quot;@timestamp&quot;: [ &quot;2023-05-16T12:22:23.468Z&quot; ], &quot;document.id&quot;: [ &quot;38cca784-109a-4ea0-a4e8-60c3be667ffd&quot; ], &quot;document.index&quot;: [ &quot;products&quot; ], &quot;event.action&quot;: [ &quot;search_click&quot; ], &quot;event.source&quot;: [ &quot;client&quot; ], &quot;page.url.domain&quot;: [ &quot;unfurnished-appartments&quot; ], &quot;page.url.original&quot;: [ &quot;https://unfurnished-appartments/new/europe&quot; ], &quot;page.url.path&quot;: [ &quot;/new/europe&quot; ], &quot;page.url.scheme&quot;: [ &quot;https&quot; ], &quot;search.filters&quot;: [ { &quot;brand&quot;: [ &quot;McClure, Marks and Mertz&quot;, &quot;Ondricka - Rath&quot; ] } ], &quot;search.query&quot;: [ &quot;ferryboat&quot; ], &quot;search.results.items.document.id&quot;: [ &quot;0c76967b-4915-446e-9b2c-b1bfb9e39e1e&quot; ], &quot;search.results.items.document.index&quot;: [ &quot;products&quot; ], &quot;search.results.items.page.url.domain&quot;: [ &quot;dependent-lecture.info&quot; ], &quot;search.results.items.page.url.original&quot;: [ &quot;http://dependent-lecture.info/documents/additional/latest&quot; ], &quot;search.results.items.page.url.path&quot;: [ &quot;/documents/additional/latest&quot; ], &quot;search.results.items.page.url.scheme&quot;: [ &quot;http&quot; ], &quot;search.results.total_results&quot;: [ 54 ], &quot;search.search_application&quot;: [ &quot;search-ui&quot; ], &quot;search.sort.name&quot;: [ &quot;relevance&quot; ], &quot;session.id&quot;: [ &quot;9411fb93-8707-49a4-baab-cec4d6aef753&quot; ], &quot;session.location.country_iso_code&quot;: [ &quot;GP&quot; ], &quot;session.location.country_name&quot;: [ &quot;Guadeloupe&quot; ], &quot;user.id&quot;: [ &quot;911d0c19-e713-4413-8f4c-c6c612bc37c4&quot; ], &quot;_id&quot;: &quot;m8cBBogBG4-Ak0Iy7LME&quot;, &quot;_index&quot;: &quot;.ds-behavioral_behavioral-analytics-event-website-2023.05.10-000001&quot;, &quot;_score&quot;: null }  查看 pageview 事件数据对象的完整示例： { &quot;@timestamp&quot;: [ &quot;2023-05-16T12:52:51.309Z&quot; ], &quot;document.id&quot;: [ &quot;c98ppfc8-3a04-4a20-888a-f87292b31181&quot; ], &quot;document.index&quot;: [ &quot;products&quot; ], &quot;event.action&quot;: [ &quot;page_view&quot; ], &quot;event.source&quot;: [ &quot;client&quot; ], &quot;page.referrer.domain&quot;: [ &quot;happy-pancakes.name&quot; ], &quot;page.referrer.original&quot;: [ &quot;https://happy-pancakes.name/magnam&quot; ], &quot;page.referrer.path&quot;: [ &quot;/magnam&quot; ], &quot;page.referrer.scheme&quot;: [ &quot;https&quot; ], &quot;page.title&quot;: [ &quot;Super fast delivery&quot; ], &quot;page.url.domain&quot;: [ &quot;happy-staircase.net&quot; ], &quot;page.url.original&quot;: [ &quot;http://happy-staircase.net/quam&quot; ], &quot;page.url.path&quot;: [ &quot;/quam&quot; ], &quot;page.url.scheme&quot;: [ &quot;http&quot; ], &quot;session.id&quot;: [ &quot;2bc31b08-d443-4b7a-81ea-65edf3dd82e7&quot; ], &quot;session.location.country_iso_code&quot;: [ &quot;SN&quot; ], &quot;session.location.country_name&quot;: [ &quot;Senegal&quot; ], &quot;user.id&quot;: [ &quot;42704a4b-692b-4654-bb67-a65eb0c72f15&quot; ], &quot;_id&quot;: &quot;zHIBBogBWHKTU-4a543S&quot;, &quot;_index&quot;: &quot;.ds-behavioral_behavioral-analytics-event-website-2023.05.10-000001&quot;, &quot;_score&quot;: null }  原文链接 ","version":"Next","tagName":"h2"},{"title":"配置 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"配置文件位置​","type":1,"pageTitle":"配置 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/#配置文件位置","content":"Elasticsearch有三个配置文件： elasticsearch.yml 用于配置 Elasticsearch jvm.options 用于配置 Elasticsearch JVM 设置 log4j2.properties 用于配置 Elasticsearch 日志记录 这些文件位于 config 目录中，其默认位置取决于安装是来自存档发行版（tar.gz 或 zip）还是软件包发行版（Debian 或 RPM 软件包）。 对于压缩分发版，配置目录位置默认为 $ES_HOME/config。可以通过 ES_PATH_CONF 环境变量更改配置目录的位置，如下所示： ES_PATH_CONF=/path/to/my/config ./bin/elasticsearch  或者，你可以通过命令行或shell概要文件导出ES_PATH_CONF环境变量。 对于包发行版，配置目录位置默认为 /etc/elasticsearch。还可以通过 ES_PATH_CONF 环境变量更改配置目录的位置，但请注意，在 shell 中设置此值是不够的。相反，这个变量来源于 /etc/default/elasticsearch（对于 Debian 包）和 /etc/sysconfig/elasticsearch（对于 RPM 包）。你需要相应地编辑其中一个文件中的 ES_PATH_CONF=/etc/elasticsearch 条目，以更改配置目录位置。 ","version":"Next","tagName":"h2"},{"title":"配置文件格式​","type":1,"pageTitle":"配置 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/#配置文件格式","content":"配置格式为 YAML。以下是更改数据和日志目录路径的示例： path: data: /var/lib/elasticsearch logs: /var/log/elasticsearch  还可以按如下方式展平设置： path.data: /var/lib/elasticsearch path.logs: /var/log/elasticsearch  在 YAML 中，可以将非标量值格式化为序列： discovery.seed_hosts: - 192.168.1.10:9300 - 192.168.1.11 - seeds.mydomain.com  虽然不太常见，但也可以将非标量值格式化为数组： discovery.seed_hosts: [&quot;192.168.1.10:9300&quot;, &quot;192.168.1.11&quot;, &quot;seeds.mydomain.com&quot;]  ","version":"Next","tagName":"h2"},{"title":"环境变量替代​","type":1,"pageTitle":"配置 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/#环境变量替代","content":"配置文件中使用 ${…} 符号引用的环境变量将替换为环境变量的值。例如： node.name: ${HOSTNAME} network.host: ${ES_NETWORK_HOST}  环境变量的值必须是简单字符串。使用逗号分隔的字符串提供 Elasticsearch 将解析为列表的值。例如，Elasticsearch 将以下字符串拆分为 ${HOSTNAME} 环境变量的值列表： export HOSTNAME=&quot;host1,host2&quot;  ","version":"Next","tagName":"h2"},{"title":"集群和节点设置类型​","type":1,"pageTitle":"配置 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/#集群和节点设置类型","content":"集群和节点设置可以根据配置方式进行分类： 动态 你可以使用集群更新设置 API 在正在运行的集群上配置和更新动态设置。你还可以使用 elasticsearch.yml 在未启动或关闭的节点上本地配置动态设置。 使用集群更新设置 API 进行的更新可以是持久的，适用于跨集群重新启动；也可以是瞬时的，在集群重新启动后重置。你还可以通过使用 API 为瞬态或持久设置分配 null 来重置它们。 如果你使用多个方法配置同一设置，Elasticsearch 将按以下优先顺序应用设置： 瞬态设置持续设置elasticsearch.yml 设置默认设置值 例如，可以应用瞬态设置来覆盖持久设置或 elasticsearch.yml 设置。但是，更改 elasticsearch.yml 设置不会覆盖已定义的瞬态或持久设置。 提示 如果使用 Elasticsearch 服务，请使用用户设置功能配置所有集群设置。此方法允许 Elasticsearch 服务自动拒绝可能破坏集群的不安全设置。 如果你在自己的硬件上运行 Elasticsearch，请使用集群更新设置 API 配置动态集群设置。仅使用 elasticsearch.yml 用于静态集群设置和节点设置。API 不需要重新启动，并确保设置的值在所有节点上都相同。 警告 我们不再建议使用临时集群设置。请改用永久集群设置。如果集群变得不稳定，瞬态设置可能会意外清除，从而导致可能不需要的集群配置。参阅瞬态设置迁移指南。 静态 只能使用 elasticsearch.yml 在未启动或关闭的节点上配置静态设置。 必须在集群中的每个相关节点上设置静态设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"断路器设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"父断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#父断路器","content":"父级断路器可以配置以下设置： indices.breaker.total.use_real_memory （静态）确定父断路器是应考虑实际内存使用（true）还是仅考虑子断路器保留的内存量（false）。默认为 true。 indices.breaker.total.limit （动态）整体母断路器的启动限制。如果 indices.breaker.total.use_real_memory 为 false，则默认 JVM 堆为 70%。。如果 indices.breaker.total.use_real_memory 为 true，默认 JVM 堆为 95%。 ","version":"Next","tagName":"h2"},{"title":"字段数据断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#字段数据断路器","content":"字段数据断路器估计将字段加载到字段数据缓存所需的堆内存。如果加载字段会导致缓存超过预定义的内存限制，断路器将停止操作并返回错误。 indices.breaker.fielddata.limit （动态）现场数据断路器的限制。默认为 JVM 堆的 40%。 indices.breaker.fielddata.overhead （动态）将所有现场数据估计值相乘以确定最终估计值的常数。默认为 1.03。 ","version":"Next","tagName":"h2"},{"title":"请求断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#请求断路器","content":"请求断路器允许 Elasticsearch 防止每个请求的数据结构（例如，请求期间用于计算聚合的内存）超过一定的内存量。 indices.breaker.request.limit （动态）请求断路器的限制，默认为 JVM 堆的 60%。 indices.breaker.request.overhead （动态）一个常数，所有请求估计都与之相乘以确定最终估计。默认为 1。 ","version":"Next","tagName":"h2"},{"title":"动态请求断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#动态请求断路器","content":"动态请求断路器允许 Elasticsearch 限制传输或 HTTP 级别上所有当前活动传入请求的内存使用，使其不超过节点上的特定内存量。内存使用情况基于请求本身的内容长度。这个断路器还考虑到，不仅需要内存来表示原始请求，而且还需要内存作为一个结构化对象，由默认开销反映出来。 network.breaker.inflight_requests.limit （动态）运行中请求断路器的限制，默认为 JVM 堆的 100%。这意味着它受到为主断路器配置的限制的约束。 network.breaker.inflight_requests.overhead （动态）一个常数，所有动态请求估值都乘以该常数以确定最终估值。默认为 2。 ","version":"Next","tagName":"h2"},{"title":"记账请求断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#记账请求断路器","content":"记帐断路器允许 Elasticsearch 限制内存中保存的、请求完成时未释放的内容的内存使用。这包括 Lucene 段内存之类的东西。 indices.breaker.accounting.limit （动态）记帐断路器的限制，默认为 JVM 堆的 100%。这意味着它受到为主断路器配置的限制的约束。 indices.breaker.accounting.overhead （动态）将所有记账估值相乘以确定最终估值的常数。默认为 1。 ","version":"Next","tagName":"h2"},{"title":"脚本编译断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#脚本编译断路器","content":"与以前基于内存的断路器略有不同，脚本编译断路器限制了一段时间内内联脚本编译的数量。 script.max_compilations_rate （动态）限制在特定间隔内允许编译的唯一动态脚本的数量。默认为 150/5m，即每 5 分钟 150 次。 如果集群定期达到给定的 max_compilation_rate，则脚本缓存可能大小不足，请使用节点统计检查最近缓存收回的数量、 script.cache_evictions_history 和编译 script.compilations_hiology。如果最近有大量缓存收回或编译，脚本缓存可能大小不足，请考虑通过设置 script.cache.max_size 将脚本缓存的大小加倍。 有关详细信息，参阅脚本文档的“首选参数”部分。 ","version":"Next","tagName":"h2"},{"title":"正则断路器​","type":1,"pageTitle":"断路器设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/circuit_breaker_settings#正则断路器","content":"编写不好的正则表达式会降低集群的稳定性和性能。正则断路器限制了 Painless 脚本中正则的使用和复杂性。 script.painless.regex.enabled （静态）在 Painless 脚本中启用正则。允许以下值： limited (默认) 启用正则，但使用 script.painles.regex.limit-factor 集群设置限制复杂度。 true 启用正则并不限制复杂度。禁用正则断路器。 false 禁用正则。任何包含正则表达式的 Painless 脚本都会返回一个错误。 script.painless.regex.limit-factor （静态）限制 Painless 脚本中正则表达式可以考虑的字符数。Elasticsearch 通过将设置值乘以脚本输入的字符长度来计算此限制。 例如，输入 foobarbaz 的字符长度为 9。如果是 script.painless.regex.limit-factor 为 6，foobarbaz 上的正则表达式最多可以考虑 54（9 * 6）个字符。如果表达式超过此限制，则会触发正则断路器并返回错误。 Elasticsearch 仅在 script.painless.regex.enabled 为 limited 时应用此限制。 原文链接 ","version":"Next","tagName":"h2"},{"title":"审计安全设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/auditing_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"常规审计设置​","type":1,"pageTitle":"审计安全设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/auditing_settings#常规审计设置","content":"xpack.security.audit.enabled (静态)设置为 true，启用对节点的审计。默认值为 false。这将把审计事件放在一个名为 &lt;clustername&gt;_audit.json 的专用文件中。 如果启用，则必须在 elasticsearch.yml 中配置此设置。在集群中的所有节点上使用。 ","version":"Next","tagName":"h2"},{"title":"审计事件设置​","type":1,"pageTitle":"审计安全设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/auditing_settings#审计事件设置","content":"可以通过使用以下设置来控制记录的事件和其他信息: xpack.security.audit.logfile.events.include (动态)指定要在审计输出中打印的事件类型。此外，_all 可以用于详尽地审计所有事件，但通常不建议这样做，因为它会变得非常冗长。默认列表值包括：access_denied、access_granted、anonymous_access_denied、authentication_failed、connection_denied、tampered_request、run_as_denied、run_as_granted、security_config_change。 xpack.security.audit.logfile.events.exclude (动态)从包含列表中排除指定事件类型。这在事件的情况下很有用。包含设置包含特殊值 _all。默认是空列表。 xpack.security.audit.logfile.events.emit_request_body (动态)指定是否将来自 REST 请求的完整请求体作为某些类型的审计事件的属性。此设置可用于审计搜索查询。 默认值为 false，因此不打印请求体。 重要 当在审计事件中包含请求体时，建议可能会以纯文本的形式审计敏感数据，即使所有安全 API(如更改用户密码的 API)在审计时都会过滤掉凭据。 ","version":"Next","tagName":"h2"},{"title":"本地节点信息设置​","type":1,"pageTitle":"审计安全设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/auditing_settings#本地节点信息设置","content":"xpack.security.audit.logfile.emit_node_name (动态)是否在每个审计事件中包含节点名字段。默认值为 false。 xpack.security.audit.logfile.emit_node_host_address (动态)在每个审计事件中是否包含节点的 IP 地址作为字段。默认值为 false。 xpack.security.audit.logfile.emit_node_host_name (动态)是否在每个审计事件中包含节点的主机名作为字段。默认值为 false。 xpack.security.audit.logfile.emit_node_id (动态)是否在每个审计事件中包含节点id字段。节点名称的值可能在管理员更改配置文件中的设置时发生变化，与节点名称不同的是，节点 id 将在集群重新启动时保持不变，管理员不能更改它。缺省值为 true。 ","version":"Next","tagName":"h2"},{"title":"审计日志文件事件忽略策略​","type":1,"pageTitle":"审计安全设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/auditing_settings#审计日志文件事件忽略策略","content":"以下设置影响忽略策略，这些策略支持对哪些审计事件打印到日志文件进行细粒度控制。具有相同策略名称的所有设置组合在一起形成单一策略。如果一个事件匹配任何策略的所有条件，它将被忽略并且不打印。大多数审计事件服从于忽略策略。唯一的例外是 security_config_change 类型的事件，它不能被过滤掉，除非完全排除。 xpack.security.audit.logfile.events.ignore_filters.&lt;policy_name&gt;.users (动态)用户名或通配符的列表。指定的策略将不会打印匹配这些值的用户的审计事件。 xpack.security.audit.logfile.events.ignore_filters.&lt;policy_name&gt;.realms (动态)认证领域名称或通配符的列表。指定的策略将不会为这些域中的用户打印审计事件。 xpack.security.audit.logfile.events.ignore_filters.&lt;policy_name&gt;.actions (动态)操作名或通配符的列表。操作名可以在审计事件的 action 字段中找到。指定的策略将不会为匹配这些值的操作打印审计事件。 xpack.security.audit.logfile.events.ignore_filters.&lt;policy_name&gt;.roles (动态)角色名或通配符的列表。指定的策略将不会为具有这些角色的用户打印审计事件。如果用户有多个角色，其中一些角色不在策略中覆盖，则策略将不覆盖此事件。 xpack.security.audit.logfile.events.ignore_filters.&lt;policy_name&gt;.indices (动态)索引名或通配符的列表。当事件中的所有索引都匹配这些值时，指定的策略将不打印审计事件。如果事件涉及多个索引，其中一些不在策略覆盖范围内，则策略将不覆盖此事件。 原文链接 ","version":"Next","tagName":"h2"},{"title":"矢量图块搜索 API","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#请求","content":"GET &lt;target&gt;/_mvt/&lt;field&gt;/&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt; POST &lt;target&gt;/_mvt/&lt;field&gt;/&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt; ","version":"Next","tagName":"h2"},{"title":"前置条件​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#前置条件","content":"在使用此 API 之前，你应该了解 Mapbox矢量图块规范。如果 Elasticsearch 安全特性启用，你对目标数据流、索引或别名必须有 read 索引权限。对于跨集群搜索，参阅配置跨集群搜索权限。 ","version":"Next","tagName":"h2"},{"title":"路径参数​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#路径参数","content":"&lt;target&gt;（可选，字符串）逗号分隔的用于搜索的数据流、索引和别名列表。支持通配符（）。为了在集群中搜索所有数据流和索引，忽略此参数或者使用 _all 或 ``。 为了搜索远程集群，使用语法 &lt;cluster&gt;:&lt;target&gt;。参阅跨集群搜索。 &lt;field&gt;（必需，字符串）包含要返回的地理空间值的字段。必须是 geo_point 或 geo_shape 字段。该字段必须启用文档值。不能是嵌套字段。 提示 矢量分片本身不支持几何体集合。对于字段 geo_shape 中的 geometrycollection 值，API 为集合的每个元素返回一个 hits 层特征。这种行为在未来的版本中可能会改变。 &lt;zoom&gt;（必需，整数）待搜索的矢量图块的缩放级别。接受 0-29。 &lt;x&gt;（必需，整数）待搜索的矢量图块 X 坐标。 &lt;y&gt;（必需，整数）待搜索的矢量图块 Y 坐标。 ","version":"Next","tagName":"h2"},{"title":"描述​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#描述","content":"在内部，Elasticsearch 将矢量图块搜索 API 请求转换为包含以下内容的搜索： &lt;field&gt; 上的 geo_bounding_box 查询。查询使用 &lt;zoom&gt;/&lt;x&gt;/&lt;y&gt; 块作为边界框。 &lt;field&gt; 上的 geotile_grid 或 geohex_grid 聚合。grid_agg 参数确定聚合类型。查询使用 &lt;zoom&gt;/&lt;x&gt;/&lt;y&gt; 块作为边界框。 可选的，&lt;field&gt;上 geo_bounds 聚合。如果 exact_bounds 参数为 true，则搜索仅包括此聚合。 如果 with_labels 的可选参数为 true，则内部搜索将包括一个动态运行时字段，该字段调用几何体文档值的 getLabelPosition 函数。这可以生成包含建议的几何体标签的新点特征，例如，多个多边形将只有一个标签。 例如，Elasticsearch 可以将具有 geotile 的 grid_agg 参数和为 true 的 exact_bounds 参数的向量图块搜索 API 请求转换为以下搜索： GET my-index/_search { &quot;size&quot;: 10000, &quot;query&quot;: { &quot;geo_bounding_box&quot;: { &quot;my-geo-field&quot;: { &quot;top_left&quot;: { &quot;lat&quot;: -40.979898069620134, &quot;lon&quot;: -45 }, &quot;bottom_right&quot;: { &quot;lat&quot;: -66.51326044311186, &quot;lon&quot;: 0 } } } }, &quot;aggregations&quot;: { &quot;grid&quot;: { &quot;geotile_grid&quot;: { &quot;field&quot;: &quot;my-geo-field&quot;, &quot;precision&quot;: 11, &quot;size&quot;: 65536, &quot;bounds&quot;: { &quot;top_left&quot;: { &quot;lat&quot;: -40.979898069620134, &quot;lon&quot;: -45 }, &quot;bottom_right&quot;: { &quot;lat&quot;: -66.51326044311186, &quot;lon&quot;: 0 } } } }, &quot;bounds&quot;: { &quot;geo_bounds&quot;: { &quot;field&quot;: &quot;my-geo-field&quot;, &quot;wrap_longitude&quot;: false } } } }  API 以二进制 Mapbox 矢量图块的形式返回结果。Mapbox 矢量图块编码为 Google Protobufs（PBF）。默认情况下，互动程序包含三层： 一个 hits 层，包含与 geo_bounding_box 查询匹配的每个 &lt;field&gt; 值的特征。 包含 geotile_grid 或 geohex_grid 每个单元的特征的 aggs 层。该层仅包含具有匹配数据的单元格的特征。 meta 层包含： 包含边界框的特征。默认情况下，这是块的边界框。 geotile_grid 或 geohex_grid 上任何子聚合的值范围。 搜索的元数据。 API 仅返回可以在其缩放级别显示的功能。例如，如果多边形特征在其缩放级别没有区域，则 API 会忽略它。 API 以 UTF-8 编码的 JSON 形式返回错误。 ","version":"Next","tagName":"h2"},{"title":"查询参数​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#查询参数","content":"警告 你可以将此 API 的几个选项指定为查询参数或请求体参数。如果同时指定这两个参数，则查询参数优先。 exact_bounds （可选，布尔值）如果为 false，则 meta 层的特征是块的边界框。默认为 false。 如果为 true，则 meta 层的特征是 geo_bounds 聚合产生的边界框。聚合在与 wrap_longitude 设置为 false 的 〈zoom〉/〈x〉/〈y〉 平铺相交的 &lt;field&gt; 值上运行。生成的边界框可能大于矢量图块。 extent （可选，整数）块一侧的大小（以像素为单位）。矢量平铺是等边的正方形。默认值为 4096。 buffer （可选，整数）块的外部剪切缓冲区的大小（以像素为单位）。这使得渲染器可以避免几何体中的轮廓瑕疵，这些几何体延伸到瓷砖的范围之外。默认为 5。 grid_agg （可选，字符串）用于为 &lt;field&gt; 创建网格的聚合。 grid_agg 有效值 geotile (Default) geotile_grid 聚合。 geohex geohex_grid 聚合。如果指定此值，则 &lt;field&gt; 必须是 geo_point 字段。 grid_precision （可选，整数）grid_agg 中单元格的精度级别。接受 0-8。默认为 8。如果为 0，则结果不包括 aggs 层。 geotile 网格精度 对于 geotile 的 grid_agg，可以将 aggs 层中的单元用作较低缩放级别的块。grid_precision 表示通过这些单元格可用的其他缩放级别。最终精度计算如下： &lt;zoom&gt; + grid_precision 例如，如果 &lt;zoom&gt; 为 7，grid_precision 为 8，则 geotile_grid 聚合将使用 15 的精度。最大最终精度为 29。 grid_precision 还决定了网格的单元数，如下所示： (2^grid_precision) x (2^grid_precision) 例如，值 8 将分片划分为 256 x 256 个单元格的网格。aggs 层仅包含具有匹配数据的单元格的特征。 geohex 网格精度 对于 geohex 的 grid_agg，Elasticsearch 使用 &lt;zoom&gt; 和 grid_precision 计算最终精度，如下所示： &lt;zoom&gt; + grid_precision 该精度决定了 geohex 聚集产生的六边形单元的 H3 分辨率。下表显示了每种精度的 H3 分辨率。 例如，如果 &lt;zoom&gt; 为 3，grid_precision 为 3，则精度为 6。在精度为 6 时，六边形单元格的 H3 分辨率为 2。如果 &lt;zoom&gt; 为 3，grid_precision 为 4，则精度为 7。在精度为 7 时，六边形单元格的 H3 分辨率为 3。 精度\t唯一的块箱\tH3 分辨率\t唯一的六边形箱\t比率1\t4\t0\t122\t30.5 2\t16\t0\t122\t7.625 3\t64\t1\t842\t13.15625 4\t256\t1\t842\t3.2890625 5\t1024\t2\t5882\t5.744140625 6\t4096\t2\t5882\t1.436035156 7\t16384\t3\t41162\t2.512329102 8\t65536\t3\t41162\t0.6280822754 9\t262144\t4\t288122\t1.099098206 10\t1048576\t4\t288122\t0.2747745514 11\t4194304\t5\t2016842\t0.4808526039 12\t16777216\t6\t14117882\t0.8414913416 13\t67108864\t6\t14117882\t0.2103728354 14\t268435456\t7\t98825162\t0.3681524172 15\t1073741824\t8\t691776122\t0.644266719 16\t4294967296\t8\t691776122\t0.1610666797 17\t17179869184\t9\t4842432842\t0.2818666889 18\t68719476736\t10\t33897029882\t0.4932667053 19\t274877906944\t11\t237279209162\t0.8632167343 20\t1099511627776\t11\t237279209162\t0.2158041836 21\t4398046511104\t12\t1660954464122\t0.3776573213 22\t17592186044416\t13\t11626681248842\t0.6609003122 23\t70368744177664\t13\t11626681248842\t0.165225078 24\t281474976710656\t14\t81386768741882\t0.2891438866 25\t1125899906842620\t15\t569707381193162\t0.5060018015 26\t4503599627370500\t15\t569707381193162\t0.1265004504 27\t18014398509482000\t15\t569707381193162\t0.03162511259 28\t72057594037927900\t15\t569707381193162\t0.007906278149 29\t288230376151712000\t15\t569707381193162\t0.001976569537 六边形单元格在矢量图块上没有完全对齐。某些单元格可能与多个矢量图块相交。为了计算每个精度的 H3 分辨率，Elasticsearch 将每个分辨率下六边形箱的平均密度与每个缩放级别下块箱的平均密度进行比较。Elasticsearch 使用最接近相应块密度的 H3 分辨率。 grid_type （可选，字符串）确定 aggs 层中特征的几何体类型。在 aggs 层中，每个特征代表网格中的一个单元。 grid_type 可用值 grid（默认） 每个特征都是单元几何体的多边形（Polygon）。对于 geotile 的 grid_agg，特征是单元格的边界框。对于 geohex 的 grid_agg，特征是六边形单元的边界。 point 每个特征都是一个点（Point），即单元格的质心。 centroid 每个特征都是一个点（Point），即单元内数据的质心。对于复杂几何形状，实际质心可能在单元外部。在这些情况下，特征设置为距单元内质心最近的点。 size （可选，整数）在 hits 层中返回的最大功能数。接受 0-10000。默认值为 10000。如果为 0，则结果不包括 hits 层。 track_total_hits （可选，整数或布尔值）与查询匹配以准确计数的点击数。默认值为 10000。 如果为 true，则返回准确的点击数，但会牺牲一些性能。如果为 false，则响应不包括与查询匹配的总点击数。 with_labels （可选，布尔值）如果为 true，hits 和 aggs 层将包含表示原始特征的建议标签位置的其他点特征。 Point 和 MultiPoint 特征将选择其中一个点。Polygon 和 MultiPolygon 特征将生成一个单点，即质心（如果位于多边形内），或从有序三角形树中选择的多边形内的另一个点。LineString 特征同样将提供从三角形树中选择的大致中心点。聚合结果将为每个聚合桶提供一个中心点。 原始特征的所有属性也将复制到新的标签特征。此外，使用标签 _mvt_label_position 可以区分新功能。 ","version":"Next","tagName":"h2"},{"title":"请求体​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#请求体","content":"aggs （可选，聚合对象）grid_agg 的子聚合。支持以下聚合类型： avgboxplotcardinalityextended statsmaxmedian absolute deviationminpercentilepercentile-rankstatssumvalue count 聚合名称不能以 _mvt_ 开头。_mvt_ 前缀是为内部聚合保留的。 exact_bounds （可选，布尔值）如果为 false，则 meta 层的特征是块的边界框。默认为 false。 如果为 true，则 meta 层的特征是 geo_bounds 边界聚合产生的边界框。聚合在与 wrap_longitude 设置为 false 的 〈zoom〉/〈x〉/〈y〉 平铺相交的 &lt;field&gt; 值上运行。生成的边界框可能大于矢量图块。 extent （可选，整数）块一侧的像素大小。矢量平铺是等边的正方形。默认值为 4096。 buffer （可选，整数）分幅外部剪切缓冲区的像素大小。这使得渲染器可以避免几何体中的轮廓瑕疵，延伸到块的范围之外。默认为 5。 fields （可选，字符串或对象数组）要在 hits 层中返回的字段。支持通配符（*）。 此参数不支持具有数组值的字段。具有数组值的字段可能返回不一致的结果。 可以将数组中的字段指定为字符串或对象。 fields 对象属性 field （必需，字符串）返回的字段。支持通配符（*）。 format （可选，字符串）日期和地理空间字段的格式。其他字段数据类型不支持此参数。 date 和 date_nanos 字段接受日期格式。geo_point 和 geo_shape 字段接受： geojson（默认） GeoJSON wkt Well Known Text/知名文本 mvt(&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;@&lt;extent&gt;) or mvt(&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;) 地图盒矢量块。此 API 返回的块是 base64 编码的字符串。 mvt 参数 &lt;zoom&gt; （必需，整数）块的缩放级别。支持 0-29。 &lt;x&gt; （必需，整数）块的 X 坐标。 &lt;y&gt; （必需，整数）块的 Y 坐标。 &lt;extent&gt; （可选，整数）平铺一侧的大小（以像素为单位）。矢量平铺是等边的正方形。默认为 4,096。 grid_agg （可选，字符串）用于为 &lt;field&gt; 创建网格的聚合。 grid_agg 可用值 geotile (Default) geotile_grid 聚合。 geohex geohex_grid 聚合。如果指定此值，则 &lt;field&gt; 必须是 geo_point 字段。 grid_precision （可选，整数）grid_agg 中单元格的精度级别。接受 0-8。默认为 8。如果为 0，则结果不包括 aggs 层。 geotile 网格精度 对于 geotile 的 grid_agg，可以将 aggs 层中的单元用作较低缩放级别的块。grid_precision 表示通过这些单元格可用的其他缩放级别。最终精度计算如下： &lt;zoom&gt; + grid_precision 例如，如果 &lt;zoom&gt; 为 7，grid_precision 为 8，则 geotile_grid 聚合将使用 15 的精度。最大最终精度为 29。 grid_precision 还决定了网格的单元数，如下所示： (2^grid_precision) x (2^grid_precision) 例如，值 8 将分片划分为 256 x 256 个单元格的网格。aggs 层仅包含具有匹配数据的单元格的特征。 geohex 网格精度 对于 geohex 的 grid_agg，Elasticsearch 使用 &lt;zoom&gt; 和 grid_precision 计算最终精度，如下所示： &lt;zoom&gt; + grid_precision 该精度决定了 geohex 聚集产生的六边形单元的 H3 分辨率。下表显示了每种精度的 H3 分辨率。 例如，如果 &lt;zoom&gt; 为 3，grid_precision 为 3，则精度为 6。在精度为 6 时，六边形单元格的 H3 分辨率为 2。如果 &lt;zoom&gt; 为 3，grid_precision 为 4，则精度为 7。在精度为 7 时，六边形单元格的 H3 分辨率为 3。 精度\t唯一的块箱\tH3 分辨率\t唯一的六边形箱\t比率1\t4\t0\t122\t30.5 2\t16\t0\t122\t7.625 3\t64\t1\t842\t13.15625 4\t256\t1\t842\t3.2890625 5\t1024\t2\t5882\t5.744140625 6\t4096\t2\t5882\t1.436035156 7\t16384\t3\t41162\t2.512329102 8\t65536\t3\t41162\t0.6280822754 9\t262144\t4\t288122\t1.099098206 10\t1048576\t4\t288122\t0.2747745514 11\t4194304\t5\t2016842\t0.4808526039 12\t16777216\t6\t14117882\t0.8414913416 13\t67108864\t6\t14117882\t0.2103728354 14\t268435456\t7\t98825162\t0.3681524172 15\t1073741824\t8\t691776122\t0.644266719 16\t4294967296\t8\t691776122\t0.1610666797 17\t17179869184\t9\t4842432842\t0.2818666889 18\t68719476736\t10\t33897029882\t0.4932667053 19\t274877906944\t11\t237279209162\t0.8632167343 20\t1099511627776\t11\t237279209162\t0.2158041836 21\t4398046511104\t12\t1660954464122\t0.3776573213 22\t17592186044416\t13\t11626681248842\t0.6609003122 23\t70368744177664\t13\t11626681248842\t0.165225078 24\t281474976710656\t14\t81386768741882\t0.2891438866 25\t1125899906842620\t15\t569707381193162\t0.5060018015 26\t4503599627370500\t15\t569707381193162\t0.1265004504 27\t18014398509482000\t15\t569707381193162\t0.03162511259 28\t72057594037927900\t15\t569707381193162\t0.007906278149 29\t288230376151712000\t15\t569707381193162\t0.001976569537 六边形单元格在矢量图块上没有完全对齐。某些单元格可能与多个矢量图块相交。为了计算每个精度的 H3 分辨率，Elasticsearch 将每个分辨率下六边形箱的平均密度与每个缩放级别下块箱的平均密度进行比较。Elasticsearch 使用最接近相应块密度的 H3 分辨率。 grid_type （可选，字符串）确定 aggs 层中特征的几何体类型。在 aggs 层中，每个特征代表网格中的一个单元。 grid_type 可用值 grid（默认） 每个特征都是单元几何体的多边形（Polygon）。对于 geotile 的 grid_agg，特征是单元格的边界框。对于 geohex 的 grid_agg，特征是六边形单元的边界。 point 每个特征都是一个点（Point），即单元格的质心。 centroid 每个特征都是一个点（Point），即单元内数据的质心。对于复杂几何形状，实际质心可能在单元外部。在这些情况下，特征设置为距单元内质心最近的点。 query （可选，对象）查询 DSL 对象用于搜索过滤文档。 runtime_mappings （可选，对象）在搜索请求中定义一个或多个运行时字段。这些字段优先于具有相同名称的映射字段。 runtime_mappings 对象属性 &lt;field-name&gt; （必需，对象）配置运行时字段。键（key）是字段名字。 &lt;field-name&gt; 属性 type （必需，字符串）字段类型，可以是以下任一种： boolean compositedatedoublegeo_pointipkeywordlong script （可选，字符串）查询时执行的 Plainless Script。脚本可以访问文档的整个上下文，包括原始 _source 和任何映射字段及其值。 此脚本必须包含 emit 以返回计算值。例如： &quot;script&quot;: &quot;emit(doc['@timestamp'].value.dayOfWeekEnum.toString())&quot; size （可选，整数）在 hits 层中返回的最大功能数。接受 0-10000。默认值为 10000。如果为 0，则结果不包括 hits 层。 sort （可选，排序对象数组）hits 层排序特性。 默认情况下，API 为每个特征计算边界框。它根据该框的对角线长度对特征进行排序，从最长到最短。 track_total_hits （可选，整数或布尔值）与查询匹配以准确计数的点击数。默认值为 10000。 如果为 true，则返回准确的点击数，但会牺牲一些性能。如果为 false，则响应不包括与查询匹配的总点击数。 with_labels （可选，布尔值）如果为 true，hits 和 aggs 层将包含表示原始特征的建议标签位置的其他点特征。 Point 和 MultiPoint 特征将选择其中一个点。Polygon 和 MultiPolygon 特征将生成一个单点，即质心（如果位于多边形内），或从有序三角形树中选择的多边形内的另一个点。LineString 特征同样将提供从三角形树中选择的大致中心点。聚合结果将为每个聚合桶提供一个中心点。 原始特征的所有属性也将复制到新的标签特征。此外，使用标签 _mvt_label_position 可以区分新功能。 ","version":"Next","tagName":"h2"},{"title":"响应​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#响应","content":"返回的矢量图块包含以下数据： hits （对象）层包含 geo_bounding_box 查询结果。 hits 属性 extent （可选，整数）块一侧的大小（以像素为单位）。矢量平铺是等边的正方形。 version （整数）Mapbox 矢量图块规范的主要版本号。 features （对象数组）特性数组。包含与 geo_bounding_box 查询匹配的每个 &lt;field&gt; 值的特征。 features 对象属性 geometry （对象）特性的几何图形。 geometry 属性 type （字符串）特征的几何图形类型。可用值为： UNKNOWNPOINTLINESTRINGPOLYGON coordinates （整数数组或二重数组）特性的坐标。 properties （对象）特性的属性。 properties 属性 _id （字符串）特性文档的文档 _id。 _index （字符串）特性文档的索引名字。 &lt;field&gt; 字段值。仅返回 fields 参数的字段。 type （整数）特性几何体类型的标识符。数值为： 1(POINT)2(LINESTRING)3(POLYGON) aggs （对象）包含 grid_agg 聚合及其子聚合结果的层。 aggs 属性 extent （可选，整数）块一侧的大小（以像素为单位）。矢量平铺是等边的正方形。 version （整数）Mapbox 矢量图块规范的主要版本号。 features （对象数组）特性数组。包含与 geo_bounding_box 查询匹配的每个 &lt;field&gt; 值的特征。 features 对象属性 geometry （对象）特性的几何图形。 geometry 属性 type （字符串）特征的几何图形类型。可用值为： UNKNOWNPOINTLINESTRINGPOLYGON coordinates （整数数组或二重数组）特性的坐标。 properties （对象）特性的属性。 properties 属性 _count （长整型）单元格文档的计数。 _key （字符串）单元格的桶（Bucket）键，格式为 &lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;。 &lt;sub-aggregation&gt;.value 单元格的子聚集结果。仅针对 aggs 参数中的子聚合返回。 type （整数）特性几何体类型的标识符。数值为： 1(POINT)2(LINESTRING)3(POLYGON) meta （对象）包含请求元数据的层。 meta 属性 extent （可选，整数）块一侧的大小（以像素为单位）。矢量平铺是等边的正方形。 version （整数）Mapbox 矢量图块规范的主要版本号。 features （对象数组）特性数组。包含与 geo_bounding_box 查询匹配的每个 &lt;field&gt; 值的特征。 features 对象属性 geometry （对象）特性的几何图形。 geometry 属性 type （字符串）特征的几何图形类型。可用值为： UNKNOWNPOINTLINESTRINGPOLYGON coordinates （整数数组或二重数组）特性的坐标。 properties （对象）特性的属性。 properties 属性 _shards.failed （整数）无法执行搜索的分片数。参阅搜索 API 的 shards 响应属性。 _shards.skipped （整数）跳过搜索的分片数。参阅搜索 API 的 shards 响应属性。 _shards.successful （整数）成功执行搜索的分片数。参阅搜索 API 的 shards 响应属性。 _shards.total （整数）需要查询的分片总数，包括未分配的分片。参阅搜索 API 的 shards 响应属性。 aggregations._count.avg （浮点数）aggs 层中特性的平均 _count 值。 aggregations._count.count （整数）aggs 层中特性的唯一 _count 值的数量。 aggregations._count.max （浮点数）aggs 层特性的最大 _count 值。 aggregations._count.min （浮点数）aggs 层特性的最小 _count 值。 aggregations._count.sum （浮点数）aggs 层特性的合计 _count 值。 aggregations.&lt;sub-aggregation&gt;.avg （浮点数）子聚合结果的平均值。 aggregations.&lt;agg_name&gt;.count （整数）子聚合结果中的唯一值的数量。 aggregations.&lt;agg_name&gt;.max （浮点数）子聚合结果中的最大值。 aggregations.&lt;agg_name&gt;.min （浮点数）子聚合结果中的最小值。 aggregations.&lt;agg_name&gt;.sum （浮点数）子聚合结果中的合计值。 hits.max_score （浮点数）搜索结果的最高文档 _score。 hits.total.relation （字符串）指示是否 hits.total.value 是准确的或下限。可能的值为： eq 准确值 gte 下限值 hits.total.value （整数）搜索命中的总数。 timed_out （布尔值）如果为 true，则搜索在完成之前超时。结果可能部分或为空。 took （整数）Elasticsearch 运行搜索所需毫秒。参阅搜索 API 的 took 响应属性。 type （整数）特性几何体类型的标识符。数值为： 1(POINT)2(LINESTRING)3(POLYGON) ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"矢量图块搜索 API","url":"/docs/elasticsearch-cn/rest_apis/search_apis/vector_tile_search#示例","content":"以下请求创建索引 museum 并添加几个地理空间 location 值。 PUT museums { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;location&quot;: { &quot;type&quot;: &quot;geo_point&quot; }, &quot;name&quot;: { &quot;type&quot;: &quot;keyword&quot; }, &quot;price&quot;: { &quot;type&quot;: &quot;long&quot; }, &quot;included&quot;: { &quot;type&quot;: &quot;boolean&quot; } } } } POST museums/_bulk?refresh { &quot;index&quot;: { &quot;_id&quot;: &quot;1&quot; } } { &quot;location&quot;: &quot;POINT (4.912350 52.374081)&quot;, &quot;name&quot;: &quot;NEMO Science Museum&quot;, &quot;price&quot;: 1750, &quot;included&quot;: true } { &quot;index&quot;: { &quot;_id&quot;: &quot;2&quot; } } { &quot;location&quot;: &quot;POINT (4.901618 52.369219)&quot;, &quot;name&quot;: &quot;Museum Het Rembrandthuis&quot;, &quot;price&quot;: 1500, &quot;included&quot;: false } { &quot;index&quot;: { &quot;_id&quot;: &quot;3&quot; } } { &quot;location&quot;: &quot;POINT (4.914722 52.371667)&quot;, &quot;name&quot;: &quot;Nederlands Scheepvaartmuseum&quot;, &quot;price&quot;:1650, &quot;included&quot;: true } { &quot;index&quot;: { &quot;_id&quot;: &quot;4&quot; } } { &quot;location&quot;: &quot;POINT (4.914722 52.371667)&quot;, &quot;name&quot;: &quot;Amsterdam Centre for Architecture&quot;, &quot;price&quot;:0, &quot;included&quot;: true }  以下请求在索引中搜索与 13/4207/2692 矢量图块相交的位置值。 GET museums/_mvt/location/13/4207/2692 { &quot;grid_agg&quot;: &quot;geotile&quot;, &quot;grid_precision&quot;: 2, &quot;fields&quot;: [ &quot;name&quot;, &quot;price&quot; ], &quot;query&quot;: { &quot;term&quot;: { &quot;included&quot;: true } }, &quot;aggs&quot;: { &quot;min_price&quot;: { &quot;min&quot;: { &quot;field&quot;: &quot;price&quot; } }, &quot;max_price&quot;: { &quot;max&quot;: { &quot;field&quot;: &quot;price&quot; } }, &quot;avg_price&quot;: { &quot;avg&quot;: { &quot;field&quot;: &quot;price&quot; } } } }  API 以二进制向量分片的形式返回结果。当解码为 JSON 时，块包含以下数据： { &quot;hits&quot;: { &quot;extent&quot;: 4096, &quot;version&quot;: 2, &quot;features&quot;: [ { &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [ 3208, 3864 ] }, &quot;properties&quot;: { &quot;_id&quot;: &quot;1&quot;, &quot;_index&quot;: &quot;museums&quot;, &quot;name&quot;: &quot;NEMO Science Museum&quot;, &quot;price&quot;: 1750 }, &quot;type&quot;: 1 }, { &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [ 3429, 3496 ] }, &quot;properties&quot;: { &quot;_id&quot;: &quot;3&quot;, &quot;_index&quot;: &quot;museums&quot;, &quot;name&quot;: &quot;Nederlands Scheepvaartmuseum&quot;, &quot;price&quot;: 1650 }, &quot;type&quot;: 1 }, { &quot;geometry&quot;: { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [ 3429, 3496 ] }, &quot;properties&quot;: { &quot;_id&quot;: &quot;4&quot;, &quot;_index&quot;: &quot;museums&quot;, &quot;name&quot;: &quot;Amsterdam Centre for Architecture&quot;, &quot;price&quot;: 0 }, &quot;type&quot;: 1 } ] }, &quot;aggs&quot;: { &quot;extent&quot;: 4096, &quot;version&quot;: 2, &quot;features&quot;: [ { &quot;geometry&quot;: { &quot;type&quot;: &quot;Polygon&quot;, &quot;coordinates&quot;: [ [ [ 3072, 3072 ], [ 4096, 3072 ], [ 4096, 4096 ], [ 3072, 4096 ], [ 3072, 3072 ] ] ] }, &quot;properties&quot;: { &quot;_count&quot;: 3, &quot;max_price.value&quot;: 1750.0, &quot;min_price.value&quot;: 0.0, &quot;avg_price.value&quot;: 1133.3333333333333 }, &quot;type&quot;: 3 } ] }, &quot;meta&quot;: { &quot;extent&quot;: 4096, &quot;version&quot;: 2, &quot;features&quot;: [ { &quot;geometry&quot;: { &quot;type&quot;: &quot;Polygon&quot;, &quot;coordinates&quot;: [ [ [ 0, 0 ], [ 4096, 0 ], [ 4096, 4096 ], [ 0, 4096 ], [ 0, 0 ] ] ] }, &quot;properties&quot;: { &quot;_shards.failed&quot;: 0, &quot;_shards.skipped&quot;: 0, &quot;_shards.successful&quot;: 1, &quot;_shards.total&quot;: 1, &quot;aggregations._count.avg&quot;: 3.0, &quot;aggregations._count.count&quot;: 1, &quot;aggregations._count.max&quot;: 3.0, &quot;aggregations._count.min&quot;: 3.0, &quot;aggregations._count.sum&quot;: 3.0, &quot;aggregations.avg_price.avg&quot;: 1133.3333333333333, &quot;aggregations.avg_price.count&quot;: 1, &quot;aggregations.avg_price.max&quot;: 1133.3333333333333, &quot;aggregations.avg_price.min&quot;: 1133.3333333333333, &quot;aggregations.avg_price.sum&quot;: 1133.3333333333333, &quot;aggregations.max_price.avg&quot;: 1750.0, &quot;aggregations.max_price.count&quot;: 1, &quot;aggregations.max_price.max&quot;: 1750.0, &quot;aggregations.max_price.min&quot;: 1750.0, &quot;aggregations.max_price.sum&quot;: 1750.0, &quot;aggregations.min_price.avg&quot;: 0.0, &quot;aggregations.min_price.count&quot;: 1, &quot;aggregations.min_price.max&quot;: 0.0, &quot;aggregations.min_price.min&quot;: 0.0, &quot;aggregations.min_price.sum&quot;: 0.0, &quot;hits.max_score&quot;: 0.0, &quot;hits.total.relation&quot;: &quot;eq&quot;, &quot;hits.total.value&quot;: 3, &quot;timed_out&quot;: false, &quot;took&quot;: 2 }, &quot;type&quot;: 3 } ] } }  原文链接 ","version":"Next","tagName":"h2"},{"title":"建议器","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"请求​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#请求","content":"建议功能通过使用建议器，基于提供的文本建议类似的词语。建议请求部分与 _search 请求中的查询部分一起定义。如果省略了查询部分，则只返回建议。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#示例","content":"每个请求可以指定多个建议。每个建议都有一个任意的名称。在下面的例子中，需要两条建议。my-suggest-1 和 my-suggest-2 建议都使用 term 建议器，但不同于 text。 POST _search { &quot;suggest&quot;: { &quot;my-suggest-1&quot; : { &quot;text&quot; : &quot;tring out Elasticsearch&quot;, &quot;term&quot; : { &quot;field&quot; : &quot;message&quot; } }, &quot;my-suggest-2&quot; : { &quot;text&quot; : &quot;kmichy&quot;, &quot;term&quot; : { &quot;field&quot; : &quot;user.id&quot; } } } }  下面的建议响应示例包括 my-suggest-1 和 my-suggest-2 的建议响应。每个建议部分都包含条目。每个条目实际上是建议文本中的一个标记，包含建议条目文本、建议文本中的原始起始偏移量和长度，如果找到，还包含任意数量的选项。 { &quot;_shards&quot;: ... &quot;hits&quot;: ... &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;suggest&quot;: { &quot;my-suggest-1&quot;: [ { &quot;text&quot;: &quot;tring&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 5, &quot;options&quot;: [ {&quot;text&quot;: &quot;trying&quot;, &quot;score&quot;: 0.8, &quot;freq&quot;: 1 } ] }, { &quot;text&quot;: &quot;out&quot;, &quot;offset&quot;: 6, &quot;length&quot;: 3, &quot;options&quot;: [] }, { &quot;text&quot;: &quot;elasticsearch&quot;, &quot;offset&quot;: 10, &quot;length&quot;: 13, &quot;options&quot;: [] } ], &quot;my-suggest-2&quot;: ... } }  每个选项数组都包含一个选项对象，其中包括建议文本、其文档频率以及与建议条目文本相比的分数。分数的意义取决于所用的建议词。术语建议者的分数基于编辑距离。 ","version":"Next","tagName":"h2"},{"title":"全局建议文本​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#全局建议文本","content":"为了避免重复建议文本，可以定义一个全局文本。在下面的示例中，建议文本是全局定义的，适用于 my-suggest-1 和 my-suggest-2 建议。 POST _search { &quot;suggest&quot;: { &quot;text&quot; : &quot;tring out Elasticsearch&quot;, &quot;my-suggest-1&quot; : { &quot;term&quot; : { &quot;field&quot; : &quot;message&quot; } }, &quot;my-suggest-2&quot; : { &quot;term&quot; : { &quot;field&quot; : &quot;user&quot; } } } }  上述示例中的建议文本也可以指定为建议特定选项。建议级别上指定的建议文本将覆盖全局级别上的建议文本。 ","version":"Next","tagName":"h2"},{"title":"词语建议器​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#词语建议器","content":"term 建议器根据编辑距离建议词语。在建议词语之前，先分析所提供的建议文本。建议条款根据分析的建议文本标记提供。term 建议器不考虑作为请求一部分的查询。 ","version":"Next","tagName":"h2"},{"title":"常见建议选项​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#常见建议选项","content":"\ttext\t建议文本。建议文本是一个必需选项，需要在全局范围内或根据建议进行设置。 field\t获取候选人建议的字段。这是一个必需的选项，需要在全局范围内或根据建议进行设置。 analyzer\t分析人员用以分析建议文本。默认为“建议”字段的搜索分析器。 size\t每个建议文本标记返回的最大更正。 sort\t定义每个建议文本项的建议排序方式。两个可能的值：score：首先按分数排序，然后记录频率，然后是术语本身。frequency：首先按文档频率排序，然后按相似度得分排序，然后按词语本身排序。 suggest_mode\t建议模式控制包含哪些建议，或控制建议文本的内容、建议应被建议。可以指定三个可能的值：missing：仅为索引中没有的建议文本词语提供建议。这是默认设置。popular：仅建议出现在比原始建议文本词更多文档中的建议。always：根据建议文本中的词语提出任何匹配建议。 ","version":"Next","tagName":"h3"},{"title":"其他词语建议选项​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#其他词语建议选项","content":"\tmax_edits\t候选建议可以具有的最大编辑距离可以被视为建议。只能是介于 1 和 2 之间的值。任何其他值都会导致抛出错误的请求错误。默认值为 2。 prefix_length\t必须匹配的最小前缀字符数，才能作为建议的候选字符。默认值为 1。增加这个数字可以提高拼写检查性能。通常拼写错误不会发生在词语开头。 min_word_length\t建议文本词语必须包含的最小长度。默认为 4。 shard_size\t要从每个建议集检索的最大建议数。在收缩（reduce）阶段，根据 size 选项只返回前 N 个建议。默认为 size 选项。为了以性能为代价获得更准确的拼写更正文档频率，将该值设置为大于 size 值会很有用。由于词语是在分片之间划分的，分片级别的文档拼写更正频率可能不精确。增加该值将使这些文档频率更精确。 max_inspections\t一个用于与 shards_size 相乘的因子，以便在分片级别检查更多候选拼写更正。可以以牺牲性能为代价提高准确性。默认为 5。 min_doc_freq\t建议应出现在其中的文档数的最小阈值。这可以指定为绝对数，也可以指定为文档数的相对百分比。这可以通过建议高频项来提高质量。默认为 0f 且未启用。如果指定的值大于 1，则该数字不能是小数。分片级别的文档频率用于此选项。 max_term_freq\t建议文本标记可以存在以包含在其中的文档数的最大阈值。可以是相对百分比（例如，0.4）或绝对数来表示文档频率。如果指定的值大于1，则不能指定分数。默认值为 0.01f。这可用于排除高频项——通常拼写正确的——避免被拼写检查。这也提高了拼写检查的性能。分片级别的文档频率用于此选项。 string_distance\t使用哪个字符串距离实现来比较建议术语的相似程度。可以指定五个可能的值：internal：默认值基于damerau_levenshtein，但经过高度优化，用于比较索引内术语的字符串距离。damerau_levenshtein：基于 damerau levenshtein 算法的字符串距离算法。levenshtein：基于 levenshtein 编辑距离算法的字符串距离算法。jaro_winkler：基于 jaro winkler 算法的字符串距离算法。ngram：基于字符 n-grams 的字符串距离算法。 ","version":"Next","tagName":"h3"},{"title":"短语建议器​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#短语建议器","content":"term 建议器提供了一个非常方便的 API，可以在一定的字符串距离内以每个标记为基础访问单词替代项。API 允许单独访问流中的每个令牌，而建议选择留给 API 使用者。然而，通常需要预先选择的建议才能呈现给最终用户。phrase 建议器在 term 建议器的基础上添加了额外的逻辑，以选择完整的已更正短语，而不是基于 ngram-language 模型加权的单个标记。在实践中，这个建议器将能够根据共现和频率更好地决定选择哪些记号。 ","version":"Next","tagName":"h2"},{"title":"API 示例​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#api-示例","content":"一般来说，phrase 建议器需要在工作前进行特殊映射。本页上的 phrase 提示示例需要以下映射才能工作。reverse 分析器仅在最后一个示例中使用。 PUT test { &quot;settings&quot;: { &quot;index&quot;: { &quot;number_of_shards&quot;: 1, &quot;analysis&quot;: { &quot;analyzer&quot;: { &quot;trigram&quot;: { &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;standard&quot;, &quot;filter&quot;: [&quot;lowercase&quot;,&quot;shingle&quot;] }, &quot;reverse&quot;: { &quot;type&quot;: &quot;custom&quot;, &quot;tokenizer&quot;: &quot;standard&quot;, &quot;filter&quot;: [&quot;lowercase&quot;,&quot;reverse&quot;] } }, &quot;filter&quot;: { &quot;shingle&quot;: { &quot;type&quot;: &quot;shingle&quot;, &quot;min_shingle_size&quot;: 2, &quot;max_shingle_size&quot;: 3 } } } } }, &quot;mappings&quot;: { &quot;properties&quot;: { &quot;title&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: { &quot;trigram&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;trigram&quot; }, &quot;reverse&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;reverse&quot; } } } } } } POST test/_doc?refresh=true {&quot;title&quot;: &quot;noble warriors&quot;} POST test/_doc?refresh=true {&quot;title&quot;: &quot;nobel prize&quot;}  一旦设置了分析器和映射，就可以在使用 term 建议器的同一位置使用 phrase 建议器： POST test/_search { &quot;suggest&quot;: { &quot;text&quot;: &quot;noble prize&quot;, &quot;simple_phrase&quot;: { &quot;phrase&quot;: { &quot;field&quot;: &quot;title.trigram&quot;, &quot;size&quot;: 1, &quot;gram_size&quot;: 3, &quot;direct_generator&quot;: [ { &quot;field&quot;: &quot;title.trigram&quot;, &quot;suggest_mode&quot;: &quot;always&quot; } ], &quot;highlight&quot;: { &quot;pre_tag&quot;: &quot;&lt;em&gt;&quot;, &quot;post_tag&quot;: &quot;&lt;/em&gt;&quot; } } } } }  回复中包含的建议由最有可能的拼写更正者首先评分。在这种情况下，我们收到了预期的更正“nobel prize”。 { &quot;_shards&quot;: ... &quot;hits&quot;: ... &quot;timed_out&quot;: false, &quot;took&quot;: 3, &quot;suggest&quot;: { &quot;simple_phrase&quot; : [ { &quot;text&quot; : &quot;noble prize&quot;, &quot;offset&quot; : 0, &quot;length&quot; : 11, &quot;options&quot; : [ { &quot;text&quot; : &quot;nobel prize&quot;, &quot;highlighted&quot;: &quot;&lt;em&gt;nobel&lt;/em&gt; prize&quot;, &quot;score&quot; : 0.48614594 }] } ] } }  ","version":"Next","tagName":"h3"},{"title":"基本短语建议 API 参数​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#基本短语建议-api-参数","content":"\tfield\t用于对语言模型进行 n-gram 查找的字段的名称，建议者将使用此字段获取统计信息以对更正进行评分。此字段为必填字段。 gram_size\t设置 field 中 n-grams（shingle）的最大大小。如果该字段不包含 n-grams（shingle），则应忽略该字段或将其设置为 1。请注意，Elasticsearch 尝试根据指定 field 检测 gram 大小。如果该字段使用 shingle 过滤器，如果未明确设置，则将 gram_size 设置为 max_shingle_size。 real_word_error_likelihood\t即使词典中存在某个词语，该词语拼写错误的可能性。默认值为 0.95，这意味着 5% 的真实单词拼写错误。 confidence\t置信度定义了一个应用于输入短语得分的因子，该因子用作其他推荐候选词的阈值。只有得分高于阈值的候选人才会被纳入结果。例如，置信度为 1.0 只会返回得分高于输入短语的建议。如果设置为 0.0，则返回前 N 名候选项。默认值为 1.0。 max_errors\t为了形成更正，被认为拼写错误的术语的最大百分比。此方法接受范围内的浮点值 [0..1）作为实际查询词的一小部分，或一个 &gt;=1 的数字作为查询词的绝对数。默认值设置为 1.0，这意味着只返回最多一个拼写错误的词的更正。请注意，设置得太高可能会对性能产生负面影响。建议使用 1 或 2 这样的小值，否则将花费时间在建议调用中可能超过查询执行所花费的时间。 separator\t用于分隔双字符字段中的术语的分隔符。如果未设置，则空格字符用作分隔符。 size\t为每个查询项生成的候选项数。3 或 5 这样的小数字通常会产生好的结果。提高这个值可以带来编辑距离更大的术语。默认值为 5。 analyzer\t将要分析的分析器设置为使用建议文本。默认为通过 field 传递的建议字段的搜索分析器。 shard_size\t设置从每个碎片中检索的建议术语的最大数量。在收缩（reduce）阶段，根据 size 选项只返回前 N 个建议。默认值为 5。 text\t设置要为其提供建议的文本/查询。 highlight\t设置建议高亮。如果未提供，则不会返回 highlighted 字段。如果提供，则必须准确地包含 pre_tag 和 post_tag，这两个包裹在已更改的标记（token）周围。如果一行中有多个标记被更改，那么更改的标记的整个短语将被包装，而不是每个标记。 collate\t根据指定的 query 检查每个建议，以删除索引中不存在匹配文档的建议。建议的collate查询仅在从中生成建议的本地分片上运行。必须指定 query，并且可以对其进行模板化。参阅搜索模板。当前建议将自动作为 {{suggestion}} 变量提供，该变量应在查询中使用。你仍然可以指定自己的模板 params — suggestion 值将添加到你指定的变量中。此外，你可以指定一个 prune 来控制是否返回所有短语建议；当设置为 true 时，建议将有一个附加选项 collate_match，如果找到匹配短语的文档，则该选项为 true，否则为 false。prune 的默认值为 false。 POST test/_search { &quot;suggest&quot;: { &quot;text&quot; : &quot;noble prize&quot;, &quot;simple_phrase&quot; : { &quot;phrase&quot; : { &quot;field&quot; : &quot;title.trigram&quot;, &quot;size&quot; : 1, &quot;direct_generator&quot; : [ { &quot;field&quot; : &quot;title.trigram&quot;, &quot;suggest_mode&quot; : &quot;always&quot;, &quot;min_word_length&quot; : 1 } ], &quot;collate&quot;: { &quot;query&quot;: { &quot;source&quot; : { &quot;match&quot;: { &quot;{{field_name}}&quot; : &quot;{{suggestion}}&quot; } } }, &quot;params&quot;: {&quot;field_name&quot; : &quot;title&quot;}, &quot;prune&quot;: true } } } } }  &quot;query&quot;：此查询将针对每个建议运行一次。&quot;{{field_name}}&quot; : &quot;{{suggestion}}&quot;：{{suggestion}} 变量将被每个建议的文本替换。&quot;params&quot;: {&quot;field_name&quot; : &quot;title&quot;}：params 中指定了一个额外的 field_name 变量，用于 match 查询。&quot;prune&quot;: true：所有建议都将返回一个额外的 collate_match 选项，指示生成的短语是否与任何文档匹配。 ","version":"Next","tagName":"h3"},{"title":"平滑模型​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#平滑模型","content":"phrase 建议器支持多个平滑模型来平衡不频繁的 grams（grams（shingles）在索引中不存在）和频繁 grams（在索引中至少出现一次）之间的权重。通过将 smoothing 参数设置为以下选项之一，可以选择平滑模型。每个平滑模型都支持可以配置的特定属性。 \tstupid_backoff\t一个简单的退避模型，如果高阶计数为 0，则退避到低阶 n-gram 模型，并通过常数因子对低阶 n-gram 模型进行低估。默认折扣为 0.4Stupid Backoff 是默认模式。 laplace\t一种使用加法平滑的平滑模型，其中向所有计数添加一个常数（通常为 1.0 或更小）以平衡权重。默认 alpha 为 0.5。 linear_interpolation\t一种平滑模型，根据用户提供的权重（lambdas），对单图、双图和三联图进行加权平均。线性插值没有任何默认值。必须提供所有参数（trigram_lambda、bigram_lambda、unigram_lambda）。 POST test/_search { &quot;suggest&quot;: { &quot;text&quot; : &quot;obel prize&quot;, &quot;simple_phrase&quot; : { &quot;phrase&quot; : { &quot;field&quot; : &quot;title.trigram&quot;, &quot;size&quot; : 1, &quot;smoothing&quot; : { &quot;laplace&quot; : { &quot;alpha&quot; : 0.7 } } } } } }  ","version":"Next","tagName":"h3"},{"title":"候选生成器​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#候选生成器","content":"phrase 建议器使用候选生成器生成给定文本中每个词语的可能词语列表。单个候选生成器类似于为文本中的每个词语调用的 term 建议器。生成器的输出随后与建议候选项的其他词语中的候选项一起评分。 目前只支持一种类型的候选生成器，即 direct_generator。短语建议 API 接受键 direct_generator 下的生成器列表；在原始文本中，列表中的每个生成器都是按词语调用的。 ","version":"Next","tagName":"h3"},{"title":"直接生成器​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#直接生成器","content":"直接生成器支持以下参数： \tfield\t获取候选建议的字段。这是一个必需的选项，需要在全局范围内或根据建议进行设置。 size\t每个建议文本标记返回的最大更正。 suggest_mode\t建议模式控制在每个碎片上生成的建议中包含哪些建议。除了 always 之外的所有值都可以被认为是一种优化，以在每个分片上生成较少的建议进行测试，并且在组合在每个碎片上生成的建议时不会重新检查。因此，missing 将为不包含它们的分片上的术语生成建议，即使其他分片确实包含它们。这些应该用 confidence 过滤掉。可以指定三个可能的值：missing：仅为不在碎片中的术语生成建议。这是默认设置。popular：只建议出现在比原始术语更多的文档中的术语。always：根据建议文本中的术语提出任何匹配建议。 max_edits\t候选建议可以具有的最大编辑距离可以被视为建议。只能是介于 1 和 2 之间的值。任何其他值都会导致抛出错误的请求错误。默认值为 2。 prefix_length\t必须匹配的最小前缀字符数才能成为候选字符。默认值为 1。增加这个数字可以提高拼写检查性能。通常拼写错误不会发生在词语开始时。 min_word_length\t建议文本词语必须包含的最小长度。默认为 4。 max_inspections\t一个用于与碎片大小相乘的因子，以便在碎片级别检查更多候选拼写更正。可以以牺牲性能为代价提高准确性。默认值为5。 min_doc_freq\t建议应出现在其中的文档数的最小阈值。这可以指定为绝对数，也可以指定为文档数的相对百分比。这可以通过建议高频项来提高质量。默认为 0f 且未启用。如果指定的值大于 1，则该数字不能是小数。分片级别的文档频率用于此选项。 max_term_freq\t建议文本标记可以存在以包含在其中的文档数的最大阈值。可以是相对百分比（例如，0.4）或绝对数来表示文档频率。如果指定的值大于1，则不能指定分数。默认值为 0.01f。这可用于排除高频项——通常拼写正确——避免被拼写检查。这也提高了拼写检查的性能。分片级别的文档频率用于此选项。 pre_filter\t应用于传递到此候选生成器的每个标识的筛选器（分析器）。在生成候选标识之前，此筛选器将应用于原始标识。 post_filter\t一个过滤器（分析器），在传递给实际短语记分器之前应用于每个生成的标记。 下面的示例显示了一个带有两个生成器的短语建议调用：第一个使用包含普通索引项的字段，第二个使用使用反向过滤器索引的项的字段（标记按反向顺序索引）。这是用来克服直接生成器需要恒定前缀以提供高性能建议的限制。pre_filter 和 post_filter 选项接受普通的分析器名称。 POST test/_search { &quot;suggest&quot;: { &quot;text&quot; : &quot;obel prize&quot;, &quot;simple_phrase&quot; : { &quot;phrase&quot; : { &quot;field&quot; : &quot;title.trigram&quot;, &quot;size&quot; : 1, &quot;direct_generator&quot; : [ { &quot;field&quot; : &quot;title.trigram&quot;, &quot;suggest_mode&quot; : &quot;always&quot; }, { &quot;field&quot; : &quot;title.reverse&quot;, &quot;suggest_mode&quot; : &quot;always&quot;, &quot;pre_filter&quot; : &quot;reverse&quot;, &quot;post_filter&quot; : &quot;reverse&quot; } ] } } } }  pre_filter 和 post_filter 也可用于在生成候选词后注入同义词。例如，对于 captain usq 查询，我们可能会为词语 usq 生成一个候选 usa，usq 是 america 的同义词。如果这个短语得分足够高，我们就可以向用户展示 captain america。 ","version":"Next","tagName":"h3"},{"title":"完成建议器​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#完成建议器","content":"completion 建议器提供键入时自动完成/搜索功能。这是一种导航功能，可以在用户键入相关结果时引导用户，从而提高搜索精度。它不是为了拼写纠正，或者你指的是像 term 或 phrase 提示器这样的功能。 理想情况下，自动完成功能应该与用户键入的内容一样快，以提供与用户已键入内容相关的即时反馈。因此，completion 建议器针对速度进行了优化。建议器使用能够快速查找的数据结构，但构建成本很高，且存储在内存中。 ","version":"Next","tagName":"h2"},{"title":"映射​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#映射","content":"要使用此功能，请为此字段指定一个特殊映射，该映射为字段值建立索引，以便快速完成。 PUT music { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;suggest&quot;: { &quot;type&quot;: &quot;completion&quot; }, &quot;title&quot;: { &quot;type&quot;: &quot;keyword&quot; } } } }  映射支持以下参数： \tanalyzer\t将使用的索引分析器，默认为 simple。 search_analyzer\t将使用的搜索分析器，默认值为 analyzer。 preserve_separators\t保留分隔符，默认为 true。如果禁用，假如你建议使用 foof，你可能会找到一个以 Foo Fighters 开头的字段。 preserve_position_increments\t启用位置增量，默认为 true。如果禁用并使用 stopwords analyzer，你可以得到一个以 The Beatles 开始的字段，如果你建议使用 b。注意：你也可以通过索引两个输入，Beatles 和 The Beatles 来实现这一点，如果你能够丰富你的数据，无需更改一个简单的分析器。 max_input_length\t限制单个输入的长度，默认为 50 个UTF-16代码点。此限制仅在索引时用于减少每个输入字符串的字符总数，以防止大量输入导致底层数据结构膨胀。大多数用例不会受到默认值的影响，因为前缀补全很少超出前缀长度超过少数字符。 ","version":"Next","tagName":"h3"},{"title":"索引​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#索引","content":"你可以像其他领域一样索引建议。建议由输入和可选的权重属性组成。输入是建议查询所匹配的预期文本，权重决定建议的评分方式。建议如下： PUT music/_doc/1?refresh { &quot;suggest&quot; : { &quot;input&quot;: [ &quot;Nevermind&quot;, &quot;Nirvana&quot; ], &quot;weight&quot; : 34 } }  支持以下参数： \tinput\t要存储的输入，可以是字符串数组，也可以只是字符串。此字段为必填字段。注意 此值不能包含以下UTF-16控制字符：\\u0000（空） \\u001f（信息分隔符一） \\u001e（信息分隔符二） weight\t一个正整数或一个包含正整数的字符串，用于定义权重并允许你对建议进行排序。此字段是可选的。 你可以为一个文档的多个建议编制索引，如下所示： PUT music/_doc/1?refresh { &quot;suggest&quot;: [ { &quot;input&quot;: &quot;Nevermind&quot;, &quot;weight&quot;: 10 }, { &quot;input&quot;: &quot;Nirvana&quot;, &quot;weight&quot;: 3 } ] }  你可以使用下面的速记形式。请注意，你不能以速记形式指定带有建议的权重。 PUT music/_doc/1?refresh { &quot;suggest&quot; : [ &quot;Nevermind&quot;, &quot;Nirvana&quot; ] }  ","version":"Next","tagName":"h3"},{"title":"查询​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#查询","content":"POST music/_search?pretty { &quot;suggest&quot;: { &quot;song-suggest&quot;: { &quot;prefix&quot;: &quot;nir&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot; } } } }  &quot;prefix&quot;: &quot;nir&quot;：用于搜索建议的前缀&quot;completion&quot;：建议类型&quot;field&quot;: &quot;suggest&quot; ：在其中搜索建议的字段名称 返回以下响应： { &quot;_shards&quot; : { &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 }, &quot;hits&quot;: ... &quot;took&quot;: 2, &quot;timed_out&quot;: false, &quot;suggest&quot;: { &quot;song-suggest&quot; : [ { &quot;text&quot; : &quot;nir&quot;, &quot;offset&quot; : 0, &quot;length&quot; : 3, &quot;options&quot; : [ { &quot;text&quot; : &quot;Nirvana&quot;, &quot;_index&quot;: &quot;music&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1.0, &quot;_source&quot;: { &quot;suggest&quot;: [&quot;Nevermind&quot;, &quot;Nirvana&quot;] } } ] } ] } }  警告 _source 源元数据字段必须启用（这是默认行为），才能使用建议返回 _source。 建议的配置权重作为 _source 返回。text 字段使用索引建议的 input。默认情况下，建议返回完整的文档 _source。由于磁盘提取和网络传输开销，_source 的大小可能会影响性能。为了节省一些网络开销，请使用源过滤从 _source 中筛选出不必要的字段，以最小化 _source 的大小。请注意 _suggest 端点不支持源过滤，但在 _search 端点上可以使用建议： POST music/_search { &quot;_source&quot;: &quot;suggest&quot;, &quot;suggest&quot;: { &quot;song-suggest&quot;: { &quot;prefix&quot;: &quot;nir&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;size&quot;: 5 } } } }  &quot;_source&quot;: &quot;suggest&quot;：过滤源以仅返回 suggest 字段&quot;field&quot;: &quot;suggest&quot;：要在其中搜索建议的字段的名称&quot;size&quot;: 5：要返回的建议数 结果类似如下： { &quot;took&quot;: 6, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: { &quot;value&quot;: 0, &quot;relation&quot;: &quot;eq&quot; }, &quot;max_score&quot;: null, &quot;hits&quot;: [] }, &quot;suggest&quot;: { &quot;song-suggest&quot;: [ { &quot;text&quot;: &quot;nir&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 3, &quot;options&quot;: [ { &quot;text&quot;: &quot;Nirvana&quot;, &quot;_index&quot;: &quot;music&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1.0, &quot;_source&quot;: { &quot;suggest&quot;: [ &quot;Nevermind&quot;, &quot;Nirvana&quot; ] } } ] } ] } }  基本完成建议查询支持以下参数： \tfield\t要在其上运行查询的字段的名称（必填）。 size\t要返回的建议数（默认为 5）。 skip_duplicates\t是否应过滤重复建议（默认为 false）。 提示 完成建议器考虑索引中的所有文档。有关如何查询文档子集的说明，参阅上下文建议器。 提示 如果完成查询跨越多个分片，建议分两个阶段执行，其中最后一个阶段从分片获取相关文档，这意味着针对单个分片执行完成请求的性能更高，因为当建议跨越多个分片时，文档获取开销更大。为了获得最佳的完成性能，建议将完成索引到单个分片索引中。如果由于分片大小导致堆使用率较高，仍然建议将索引拆分为多个分片，而不是优化完成性能。 ","version":"Next","tagName":"h3"},{"title":"跳过重复的建议​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#跳过重复的建议","content":"查询可以返回来自不同文档的重复建议。可以通过将 skip_duplicates 设置为 true 来修改此行为。设置后，此选项会从结果中过滤出包含重复建议的文档。 POST music/_search?pretty { &quot;suggest&quot;: { &quot;song-suggest&quot;: { &quot;prefix&quot;: &quot;nor&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;skip_duplicates&quot;: true } } } }  警告 当设置为 true 时，此选项会减慢搜索速度，因为需要访问更多建议才能找到前 N 个。 ","version":"Next","tagName":"h3"},{"title":"模糊查询​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#模糊查询","content":"完成建议器还支持模糊查询——这意味着你可以在搜索中输错，但仍然可以获得返回结果。 POST music/_search?pretty { &quot;suggest&quot;: { &quot;song-suggest&quot;: { &quot;prefix&quot;: &quot;nor&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;fuzzy&quot;: { &quot;fuzziness&quot;: 2 } } } } }  与查询 prefix 共享最长前缀的建议将获得更高的分数。 模糊查询可以采用特定的模糊参数。支持以下参数： \tfuzziness\t模糊因子默认为 auto。有关允许的设置，参阅模糊性。 transpositions\t如果设置为 true，则换位计算为一次更改，而不是两次，默认为 true min_length\t返回模糊建议前输入的最小长度，默认值为 3 prefix_length\t输入的最小长度默认为 1，不检查模糊选项 unicode_aware\t如果为 true，则所有度量（如模糊编辑距离、换位和长度）都以 Unicode 码点而不是字节来度量。这比原始字节稍慢，因此默认设置为 false。 提示 如果你想坚持使用默认值，但仍然使用fuzzy，可以使用 fuzzy:{} 或 fuzzy:true。 ","version":"Next","tagName":"h3"},{"title":"正则查询​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#正则查询","content":"完成建议器还支持正则表达式查询，这意味着你可以将前缀表示为正则表达式。 POST music/_search?pretty { &quot;suggest&quot;: { &quot;song-suggest&quot;: { &quot;regex&quot;: &quot;n[ever|i]r&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot; } } } }  正则查询可以采用特定的正则参数。支持以下参数： \tflags\t可能的标志有 ALL（默认）、ANYSTRING、COMPLEMENT、EMPTY、INTERSECTION、INTERVAL 或 NONE。参阅正则表达式语法了解其含义 max_determinized_states\t正则表达式是危险的，因为它很容易意外地创建一个看起来无害的表达式，它需要大量内部确定的自动机状态（以及相应的 RAM 和 CPU）供 Lucene 执行。Lucene 使用 max_determinized_states 设置（默认值为 10000）防止这些情况发生。可以提高此限制，以允许执行更复杂的正则表达式。 ","version":"Next","tagName":"h3"},{"title":"上下文建议器​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#上下文建议器","content":"完成建议器会考虑索引中的所有文档，但通常需要提供经过筛选和/或通过某些标准增强的建议。例如，你希望建议由某些艺术家筛选的歌曲标题，或者希望根据他们的流派增加歌曲标题。 要实现建议过滤和/或增强，可以在配置完成字段时添加上下文映射。可以为一个完成字段定义多个上下文映射。每个上下文映射都有一个唯一的名称和类型。有两种类型：category 和 geo。上下文映射在字段映射中的 contexts 参数下配置。 提示 索引和查询启用上下文的完成字段时，必须提供上下文。 提示 允许的最大完成字段上下文映射数为 10。 以下定义了类型，每个类型都有两个用于完成字段的上下文映射： PUT place { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;suggest&quot;: { &quot;type&quot;: &quot;completion&quot;, &quot;contexts&quot;: [ { &quot;name&quot;: &quot;place_type&quot;, &quot;type&quot;: &quot;category&quot; }, { &quot;name&quot;: &quot;location&quot;, &quot;type&quot;: &quot;geo&quot;, &quot;precision&quot;: 4 } ] } } } }  &quot;type&quot;: &quot;category&quot;： 定义一个名为 place_type 的 category 上下文，类别必须与建议一起发送。&quot;type&quot;: &quot;geo&quot;：定义一个名为 location 的 geo 上下文，类别必须与建议一起发送到该位置。 PUT place_path_category { &quot;mappings&quot;: { &quot;properties&quot;: { &quot;suggest&quot;: { &quot;type&quot;: &quot;completion&quot;, &quot;contexts&quot;: [ { &quot;name&quot;: &quot;place_type&quot;, &quot;type&quot;: &quot;category&quot;, &quot;path&quot;: &quot;cat&quot; }, { &quot;name&quot;: &quot;location&quot;, &quot;type&quot;: &quot;geo&quot;, &quot;precision&quot;: 4, &quot;path&quot;: &quot;loc&quot; } ] }, &quot;loc&quot;: { &quot;type&quot;: &quot;geo_point&quot; } } } }  &quot;type&quot;: &quot;category&quot;：定义一个名为 place_type 的 category 上下文，从 cat 字段中读取类别。&quot;type&quot;: &quot;geo&quot;：定义一个名为 location 的 geo 上下文，从 loc 字段中读取类别。 提示 添加上下文映射会增加完成字段的索引大小。完成索引完全驻留在堆中，你可以使用索引统计信息监视完成字段索引大小。 ","version":"Next","tagName":"h2"},{"title":"类别上下文​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#类别上下文","content":"category 上下文允许你在索引时将一个或多个类别与建议关联。在查询时，建议可以通过其关联的类别进行过滤和增强。 映射的设置与上面的 place_type 字段类似。如果定义了 path，则从文档中的该路径读取类别，否则它们必须在建议字段中发送，如下所示： PUT place/_doc/1 { &quot;suggest&quot;: { &quot;input&quot;: [ &quot;timmy's&quot;, &quot;starbucks&quot;, &quot;dunkin donuts&quot; ], &quot;contexts&quot;: { &quot;place_type&quot;: [ &quot;cafe&quot;, &quot;food&quot; ] } } }  &quot;place_type&quot;: [ &quot;cafe&quot;, &quot;food&quot; ]：这些建议将与 cafe 和 food 类别相关联。 如果映射有路径，那么以下索引请求就足以添加类别： PUT place_path_category/_doc/1 { &quot;suggest&quot;: [&quot;timmy's&quot;, &quot;starbucks&quot;, &quot;dunkin donuts&quot;], &quot;cat&quot;: [&quot;cafe&quot;, &quot;food&quot;] }  &quot;cat&quot;: [&quot;cafe&quot;, &quot;food&quot;]： 这些建议将与 cafe 和 food 类别相关联。 提示 如果上下文映射引用了另一个字段，并且对类别进行了显式索引，则建议将使用这两组类别进行索引。 ","version":"Next","tagName":"h3"},{"title":"类别查询​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#类别查询","content":"建议可以按一个或多个类别过滤。以下按多个类别筛选建议： POST place/_search?pretty { &quot;suggest&quot;: { &quot;place_suggestion&quot;: { &quot;prefix&quot;: &quot;tim&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;size&quot;: 10, &quot;contexts&quot;: { &quot;place_type&quot;: [ &quot;cafe&quot;, &quot;restaurants&quot; ] } } } } }  提示 如果在查询中设置了多个类别或类别上下文，它们将作为析取合并。这意味着，如果建议至少包含一个提供的上下文值，则建议匹配。 某些类别的建议可以比其他类别的建议更高。以下内容按类别过滤建议，并进一步增强与某些类别相关的建议： POST place/_search?pretty { &quot;suggest&quot;: { &quot;place_suggestion&quot;: { &quot;prefix&quot;: &quot;tim&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;size&quot;: 10, &quot;contexts&quot;: { &quot;place_type&quot;: [ { &quot;context&quot;: &quot;cafe&quot; }, { &quot;context&quot;: &quot;restaurants&quot;, &quot;boost&quot;: 2 } ] } } } } }  &quot;place_type&quot;：上下文查询过滤与类别咖啡馆和餐馆相关的建议，并将与餐馆相关的建议提高 2 倍 除了接受类别值外，上下文查询还可以由多个类别上下文子句组成。类别上下文子句支持以下参数： \tcontext\t要过滤/增强的类别的值。这是强制性的。 boost\t建议得分的提升因子，通过将提升值乘以建议权重来计算得分，默认为 1 prefix\t类别值是否应被视为前缀。例如，如果设置为 true，则可以通过指定 type 的类别前缀来过滤 type1、type2 等的类别。默认为 false 提示 如果一个建议条目匹配多个上下文，则最终分数将计算为任何匹配上下文产生的最大分数。 ","version":"Next","tagName":"h3"},{"title":"地理位置上下文​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#地理位置上下文","content":"geo 上下文允许你在索引时将一个或多个地理点或地理哈希与建议关联。在查询时，如果建议位于指定地理位置的特定距离内，则可以对其进行过滤和增强。 在内部，地理点被编码为具有指定精度的地理哈希。 地理映射​ 除 path 设置外，geo 上下文映射还接受以下设置： \tprecision\t这定义了要索引的地理哈希（geohash）的精度，可以指定为距离值（5m、10km等），也可以指定为原始地理哈希精度（1..12）。默认为原始地理哈希精度值 6。 提示 索引时间 precision 设置设置可在查询时使用的最大地理哈希精度。 索引地理上下文​ geo 上下文可以通过建议显式设置，或者通过 path 参数从文档中的地理点字段建立索引，类似于 category 上下文。将多个地理位置上下文与建议关联，将为每个地理位置的建议编制索引。以下索引包含两个地理位置上下文： PUT place/_doc/1 { &quot;suggest&quot;: { &quot;input&quot;: &quot;timmy's&quot;, &quot;contexts&quot;: { &quot;location&quot;: [ { &quot;lat&quot;: 43.6624803, &quot;lon&quot;: -79.3863353 }, { &quot;lat&quot;: 43.6624718, &quot;lon&quot;: -79.3873227 } ] } } }  ","version":"Next","tagName":"h3"},{"title":"地理位置查询​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#地理位置查询","content":"建议可以根据它们与一个或多个地理点的距离进行过滤和增强。以下过滤属于由地理点的编码地理哈希表示的区域内的建议： POST place/_search { &quot;suggest&quot;: { &quot;place_suggestion&quot;: { &quot;prefix&quot;: &quot;tim&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;size&quot;: 10, &quot;contexts&quot;: { &quot;location&quot;: { &quot;lat&quot;: 43.662, &quot;lon&quot;: -79.380 } } } } } }  提示 当指定查询时精度较低的位置时，将考虑该区域内的所有建议。 提示 如果在查询中设置了多个类别或类别上下文，它们将作为析取合并。这意味着，如果建议至少包含一个提供的上下文值，则建议匹配。 在地理哈希表示的区域内的建议也可以比其他建议更高，如下所示： POST place/_search?pretty { &quot;suggest&quot;: { &quot;place_suggestion&quot;: { &quot;prefix&quot;: &quot;tim&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;suggest&quot;, &quot;size&quot;: 10, &quot;contexts&quot;: { &quot;location&quot;: [ { &quot;lat&quot;: 43.6624803, &quot;lon&quot;: -79.3863353, &quot;precision&quot;: 2 }, { &quot;context&quot;: { &quot;lat&quot;: 43.6624803, &quot;lon&quot;: -79.3863353 }, &quot;boost&quot;: 2 } ] } } } } }  &quot;location&quot;：上下文查询过滤属于地理哈希 （43.662，-79.380） 表示的地理位置的建议（精度为 2），并将属于地理哈希 （43.6624803，-79.3863353） 表示的建议（默认精度为 6）的建议提升 2 倍 提示 如果一个建议条目匹配多个上下文，则最终分数将计算为任何匹配上下文产生的最大分数。 除了接受上下文值之外，上下文查询还可以由多个上下文子句组成。geo 上下文子句支持以下参数： \tcontext\t用于过滤或增强建议的地理点对象或地理哈希字符串。这是强制性的。 boost\t建议得分的提升因子，通过将提升值乘以建议权重来计算得分，默认为 1 precision\t对查询地理点进行编码的地理哈希的精度。这可以指定为距离值（5m、10km 等），也可以指定为原始geohash精度（1..12）。默认为索引时间精度级别。 neighbours\t接受一个精度值数组，在该数组中应考虑相邻的地理哈希。精度值可以是距离值（5m、10km 等）或原始geohash精度（1..12）。默认为生成索引时间精度级别的邻居。 ","version":"Next","tagName":"h3"},{"title":"返回建议器类型​","type":1,"pageTitle":"建议器","url":"/docs/elasticsearch-cn/rest_apis/search_apis/suggesters#返回建议器类型","content":"有时你需要知道建议者的确切类型，以便分析其结果。typed_keys 参数可用于更改响应中建议者的名称，以便以其类型作为前缀。 考虑以下两个建议 term 和 phrase 的示例： POST _search?typed_keys { &quot;suggest&quot;: { &quot;text&quot; : &quot;some test mssage&quot;, &quot;my-first-suggester&quot; : { &quot;term&quot; : { &quot;field&quot; : &quot;message&quot; } }, &quot;my-second-suggester&quot; : { &quot;phrase&quot; : { &quot;field&quot; : &quot;message&quot; } } } }  在回复中，建议者的名称将分别更改为 term#my-first-suggester 和 phrase#my-second-suggester，以反映每个建议的类型： { &quot;suggest&quot;: { &quot;term#my-first-suggester&quot;: [ { &quot;text&quot;: &quot;some&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 4, &quot;options&quot;: [] }, { &quot;text&quot;: &quot;test&quot;, &quot;offset&quot;: 5, &quot;length&quot;: 4, &quot;options&quot;: [] }, { &quot;text&quot;: &quot;mssage&quot;, &quot;offset&quot;: 10, &quot;length&quot;: 6, &quot;options&quot;: [ { &quot;text&quot;: &quot;message&quot;, &quot;score&quot;: 0.8333333, &quot;freq&quot;: 4 } ] } ], &quot;phrase#my-second-suggester&quot;: [ { &quot;text&quot;: &quot;some test mssage&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 16, &quot;options&quot;: [ { &quot;text&quot;: &quot;some test message&quot;, &quot;score&quot;: 0.030227963 } ] } ] }, ... }  &quot;term#my-first-suggester&quot;：my-first-suggester的名字现在包含了 term 前缀。&quot;phrase#my-second-suggester&quot;：my-second-suggester 的名字现在包含 phrase 前缀。 原文链接 ","version":"Next","tagName":"h2"},{"title":"集群级分片分配和路由设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"集群级分片分配设置​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#集群级分片分配设置","content":"你可以使用以下设置来控制分片分配和恢复： cluster.routing.allocation.enable （动态）为特定种类的分片启用或禁用分配： all ——（默认）允许为所有类型的分片分配分片。primaries ——仅允许主分片分配分片。new_primaries ——仅允许为新索引的主分片分配分片。none ——任何索引都不允许任何类型的分片分配。 重新启动节点时，此设置不会影响本地主分片的恢复。具有未分配主分片副本的重新启动节点将立即恢复该主分片，前提是其分配 id 与集群状态中的活动分配 id 之一匹配。 cluster.routing.allocation.node_concurrent_incoming_recoveries （动态）一个节点上允许发生多少并发传入分片恢复。传入恢复是指在节点上分配目标分片（除非分片正在重新定位，否则很可能是副本）的恢复。默认为 2。 cluster.routing.allocation.node_concurrent_outgoing_recoveries （动态）一个节点上允许发生多少并发传出分片恢复。传出恢复是指在节点上分配源分片（除非分片正在重新定位，否则很可能是主分片）的恢复。默认为 2。 cluster.routing.allocation.node_concurrent_recoveries （动态）快捷设置所有 cluster.routing.allocation.node_concurrent_incoming_recoveries 和 cluster.routing.allocation.node_concurrent_outgoing_recoveries。 cluster.routing.allocation.node_initial_primaries_recoveries （动态）虽然副本的恢复是通过网络进行的，但节点重新启动后未分配的主副本的恢复将使用本地磁盘中的数据。这些恢复应该很快，因此可以在同一节点上并行进行更多的初始主恢复。默认为 4。 cluster.routing.allocation.same_shard.host （动态）如果为 true，则禁止将分片的多个副本分配给同一主机上的不同节点，即具有相同网络地址的节点。默认为 false，这意味着有时可以将分片的副本分配给同一主机上的节点。只有在每个主机上运行多个节点时，此设置才有关。 ","version":"Next","tagName":"h2"},{"title":"分片重平衡设置​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#分片重平衡设置","content":"当集群在每个节点上具有相等数量的分片，而没有来自任何节点上任何索引的分片集中时，集群是平衡的。Elasticsearch 运行一个称为重新平衡的自动过程，该过程在集群中的节点之间移动碎片，以改善其平衡。重平衡遵循所有其他分片分配规则，如分配过滤和强制感知，这可能会阻止它完全平衡集群。在这种情况下，重平衡努力在你配置的规则内实现尽可能平衡的集群。如果你使用的是数据层，Elasticsearch 会自动应用分配过滤规则，将每个分片放在适当的层中。这些规则意味着均衡器在每个层中独立工作。 你可以使用以下设置来控制集群中分片的重新平衡： cluster.routing.rebalance.enable （动态）为特定类型的分片启用或禁用重新平衡： all ——（默认）允许为所有类型的分片进行分片平衡。primaries ——仅允许主分片进行分片平衡。new_primaries ——仅允许为新索引的主分片进行分片平衡。none ——任何索引都不允许任何类型的分片平衡。 cluster.routing.allocation.allow_rebalance （动态）指定何时允许分片重平衡： always ——总是允许重平衡indices_primaries_active ——仅当集群中的所有主节点都已分配时。indices_all_active ——（默认）仅当集群中的所有分片（主分片和副本）都已分配时。 cluster.routing.allocation.cluster_concurrent_rebalance （动态）允许控制集群范围内允许多少并发分片重平衡。默认值为 2。请注意，此设置仅控制由于集群中的不平衡而导致的并发分片重定位的数量。由于分配筛选或强制感知，此设置不会限制分片重定位。 ","version":"Next","tagName":"h2"},{"title":"分片平衡启发式设置​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#分片平衡启发式设置","content":"重平衡的工作方式是根据每个节点的分片分配计算每个节点的权重，然后在节点之间移动分片，以减少较重节点的权重并增加较轻节点的权重。当没有可能的分片移动使任何节点的权重接近任何其他节点的权重超过可配置的阈值时，集群是平衡的。以下设置允许你控制这些计算的详细信息。 cluster.routing.allocation.balance.shard （动态）定义节点上分配的碎片总数的权重因子（浮点）。默认为 0.45f。提高这一点会使集群中所有节点的分片数量趋于均衡。 cluster.routing.allocation.balance.index （动态）定义在特定节点（浮点）上分配的每个索引的碎片数的权重因子。默认为 0.55f。提高这一点会增加在集群中所有节点上均衡每个索引的分片数量的趋势。 cluster.routing.allocation.balance.threshold （动态）应执行的操作的最小优化值（非负浮点）。默认值为 1.0f。提高此值将导致集群在优化分片平衡方面不太积极。 注意 无论平衡算法的结果如何，由于强制感知或分配过滤，可能不允许重新平衡。 ","version":"Next","tagName":"h2"},{"title":"基于磁盘的分片分配设置​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#基于磁盘的分片分配设置","content":"基于磁盘的分片分配器可确保所有节点都有足够的磁盘空间，而无需执行超出必要的分片移动。它基于一对称为低水位和高水位的阈值来分配分片。它的主要目标是确保没有节点超过高水位，或者至少任何这样的水位只是暂时的。如果一个节点超过了高水位，Elasticsearch 将通过将其分片移动到集群中的其他节点来解决这个问题。 注意 节点有时会暂时超出高水位，这是正常的。 分配器还试图通过禁止向超过低水位的节点分配更多分片来保持节点远离高水位。重要的是，如果所有节点都超过了低水位，则无法分配新的分片，Elasticsearch 将无法在节点之间移动任何分片，以将磁盘使用率保持在高水位以下。你必须确保你的集群总共有足够的磁盘空间，并且总是有一些节点低于低水位线。 基于磁盘的分片分配器触发的分片移动，还必须满足所有其他分片分配规则，如分配筛选和强制感知。如果这些规则过于严格，那么它们还可以阻止分片移动，以控制节点的磁盘使用。如果你使用的是数据层，Elasticsearch会自动配置分配过滤规则，将碎片放置在适当的层中，这意味着基于磁盘的分片分配器在每个层中独立工作。 如果一个节点填满其磁盘的速度快于 Elasticsearch 将分片移动到其他地方的速度，则存在磁盘将完全填满的风险。为了防止这种情况，作为最后的手段，一旦磁盘使用率达到洪泛阶段，Elasticsearch 将阻止对受影响节点上具有分片的索引的写入。它还将继续将分片移动到集群中的其他节点上。当受影响节点上的磁盘使用率降至高水位以下时，Elasticsearch 会自动删除写块。 提示 集群中的节点使用的磁盘空间量非常不同，这是正常的。集群的平衡只取决于每个节点上的碎片数量以及这些碎片所属的索引。它既不考虑这些碎片的大小，也不考虑每个节点上的可用磁盘空间，原因如下： 磁盘使用率随时间变化。平衡单个节点的磁盘使用将需要更多的分片移动，甚至可能会浪费掉先前的移动。移动分片会消耗资源，如 I/O 和网络带宽，并可能从文件系统缓存中收回数据。在可能的情况下，最好使用这些资源来处理搜索和索引。只要没有磁盘太满，每个节点上的磁盘使用率相等的集群通常不会比磁盘使用率不相等的集群性能更好。 你可以使用以下设置来控制基于磁盘的分配： cluster.routing.allocation.disk.threshold_enabled （动态）默认为 true。设置为 false 可禁用磁盘分配决策器。禁用后，它还将删除任何现有的 index.blocks.read_only_allow_delete 索引块。 cluster.routing.allocation.disk.watermark.low （动态）控制磁盘使用的低水位。默认为 85%，这意味着 Elasticsearch 不会将分片分配给磁盘使用率超过 85% 的节点。也可以将其设置为比率值，例如 0.85。也可以将它设置为绝对字节值（如 500mb），以防止 Elasticsearch 在可用空间少于指定数量时分配分片。此设置对新创建索引的主分片没有影响，但会阻止分配其副本。 cluster.routing.allocation.disk.watermark.high （动态）控制高水位。默认为 90%，这意味着 Elasticsearch 将尝试将分片从磁盘使用率高于 90% 的节点重新定位。也可以将其设置为比率值，例如 0.9。也可以将它设置为绝对字节值（类似于低水印），以便在节点的可用空间小于指定数量时将分片重新定位到远离节点的位置。此设置会影响所有分片的分配，无论以前是否分配。 cluster.routing.allocation.disk.watermark.enable_for_single_data_node （静态）在早期版本中，默认行为是在做出分配决策时忽略单个数据节点群集的磁盘水印。这是自 7.14 以来被弃用的行为，已在 8.0 中删除。此设置的唯一有效值现在为 true。该设置将在以后的版本中删除。 cluster.routing.allocation.disk.watermark.flood_stage （动态）控制危险水位，默认为 95%。Elasticsearch 对每个索引强制执行只读索引块（index.blocks.read_only_allow_delete），该索引在节点上分配了一个或多个分片，并且至少有一个磁盘超过危险水位。此设置是防止节点耗尽磁盘空间的最后手段。当磁盘利用率低于高水位时，索引块将自动释放。与低和高水位类似，也可以将其设置为比值，例如 0.95 或绝对字节值。 注意 不能在水印设置中混合使用百分比/比率值和字节值。要么将所有值设置为百分比/比率值，要么将所有设置为字节值。此强制是为了让 Elasticsearch 可以验证设置是否内部一致，确保低磁盘阈值小于高磁盘阈值，高磁盘阈值小于危险水位阈值。 重置 my-index-000001 索引上的只读索引块的示例： PUT /my-index-000001/_settings { &quot;index.blocks.read_only_allow_delete&quot;: null }  cluster.routing.allocation.disk.watermark.flood_stage.frozen （动态）控制专用冻结节点的危险水位，默认为 95%。 cluster.routing.allocation.disk.watermark.flood_stage.frozen.max_headroom （动态）控制专用冻结节点的危险水位的最大净空。当 cluster.routing.allocation.disk.watermark.flood_stage.frozen 未明确设置时，默认为 20GB。这将限制专用冻结节点上所需的可用空间量。 cluster.info.update.interval （动态）Elasticsearch 应该多久检查一次集群中每个节点的磁盘使用情况。默认为 30s。 注意 百分比值表示已使用的磁盘空间，而字节值表示可用磁盘空间。这可能会让人困惑，因为它颠倒了高低的含义。例如，将低水位设置为 10gb，将高水位设置为 5gb 是有意义的，但反之亦然。 将低水位更新为至少 100 GB 可用、高水位至少 50 GB 可用、洪水阶段水位线至少10 GB可用，并每分钟更新有关集群的信息的示例： PUT _cluster/settings { &quot;persistent&quot;: { &quot;cluster.routing.allocation.disk.watermark.low&quot;: &quot;100gb&quot;, &quot;cluster.routing.allocation.disk.watermark.high&quot;: &quot;50gb&quot;, &quot;cluster.routing.allocation.disk.watermark.flood_stage&quot;: &quot;10gb&quot;, &quot;cluster.info.update.interval&quot;: &quot;1m&quot; } }  ","version":"Next","tagName":"h2"},{"title":"分片分配感知​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#分片分配感知","content":"你可以使用自定义节点属性作为感知属性，以使 Elasticsearch 在分配分片时考虑物理硬件配置。如果 Elasticsearch 知道哪些节点位于同一物理服务器上、同一机架中或同一区域中，它可以分发主分片及其副本分片，以最大限度地减少在发生故障时丢失所有分片副本的风险。 当使用动态 cluster.routing.allocation.awareness.attributes 启用分片分配感知时，分片仅分配给为指定感知属性设置了值的节点。如果使用多个感知属性，Elasticsearch 在分配分片时会分别考虑每个属性。 注意 属性值的数量决定了在每个位置分配了多少分片副本。如果每个位置中的节点数量不平衡，并且有大量副本，则副本分片可能未分配。 ","version":"Next","tagName":"h2"},{"title":"启用分片分配感知​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#启用分片分配感知","content":"为了启用分片分配感知： 使用自定义节点属性指定每个节点的位置。例如，如果你希望 Elasticsearch 在不同的机架上分发分片，可以在每个节点的 elasticsearch.yml 配置文件中设置一个名为 rack_id 的感知属性。 node.attr.rack_id: rack_one  启动节点时，还可以设置自定义属性： ./bin/elasticsearch -Enode.attr.rack_id=rack_one  告诉 Elasticsearch 在分配分片时，通过在每个符合主节点的 elasticsearch.yml 配置文件中设置 cluster.routing.allocation.awareness.attributes 来考虑一个或多个感知属性。 cluster.routing.allocation.awareness.attributes: rack_id  将多个属性指定为逗号分隔的列表。 你还可以使用集群更新设置 API 来设置或更新集群的感知属性。 在这个示例配置中，如果使用 node.attr 启动两个节点。rack_id 设置为 rack_one 并创建一个索引，其中包含 5 个主分片和每个主分片的 1 个副本，所有主分片和副本都在这两个节点上分配。 如果使用 node.attr 添加两个节点。rack_id 设置为 rack_two，Elasticsearch 将分片移动到新节点，确保（如果可能）同一分片的两个副本不在同一机架中。 如果 rack_two 失败并关闭其两个节点，默认情况下，Elasticsearch 会将丢失的碎片副本分配给 rack_one 中的节点。为了防止在同一位置分配特定分片的多个副本，可以启用强制感知。 ","version":"Next","tagName":"h3"},{"title":"强制感知​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#强制感知","content":"默认情况下，如果一个位置失败，Elasticsearch 会将所有丢失的副本分片分配给其余位置。虽然你可能在所有位置拥有足够的资源来托管主分片和副本分片，但单个位置可能无法托管所有分片。 为了防止单个位置在发生故障时过载，可以设置 cluster.routing.allocation.awareness.force，以便在其他位置的节点可用之前不分配副本。 例如，如果你有一个名为 zone 的感知属性，并在 zone1 和 zone2 中配置节点，则可以使用强制感知来防止 Elasticsearch 在只有一个可用区域的情况下分配副本： cluster.routing.allocation.awareness.attributes: zone cluster.routing.allocation.awareness.force.zone.values: zone1,zone2  cluster.routing.allocation.awareness.force.zone.values: zone1,zone2：指定感知属性的所有可能值。 在这个示例配置中，如果将 node.attr.zone 设置为 zone1 并创建一个包含 5 个分片和 1 个副本的索引，用于启动两个节点。Elasticsearch 创建索引并分配 5 个主分片，但不分配副本。只有 node.attr.zone 设置为 zone1 的节点可用时，才会分配副本。 ","version":"Next","tagName":"h3"},{"title":"集群级分片分配筛选​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#集群级分片分配筛选","content":"你可以使用集群级分片分配过滤器来控制 Elasticsearch 从任何索引分配分片的位置。这些集群范围的过滤器与按索引分配过滤和分配感知一起应用。 分片分配筛选器可以基于自定义节点属性或内置的 _name、_host_ip、_publish_ip、_ip、_ host、_id 和 _tier 属性。 cluster.routing.allocation 设置是动态的，允许将活动索引从一组节点移动到另一组节点。只有在不破坏另一个路由约束（例如从不在同一节点上分配主分片和副本分片）的情况下才能重新定位分片。 集群级分片分配过滤最常见的用例是，当你想要解除某个节点的授权时。要在关闭节点之前将分片移出该节点，可以创建一个过滤器，通过其 IP 地址排除该节点： PUT _cluster/settings { &quot;persistent&quot; : { &quot;cluster.routing.allocation.exclude._ip&quot; : &quot;10.0.0.1&quot; } } ","version":"Next","tagName":"h2"},{"title":"集群路由设置​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#集群路由设置","content":"cluster.routing.allocation.include.{attribute} （动态）将分片分配给与 ｛attribute｝ 中至少有一个逗号分隔值匹配的节点。 cluster.routing.allocation.require.{attribute} （动态）仅将分片分配给与 ｛attribute｝ 中所有逗号分隔值匹配的节点。 cluster.routing.allocation.exclude.{attribute} （动态）不将分片分配给与 ｛attribute｝ 中任何逗号分隔值匹配的节点。 \t_name\t按节点名字匹配节点 _host_ip\t按 IP 地址匹配节点（IP 关联主机名） _publish_ip\t按公开 IP 地址匹配节点 _ip\t匹配 _host_ip 或者 _publish_ip _host\t按主机名匹配 _id\t按节点 id 匹配 _tier\t按节点数据层角色匹配节点 注意 _tier 过滤基于节点角色。只有角色的子集是数据层角色，通用数据角色将匹配任何层筛选。数据层角色的角色子集，但通用数据角色将匹配任何层筛选。 指定属性值时可以使用通配符，例如： PUT _cluster/settings { &quot;persistent&quot;: { &quot;cluster.routing.allocation.exclude._ip&quot;: &quot;192.168.2.*&quot; } }  ","version":"Next","tagName":"h3"},{"title":"杂项集群级设置​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#杂项集群级设置","content":"","version":"Next","tagName":"h2"},{"title":"元数据​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#元数据","content":"可以使用以下设置将整个群集设置为只读： cluster.blocks.read_only （动态）将整个集群设为只读（索引不接受写入操作），不允许修改元数据（创建或删除索引）。 cluster.blocks.read_only_allow_delete （动态）与 cluster.blocks.read_only 相同，但允许删除索引以释放资源。 警告 不要依赖此设置来阻止更改集群。任何有权访问集群更新设置 API的用户都可以使集群再次读写。 ","version":"Next","tagName":"h3"},{"title":"集群分片限制​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#集群分片限制","content":"根据集群中的节点数量，对集群中的碎片数量有一个软限制。这是为了防止可能无意中破坏集群稳定的操作。 重要 此限制旨在作为安全网，而不是尺寸建议。集群可以安全支持的分片的确切数量取决于硬件配置和工作负载，但在几乎所有情况下都应该保持在这个限制之下，因为默认限制设置得很高。 如果某个操作（如创建新索引、恢复索引快照或打开关闭的索引）会导致集群中的碎片数量超过此限制，则该操作将失败，并出现指示碎片限制的错误。 如果由于节点成员身份的更改或设置的更改，群集已超过限制，则创建或打开索引的所有操作都将失败，除非限制如下文所述增加，或者关闭或删除某些索引以使碎片数低于限制。 对于正常（非冻结）索引，群集分片限制默认为每个非冻结数据节点 1000 个碎片，对于冻结索引，每个冻结数据节点 3000 个分片。所有开放索引的主分片和副本分片都将计入限制，包括未分配的分片。例如，一个包含 5 个主分片和2个副本的开放索引计为 15 个分片。闭合索引不会影响分片计数。 你可以使用以下设置动态调整集群分片限制： cluster.max_shards_per_node （动态）限制集群的主分片和副本分片的总数。Elasticsearch 计算极限如下： cluster.max_shards_per_node * 非冻结节点数 关闭索引的分片不计入此限制。默认为 1000。没有数据节点的集群是无限的。 Elasticsearch 拒绝任何创建超过此限制的分片的请求。例如，一个 cluster.max_shards_per_node 设置为 100 且三个数据节点的集群的分片限制为 300。如果该集群已经包含 296 个分片，Elasticsearch 将拒绝任何向集群添加五个或更多分片的请求。 请注意，冻结分片有自己的独立限制。 cluster.max_shards_per_node.frozen （动态）限制集群的主节点和副本冻结分片的总数。Elasticsearch 计算极限如下： cluster.max_shards_per_node * 冻结结点数量 关闭索引的碎片不计入此限制。默认为 3000。没有冻结数据节点的集群是无限的。 Elasticsearch拒绝任何创建超过此限制的冻结分片的请求。例如，cluster.max_shards_per_node.frozen 设置为 100 且三个冻结数据节点的集群的冻结分片限制为 300。如果群集已包含 296 个分片，Elasticsearch 将拒绝向集群添加五个或更多冻结分片的任何请求。 注意 这些设置不限制单个节点的分片。要限制每个节点的分片数量，请使用 cluster.routing.allocation.total_shards_per_node 设置。 ","version":"Next","tagName":"h3"},{"title":"用户定义的集群元数据​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#用户定义的集群元数据","content":"可以使用群集群设置 API 存储和检索用户定义的元数据。这可以用于存储关于集群的任意、不经常更改的数据，而无需创建索引来存储数据。可以使用以 cluster.metadata 为前缀的任何密钥来存储此数据。例如，将集群管理员的电子邮件地址存储在密钥 cluster.metadata.administrato 下，发出此请求： PUT /_cluster/settings { &quot;persistent&quot;: { &quot;cluster.metadata.administrator&quot;: &quot;sysadmin@example.com&quot; } }  重要 用户定义的集群元数据不用于存储敏感或机密信息。任何有权访问集群获取设置 API 的人都可以查看存储在用户定义的集群元数据中的任何信息，并将其记录在 Elasticsearch 日志中。 ","version":"Next","tagName":"h3"},{"title":"索引墓碑​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#索引墓碑","content":"集群状态维护索引逻辑删除，以明确表示已删除的索引。集群状态下维护的逻辑删除数由以下设置控制： cluster.indices.tombstones.size （静态）索引逻辑删除防止在发生删除时不属于集群的节点加入集群并重新导入索引，就像从未发出删除一样。为了防止集群状态变大，我们只保留最后的 cluster.indices.tombstones.size 次删除，默认为 500 次。如果你希望节点不在集群中，并且错过了 500 次以上的删除，你可以增加它。我们认为这是罕见的，因此是违约。墓碑不会占用太多空间，但我们也认为像 50000 这样的数字可能太大了。 如果 Elasticsearch 遇到当前集群状态中不存在的索引数据，则认为这些索引是悬空的。例如，如果在 Elasticsearch 节点脱机时删除了多个 cluster.indices.tombstones.size 索引，则会发生这种情况。 你可以使用悬空索引 API 来管理这种情况。 ","version":"Next","tagName":"h3"},{"title":"日志器​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#日志器","content":"可以使用 logger. 前缀动态更新控制日志记录的设置。例如，要将 indices.recovery 模块的日志级别提高到 DEBUG，发出以下请求： PUT /_cluster/settings { &quot;persistent&quot;: { &quot;logger.org.elasticsearch.indices.recovery&quot;: &quot;DEBUG&quot; } }  ","version":"Next","tagName":"h3"},{"title":"持久性任务分配​","type":1,"pageTitle":"集群级分片分配和路由设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cluster_level_shard_allocation_and_routing_settings#持久性任务分配","content":"插件可以创建一种称为持久任务的任务。这些任务通常是长寿命任务，存储在集群状态中，允许任务在完全集群重启后恢复。 每次创建持久任务时，主节点负责将任务分配给集群的一个节点，然后分配的节点将拾取任务并在本地执行。将持久任务分配给节点的过程由以下设置控制： cluster.persistent_tasks.allocation.enable （动态）启用或禁用永久任务的分配： all ——（默认）允许将持久任务分配给节点none ——任何类型的持久任务都不允许分配 此设置不会影响已执行的持久任务。只有新创建的持久任务或必须重新分配的任务（例如，在节点离开集群后）才会受到此设置的影响。 cluster.persistent_tasks.allocation.recheck_interval （动态）当集群状态发生显著变化时，主节点将自动检查是否需要分配持久任务。但是，可能还有其他因素，例如内存使用，会影响是否可以将持久任务分配给节点，但不会导致集群状态改变。此设置控制执行分配检查以对这些因素作出反应的频率。默认值为 30 秒。最小允许值为 10 秒。 原文链接 ","version":"Next","tagName":"h3"},{"title":"跨集群复制设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cross_cluster_replication_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"远程恢复设置​","type":1,"pageTitle":"跨集群复制设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cross_cluster_replication_settings#远程恢复设置","content":"以下设置可用于对远程恢复期间传输的数据进行速率限制： ccr.indices.recovery.max_bytes_per_sec （动态） 限制每个节点上的总入站和出站远程恢复流量。由于此限制适用于每个节点，但可能有多个节点同时执行远程恢复，因此远程恢复字节的总量可能远高于此限制。如果将此限制设置得太高，则存在进行中的远程恢复将消耗过量带宽（或其他资源）的风险，这可能会破坏集群的稳定。该设置同时用于领导者和追随者集群。例如，如果将一个领导者其设置为 20mb，那么即使追随者正在请求，领导也只会向随从发送 20mb/s，且可以能 60mb/s。默认为 40mb。 ","version":"Next","tagName":"h2"},{"title":"高级远程恢复设置​","type":1,"pageTitle":"跨集群复制设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/cross_cluster_replication_settings#高级远程恢复设置","content":"可以设置以下专家设置来管理远程恢复所消耗的资源： ccr.indices.recovery.max_concurrent_file_chunks （动态） 控制每次恢复可并行发送的文件块请求数。由于多个远程恢复可能已经并行运行，因此增加此专家级设置可能只会在单个分片的远程恢复未达到 ccr.indices.recovery.max_bytes_per_sec 配置的总入站和出站远程恢复流量的情况下有所帮助。默认为 5。允许的最大值为 10。 ccr.indices.recovery.chunk_size （动态） 控制文件传输期间追随者请求的块大小。默认为 1mb。 ccr.indices.recovery.recovery_activity_timeout （动态） 控制恢复活动的超时。此超时主要适用于领导者集群。领导者集群必须在内存中打开资源，以便在恢复过程中向追随者提供数据。如果领导者在这段时间内没有收到跟随者的恢复请求，它将关闭资源。默认为 60 秒。 ccr.indices.recovery.internal_action_timeout （动态） 控制远程恢复过程中单个网络请求的超时。单个操作超时可能会导致恢复失败。默认为 60 秒。 原文链接 ","version":"Next","tagName":"h2"},{"title":"发现和集群组成设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/discovery_and_cluster_formation_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"专家设置​","type":1,"pageTitle":"发现和集群组成设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/discovery_and_cluster_formation_settings#专家设置","content":"发现和集群形成也会受到以下专家级设置的影响，尽管不建议将这些设置中的任何一个更改为默认值。 警告 如果你调整这些设置，那么你的集群可能无法正确形成，或者可能变得不稳定或无法容忍某些故障。 discovery.cluster_formation_warning_timeout (静态)设置节点在记录集群未形成的警告之前尝试形成集群的时间。默认值为 10s。如果在 discovery.cluster_formation_warning_timeout 后未形成集群，则节点将记录一条警告消息，该消息以短语 master not discovery 开头，描述发现过程的当前状态。 discovery.find_peers_interval (静态)设置节点在尝试另一轮发现之前等待的时间。默认为 1s。 discovery.probe.connect_timeout (静态)设置尝试连接到每个地址时等待的时间。默认为 30s。 discovery.probe.handshake_timeout (静态)设置尝试通过握手标识远程节点时等待的时间。默认为 30S。 discovery.request_peers_timeout (静态)设置节点在再次询问其对等方后等待多长时间后才认为请求失败。默认为 3s。 discovery.find_peers_warning_timeout (静态)设置节点在开始记录描述连接尝试失败原因的详细消息之前尝试发现其对等方的时间。默认为 3m。 discovery.seed_resolver.max_concurrent_resolvers (静态)指定解析种子节点地址时要执行的并发 DNS 查找数。默认为 10。 discovery.seed_resolver.timeout (静态)指定解析种子节点地址时执行的每次DNS查找的等待时间。默认为 5s。 cluster.auto_shrink_voting_configuration (动态)控制投票配置是否自动丢弃离开的节点，只要它仍然包含至少 3 个节点。默认值为 true。如果设置为 false，投票配置永远不会自动收缩，你必须使用投票配置排除 API 手动删除离开的节点。 cluster.election.back_off_time (静态)设置在每次选举失败时增加选举前等待时间额外值的上限。请注意，这是线性回退。默认为 100ms。从默认设置更改此设置可能会导致集群无法选择主节点。 cluster.election.duration (静态)设置在节点认为每次选举失败并计划重试之前允许每次选举的时间。默认为 500ms。从默认设置更改此设置可能会导致集群无法选择主节点。 cluster.election.initial_timeout (静态)设置节点在尝试第一次选择之前，最初等待多长时间的上限，或者在所选主节点失败后等待多长时间。默认为 100ms。从默认设置更改此设置可能会导致集群无法选择主节点。 cluster.election.max_timeout (静态)设置节点在尝试第一次选举之前等待多长时间的最大上限，以便持续很长时间的网络分区不会导致过于稀疏的选举。默认为 10s。从默认设置更改此设置可能会导致集群无法选择主节点。 cluster.fault_detection.follower_check.interval (静态)设置选定的主机在认为跟随者检查失败之前等待响应的时间。默认为 10s。从默认设置更改此设置可能会导致群集变得不稳定。 cluster.fault_detection.follower_check.retry_count (静态)设置在选定的主节点认为该节点有故障并将其从集群中删除之前，每个节点必须连续发生多少次跟随器检查失败。默认值为 3。从默认值更改此设置可能会导致集群变得不稳定。 cluster.fault_detection.leader_check.interval (静态)设置每个节点在检查选定主节点之间等待的时间。默认为 1s。从默认设置更改此设置可能会导致集群变得不稳定。 cluster.fault_detection.leader_check.timeout (静态)设置每个节点在认为其失败之前等待所选主节点对引线检查的响应的时间。默认为 10s。从默认设置更改此设置可能会导致集群变得不稳定。 cluster.fault_detection.leader_check.retry_count (静态)设置在节点认为选定的主节点有故障并尝试查找或选择新主节点之前，必须发生多少次连续引线检查失败。默认值为 3。从默认值更改此设置可能会导致集群变得不稳定。 cluster.follower_lag.timeout (静态)设置主节点等待从滞后节点接收群集状态更新确认的时间。默认值为 90s。如果某个节点在这段时间内没有成功应用集群状态更新，则该节点将被视为已失败并从集群中删除。参阅发布集群状态。 cluster.max_voting_config_exclusions (动态)设置一次投票配置排除次数的限制。默认值为 10。参阅添加和删除节点。 cluster.publish.info_timeout (静态)设置主节点等待每个集群状态更新完全发布到所有节点的时间，然后记录一条指示某些节点响应缓慢的消息。默认值为 10s。 cluster.publish.timeout (静态)设置主节点等待每个群集状态更新完全发布到所有节点的时间，除非 discovery.type 设置为 single-node。默认值为 30s。参阅发布集群状态。 cluster.discovery_configuration_check.interval (静态)设置将记录有关不正确发现配置的警告的某些检查的间隔。默认值为 30s。 cluster.join_validation.cache_timeout (静态)当一个节点请求加入集群时，所选的主节点会向它发送最近集群状态的副本，以检测可能阻止新节点加入集群的某些问题。主节点缓存它发送的状态，如果另一个节点不久后加入集群，则使用缓存状态。此设置控制主机在清除此缓存之前等待的时间。默认为 60s。 cluster.no_master_block (动态)指定集群中没有活动主机时拒绝哪些操作。此设置有三个有效值： all 节点上的所有操作（读操作和写操作）都被拒绝。这也适用于API集群状态读取或写入操作，如获取索引设置、更新映射和集群状态API。 write （默认）写入操作被拒绝。根据上次已知的集群配置，读取操作成功。这种情况可能导致部分读取过时数据，因为该节点可能与集群的其他部分隔离。 metadata_write 只有元数据写入操作（例如，映射更新、路由表更改）被拒绝，但常规索引操作仍然有效。根据上次已知的集群配置，读取和写入操作成功。这种情况可能导致部分读取过时数据，因为该节点可能与集群的其他部分隔离。 注意 cluster.no_master_block 设置不适用于基于节点的 API（例如，集群统计、节点信息和节点统计 API）。对这些 API 的请求不会被阻止，可以在任何可用节点上运行。要使集群完全运行，它必须有一个活动的主机。 monitor.fs.health.enabled (动态)如果为 true，则节点会定期运行文件系统健康检查。默认为 true。 monitor.fs.health.refresh_interval (静态)连续文件系统健康检查之间的间隔。默认为 2m。 monitor.fs.health.slow_path_logging_threshold (动态)如果文件系统健康检查花费的时间超过此阈值，则 Elasticsearch 会记录一条警告。默认为 5s。 原文链接 ","version":"Next","tagName":"h2"},{"title":"字段数据缓存设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/field_data_cache_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"缓存大小​","type":1,"pageTitle":"字段数据缓存设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/field_data_cache_settings#缓存大小","content":"缓存中的条目构建成本很高，因此默认行为是将缓存加载到内存中。默认缓存大小是无限的，这会导致缓存增长，直到字段数据断路器设置的限制。此行为可配置。 如果设置了缓存大小限制，缓存将开始清除缓存中最近更新最少的条目。此设置可以自动避免断路器限制，代价是按需重建缓存。 如果达到断路器限制，将阻止会增加缓存大小的更多请求。在这种情况下，你应该手动清除缓存。 indices.fielddata.cache.size (静态)字段数据缓存的最大大小，例如节点堆空间的 38%，或绝对值，例如 12GB。默认为无界。如果你选择设置它，它应该小于字段数据断路器限制。 ","version":"Next","tagName":"h2"},{"title":"监控字段数据​","type":1,"pageTitle":"字段数据缓存设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/field_data_cache_settings#监控字段数据","content":"你可以使用节点统计 API 或 cat 字段数据 API 监视字段数据的内存使用情况以及字段数据断路器。 原文链接 ","version":"Next","tagName":"h2"},{"title":"Elasticsearch 中的健康诊断设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/health_diagnostic_settings_in_elasticsearch","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"集群级设置​","type":1,"pageTitle":"Elasticsearch 中的健康诊断设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/health_diagnostic_settings_in_elasticsearch#集群级设置","content":"health.master_history.has_master_lookup_timeframe (静态)节点在继续进行其他检查之前，回顾是否观察到主节点的时间。默认为 30s（30秒）。 master_history.max_age (静态)我们记录用于诊断集群健康状况的主历史记录的时间范围。诊断集群运行状况时，不会考虑早于此时间的主节点更改。默认为 30m（30分钟）。 health.master_history.identity_changes_threshold (静态)节点见证的，表示集群不健康的主标识变更数。默认为 4。 health.master_history.no_master_transitions_threshold (静态)节点见证的，表示集群不健康的转换为无主节点的次数。默认为 4。 health.node.enabled (动态)启用健康节点，这允许健康 API 提供有关集群范围健康方面（如磁盘空间）的指示。 health.reporting.local.monitor.interval (动态)确定集群的每个节点，监视其本地健康情况（如磁盘使用情况）的间隔时间。 原文链接 ","version":"Next","tagName":"h2"},{"title":"Elasticsearch 索引生命周期管理设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_lifecycle_management_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"集群级设置​","type":1,"pageTitle":"Elasticsearch 索引生命周期管理设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_lifecycle_management_settings#集群级设置","content":"xpack.ilm.enabled (静态，布尔值)[~7.0.0~] 此不推荐使用的设置已无效，将在 Elasticsearch 8.0 中删除。 indices.lifecycle.history_index_enabled (动态，布尔值)是否启用 ILM 的历史索引。如果启用，ILM 将把作为 ILM 策略一部分采取的操作的历史记录记录到 ilm-history-* 索引中。默认为 true。 indices.lifecycle.poll_interval (动态，时间单位值)索引生命周期管理检查符合策略条件的索引的频率。默认为 10m。 indices.lifecycle.rollover.only_if_has_documents (动态，布尔值)ILM 是否只滚动非空索引。如果启用，ILM 将只滚动索引，只要索引至少包含一个文档。默认为 true。 ","version":"Next","tagName":"h2"},{"title":"索引级设置​","type":1,"pageTitle":"Elasticsearch 索引生命周期管理设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_lifecycle_management_settings#索引级设置","content":"这些索引级 ILM 设置通常通过索引模板进行配置。有关详细信息，参阅创建生命周期策略。 index.lifecycle.indexing_complete (动态，布尔值)指示索引是否已翻转。ILM 完成翻转操作时自动设置为 true。可以将其显式设置为跳过翻转。默认为 false。 index.lifecycle.name (动态，字符串)用于管理索引的策略的名称。有关 Elasticsearch 如何应用策略更改的信息，参阅策略更新。如果要从以前由索引生命周期管理管理的快照恢复索引，则可以在恢复操作期间将此设置覆盖为空，以禁用对索引的进一步管理。参阅 index.lifecycle.rollover_alias。 index.lifecycle.origination_date (动态，长整型)如果指定，这是用于计算其相变的索引年龄的时间戳。如果创建包含旧数据的新索引并希望使用原始创建日期计算索引年限，请使用此设置。以毫秒为单位指定为 Unix epoch 值。 index.lifecycle.parse_origination_date (动态，布尔值)设置为 true 可从索引名称解析起始日期。该起始日期用于计算其相变的索引年龄。索引名称必须匹配模式 ^.*-{date_format}-\\\\d+，其中 date_format 为 yyyy.MM.dd，尾随数字是可选的。滚动的索引通常与完整格式匹配，例如 logs-2016.10.31-000002。如果索引名称与模式不匹配，则索引创建失败。 index.lifecycle.step.wait_time_threshold (动态，时间单位值)等待群集在 ILM 收缩操作期间解决分配问题的时间。必须大于 1h（1小时）。默认为 12h（12小时）。参阅用于收缩的分片分配。 index.lifecycle.rollover_alias (动态，字符串)索引滚动时要更新的索引别名。指定何时使用包含滚动操作的策略。当索引翻转时，别名将更新以反映索引不再是写索引。有关翻转索引的详细信息，参阅翻转。如果要从以前由索引生命周期管理管理的快照恢复索引，则可以在恢复操作期间将此设置覆盖为空，以禁用对未来索引的进一步管理。参阅 index.lifecycle.name。 原文链接 ","version":"Next","tagName":"h2"},{"title":"索引管理设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_management_settings","content":"索引管理设置 你可以使用以下集群设置来启用或禁用索引管理功能。 action.auto_create_index 动态如果索引还不存在将自动创建索引并应用任何配置的索引模板。默认为 true。 action.destructive_requires_name (动态设置为 true 时，必须指定索引名称以删除索引。不可能删除所有带 _all 的索引或使用通配符。默认为 true。 cluster.indices.close.enable (动态允许关闭 Elasticsearch 中的开放索引。如果为 false，则无法关闭打开的索引。默认为 true。 注意 关闭的索引仍然占用大量磁盘空间。 reindex.remote.whitelist (静态指定可以从远程重索引的主机。期望它为 host:port 字符串的 YAML 数组。由逗号分隔的 host:port 条目列表组成。默认值为 [&quot;\\*.io:*&quot;，&quot;\\*.com:*&quot;]。 stack.templates.enabled (动态如果为 true，则启用内置索引和组件模板。Elastic Agent 使用这些模板创建数据流。如果为 false，Elasticsearch 将禁用这些索引和组件模板。默认为 true。 此设置影响以下内置索引模板： logs-*-*metrics-*-*synthetics-*-* 此设置也影响以下内置的组件模板： logs-mappingslogs-settingsmetrics-mappingsmetrics-settingssynthetics-mappingsynthetics-settings 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引缓存区设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/indexing_buffer_settings","content":"索引缓存区设置 索引缓冲区用于存储新索引的文档。当它填满时，缓冲区中的文档将写入磁盘上的一个段。它在节点上的所有分片之间划分。 以下设置是静态的，必须在集群中的每个数据节点上配置： indices.memory.index_buffer_size (静态接受百分比或字节大小值。它默认为 10%，这意味着分配给节点的总堆的 10% 将用作所有分片共享的索引缓冲区大小。 indices.memory.min_index_buffer_size (静态如果将 index_buffer_size 指定为百分比，则可以使用此设置指定绝对最小值。默认值为 48mb。 indices.memory.max_index_buffer_size (静态如果将 index_buffer_size 指定为百分比，则可以使用此设置指定绝对最大值。默认为未限定。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"索引恢复设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_recovery_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"恢复设置​","type":1,"pageTitle":"索引恢复设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_recovery_settings#恢复设置","content":"indices.recovery.max_bytes_per_sec （动态）限制每个节点的总入站和出站恢复流量。适用于对等恢复和快照恢复（即从快照恢复）。默认值为 40mb，除非节点是专用冷节点或冻结节点，在这种情况下，默认值与节点可用的总内存有关： 总内存\t在冷节点或冻结节点默认恢复率≤ 4 GB\t40 MB/s &gt; 4 GB and ≤ 8 GB\t60 MB/s &gt; 8 GB and ≤ 16 GB\t90 MB/s &gt; 16 GB and ≤ 32 GB\t125 MB/s &gt; 32 GB\t250 MB/s 此限制分别适用于每个节点。如果集群中的多个节点同时执行恢复，则集群的总恢复流量可能会超过此限制。 如果此限制太高，则正在进行的恢复可能会消耗过多的带宽和其他资源，这可能会破坏集群的稳定。 这是一个动态设置，这意味着你可以在每个节点的 elasticsearch.yml 配置文件中设置它，并且可以使用集群更新设置 API 动态更新它。如果动态设置，那么集群中的每个节点都会受到相同的限制。如果不动态设置，则可以在每个节点上设置不同的限制，这在某些节点的带宽比其他节点的带宽更好时非常有用。例如，如果你使用的是索引生命周期管理，那么你可以为热门节点提供比温和节点更高的恢复带宽限制。 ","version":"Next","tagName":"h2"},{"title":"专家对待恢复设置​","type":1,"pageTitle":"索引恢复设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_recovery_settings#专家对待恢复设置","content":"你可以使用以下expert（专家）设置来管理对等恢复的资源。 indices.recovery.max_concurrent_file_chunks （动态，专家）为每次恢复并行发送的文件块数。默认值为 2。 当单个分片的恢复未达到 indices.recovery.max_bytes_per_sec 设置的流量限制，可以增加此值，最大值为 8。 indices.recovery.max_concurrent_operations （动态，专家）每个恢复并行发送的操作数。默认值为 1。 在恢复过程中并发重放操作可能非常耗费资源，并且可能会干扰集群中的索引、搜索和其他活动。如果没有仔细验证集群是否有足够的资源来处理将导致的额外负载，请不要增加此设置。 indices.recovery.use_snapshots （动态，专家）启用基于快照的对等恢复。 Elasticsearch 使用对等恢复过程恢复副本并重新定位主分片，这涉及在目标节点上构建碎片的新副本。当标记恢复时。use_snapshots 为false, Elasticsearch 将通过从当前主节点传输索引数据来构建此新副本。如果此设置为 true，Elasticsearch 将首先尝试从最近的快照复制索引数据，如果无法识别合适的快照，则仅从主快照复制数据。默认为 true。 如果集群在节点到节点的数据传输成本高于从快照恢复数据的成本的环境中运行，则将此选项设置为 true 可降低操作成本。它还减少了主服务器在恢复期间必须完成的工作量。 此外，在恢复分片时，将参考设置为 use_for_peer_recovery=true 的仓库以找到一个好的快照。如果没有注册的仓库定义了此设置，则将从源节点恢复索引文件。 indices.recovery.max_concurrent_snapshot_file_downloads （动态，专家）为每次恢复并行发送到目标节点的快照文件下载请求数。默认值为 5。 如果没有仔细验证集群是否有足够的资源来处理将导致的额外负载，请不要增加此设置。 indices.recovery.max_concurrent_snapshot_file_downloads_per_node （动态，专家）在目标节点中为所有恢复并行执行的快照文件下载请求数。默认值为 25。 如果没有仔细验证集群是否有足够的资源来处理将导致的额外负载，请不要增加此设置。 ","version":"Next","tagName":"h2"},{"title":"托管服务的恢复设置​","type":1,"pageTitle":"索引恢复设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/index_recovery_settings#托管服务的恢复设置","content":"注意 此功能旨在供 Elasticsearch Service、ElasticCloud Enterprise 和 Kubernetes 上的 Elasticcloud 间接使用。不支持直接使用。 将 Elasticsearch 作为托管服务运行时，以下设置允许服务为每个节点上的磁盘读取、磁盘写入和网络流量指定绝对最大带宽，并允许你根据这些绝对最大值控制每个节点上最大恢复带宽。它们有两个效果： 如果未设置 indices.recovery.max_bytes_per_sec，它们将确定用于恢复的带宽，覆盖上述默认行为。它们对恢复带宽施加了节点范围的限制，这与 indices.recovery.max_bytes_per_sec 的值无关。 如果未设置 indices.recovery.max_bytes_per_sec，则将最大恢复带宽计算为绝对最大带宽的一部分。读取和写入流量分别执行计算。该服务使用 node.bandwidth.recovery.disk.read、node.bandwidth.recovery.disk.write 和 node.bandwidth.recovery.network 定义磁盘读取、磁盘写入和网络传输的绝对最大带宽，你可以通过调整 node.bandwidth.recovery.factor.read 和 node.bandwidth.recovery.factor.write 来设置可用于恢复的绝对最大带宽的比例。如果启用了操作员权限功能，则服务还可以使用这些设置的仅操作员变体设置默认比例。 如果设置 indices.recovery.max_bytes_per_sec，则 Elasticsearch 将使用其值作为最大恢复带宽，只要这不超过节点范围的限制。Elasticsearch 通过将绝对最大带宽乘以 node.bandwidth.recovery.operator.factor.max_overcommit 因子来计算节点宽度限制。如果将 indices.recovery.max_bytes_per_sec 设置为超出节点范围限制，则节点范围限制优先。 服务应该通过实验确定绝对最大带宽设置的值，使用类似于恢复的工作负载，其中有几个并发工作器，每个工作器以 512kiB 的块顺序处理文件。 node.bandwidth.recovery.disk.read （每秒字节值）节点上类似恢复的工作负载的绝对最大磁盘读取速度。如果设置了它，node.bandwidth.recovery.disk.write 和 node.bandwidth.recovery.network 也必须设置。 node.bandwidth.recovery.disk.write （每秒字节值）节点上类似恢复的工作负载的绝对最大磁盘写入速度。如果设置了它，node.bandwidth.recovery.disk.read 和 node.bandwidth.recovery.network 也必须设置。 node.bandwidth.recovery.network （每秒字节值）节点上类似恢复的工作负载的绝对最大磁盘写入速度节点上类似于恢复的工作负荷的绝对最大网络吞吐量，适用于读取和写入。如果设置了它，node.bandwidth.recovery.disk.read 和 node.bandwidth.recovery.write 也必须设置。 node.bandwidth.recovery.factor.read （浮点数，动态）如果 indices.recovery.max_bytes_per_sec 和 node.bandwidth.recovery.factor.write 可用于恢复的最大写入带宽的比例。必须大于 0，小于等于 1。如果未设置，将会使用 node.bandwidth.recovery.operator.factor。如果未设置因子设置，则使用值 0.4。启用操作员权限功能后，此设置只能由操作员用户更新。 node.bandwidth.recovery.operator.factor （浮点数，动态）如果 indices.recovery.max_bytes_per_sec 或其他任何因子都未设置，则为可用于恢复的最大带宽比例。必须大于 0，小于等于 1。默认为 0.4。启用操作员权限功能后，此设置只能由操作员用户更新。 node.bandwidth.recovery.operator.factor.max_overcommit （浮点数，动态）无论任何其他设置如何，可用于恢复的绝对最大带宽比例。必须大于 0。默认为 100。启用操作员权限功能后，此设置只能由操作员用户更新。 原文链接 ","version":"Next","tagName":"h2"},{"title":"重要的 Elasticsearch 配置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"路径设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#路径设置","content":"Elasticsearch 将索引的数据写入索引，并将数据流写入数据目录。Elasticsearch 将自己的应用程序日志写入日志目录，其中包含有关集群运行状况和操作的信息。 对于 macOS .tar.gz，Linux .tar.gz 和 Windows .zip 安装，data 和 logs 默认是 $ES_HOME 的子目录。然而，$ES_HOME 中的文件可能在升级过程中被删除。 在生产中，我们强烈建议你设置 elasticsearch.yml 中的 path.data 和 path.logs 在 $ES_HOME 之外的位置。默认情况下，Docker、Debian 和 RPM 安装将数据和日志写入 $ES_HOME 之外的位置。 支持的 path.data和 path.logs。值因平台而异： 类 Unix 系统 Linux 和 macOS 安装支持 Unix 风格的路径： path: data: /var/data/elasticsearch logs: /var/log/elasticsearch  Windows Windows 安装支持带转义反斜杠的 DOS 路径： path: data: &quot;C:\\\\Elastic\\\\Elasticsearch\\\\data&quot; logs: &quot;C:\\\\Elastic\\\\Elasticsearch\\\\logs&quot;  重要 不要修改数据目录中的任何内容或运行可能会干扰其内容的进程。如果 Elasticsearch 以外的其他内容修改了数据目录的内容，则 Elasticsearch 可能会失败，报告损坏或其他数据不一致，或者可能在默默丢失部分数据后正常工作。不要尝试对数据目录进行文件系统备份；不支持还原此类备份的方法。相反，请使用快照和还原来安全地进行备份。不要在数据目录上运行病毒扫描程序。病毒扫描程序可能会阻止 Elasticsearch 正常工作，并可能会修改数据目录的内容。数据目录不包含可执行文件，因此病毒扫描只会发现误报。 ","version":"Next","tagName":"h2"},{"title":"多数据路径​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#多数据路径","content":"重要 7.13.0 版本已弃用 如果需要，可以在 path.data 中指定多个路径。Elasticsearch 跨所有提供的路径存储节点的数据，但将每个分片的数据保持在同一路径上。 Elasticsearch 不平衡节点数据路径上的分片。单个路径中的高磁盘使用率可以触发整个节点的高磁盘利用率水印。如果触发，Elasticsearch 将不会向节点添加分片，即使节点的其他路径具有可用磁盘空间。如果需要额外的磁盘空间，建议你添加新节点，而不是其他数据路径。 类 Unix 系统 Linux 和 macOS 安装支持 path.data 中的多个 Unix 样式路径： path: data: - /mnt/elasticsearch_1 - /mnt/elasticsearch_2 - /mnt/elasticsearch_3  Windwos Windows 安装支持 path.data 中的多个 DOS 路径： path: data: - &quot;C:\\\\Elastic\\\\Elasticsearch_1&quot; - &quot;E:\\\\Elastic\\\\Elasticsearch_1&quot; - &quot;F:\\\\Elastic\\\\Elasticsearch_3&quot;  ","version":"Next","tagName":"h2"},{"title":"从多个数据路径迁移​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#从多个数据路径迁移","content":"支持多数据路径在 7.13 中已被弃用，并将在未来版本中删除。 作为多数据路径的替代方案，你可以使用硬件虚拟化层（如 RAID）或软件虚拟化层，如 Linux 上的逻辑卷管理器（LVM）或 Windows 上的存储空间，创建跨越多个磁盘的文件系统。如果希望在一台计算机上使用多个数据路径，则必须为每个数据路径运行一个节点。 如果当前在高可用集群中使用多个数据路径，则可以迁移到为每个节点使用单一路径的设置，而无需使用类似于滚动重启的过程进行停机：依次关闭每个节点，并将其替换为一个或多个节点，每个节点都配置为使用单一数据路径。更详细地说，对于当前具有多个数据路径的每个节点，应遵循以下过程。原则上，你可以在滚动升级到 8.0 期间执行此迁移，但我们建议在开始升级之前迁移到单个数据路径设置。 创建快照以在发生灾难时保护你的数据。 可选地，通过使用分配过滤器将数据从目标节点迁移： PUT _cluster/settings { &quot;persistent&quot;: { &quot;cluster.routing.allocation.exclude._name&quot;: &quot;target-node-name&quot; } }  你可以使用 cat 分配 API 跟踪数据迁移的进度。如果一些分片没有迁移，那么集群分配解释 API 将帮助你确定原因。 按照滚动重启过程中的步骤操作，直到关闭目标节点。 确保集群运行状况为 yellow（黄色）或 green（绿色），以便有分配给集群中至少一个其他节点的每个分片的副本。 如果适用，请删除前面步骤中应用的分配筛选器。 PUT _cluster/settings { &quot;persistent&quot;: { &quot;cluster.routing.allocation.exclude._name&quot;: null } }  通过删除已停止节点的数据路径的内容，丢弃已停止节点持有的数据。 重新配置存储。例如，使用LVM或存储空间将磁盘合并到单个文件系统中。确保重新配置的存储具有足够的空间来存放数据。 通过调整 elasticsearch.yml 文件中的 path.data 设置重新配置节点。如果需要，安装更多节点，每个节点都有自己的 path.data 设置指向单独数据路径。 启动新节点，并对其执行其余的滚动重启过程过程。 确保集群运行状况为绿色，以便已分配每个分片。 你也可以向集群添加一些单数据路径节点，使用分配过滤器将所有数据迁移到这些新节点，然后从集群中删除旧节点。这种方法将使集群的大小临时增加一倍，因此只有在你有能力这样扩展集群的情况下，它才能工作。 如果你当前使用多个数据路径，但你的群集不是高度可用的，则可以通过创建快照，再创建具有所需配置的新集群并将快照还原到其中，用以迁移到非弃用配置。 ","version":"Next","tagName":"h2"},{"title":"集群名设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#集群名设置","content":"节点只能在加入集群后，向集群中其他所有节点共享其 cluster.name。默认名称是 elasticsearch，但你应该将其更改为描述集群用途的适当名称。 cluster.name: logging-prod  不要在不同的环境中重用相同的集群名称。否则，节点可能加入错误的集群。 ","version":"Next","tagName":"h2"},{"title":"节点名设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#节点名设置","content":"Elasticsearch 使用 node.name 作为 Elasticsearch 特定实例的可读标识符。此名称包含在许多 API 的响应中。节点名称默认为 Elasticsearch 启动时机器的主机名，但可以在 elasticsearch.yml 中显式配置： node.name: prod-data-2  ","version":"Next","tagName":"h2"},{"title":"网络主机设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#网络主机设置","content":"默认情况下，Elasticsearch 仅绑定到回环地址，如 127.0.0.1 和 [：：1]。这足以在单个服务器上运行一个或多个节点的集群进行开发和测试，但弹性生产集群必须涉及其他服务器上的节点。有许多网络设置，但通常只需要配置 network.host： network.host: 192.168.1.10  重要 当你提供 network.host 值，Elasticsearch 假设你正在从开发模式转移到生产模式，并将大量系统启动检查从警告升级为异常。查看开发和生产模式之间的差异。 ","version":"Next","tagName":"h2"},{"title":"发现和集群构成设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#发现和集群构成设置","content":"在投入生产之前，配置两个重要的发现和群集形成设置，以便群集中的节点可以相互发现并选择主节点。 discovery.seed_hosts 开箱即用，无需任何网络配置，Elasticsearch 将绑定到可用的环回地址，并扫描本地端口 9300 至 9305，以与运行在同一服务器上的其他节点连接。这种行为提供了一种无需进行任何配置的自动集群体验。 当你希望与其他主机上的节点组成集群时，请使用静态 discovery.seed_hosts 设置。此设置提供群集中其他节点的列表，这些节点具有主资格，并且可能处于活动状态，并且可以联系以启动发现过程。此设置接受集群中所有主合格节点的 YAML 序列或地址数组。每个地址可以是 IP 地址，也可以是通过 DNS 解析为一个或多个 IP 地址的主机名。 discovery.seed_hosts: - 192.168.1.10:9300 - 192.168.1.11 - seeds.mydomain.com - [0:0:0:0:0:ffff:c0a8:10c]:9301  192.168.1.11：端口可选，默认为 9300，但可以被覆盖。 seeds.mydomain.com：如果主机名解析为多个 IP 地址，则节点将尝试在所有解析的地址发现其他节点。 [0:0:0:0:0:ffff:c0a8:10c]:9301：IPv6 地址必须用方括号括起来。 如果符合主节点条件的节点没有固定名称或地址，请使用备用主机提供程序动态查找其地址。 cluster.initial_master_nodes 首次启动 Elasticsearch 集群时，群集引导步骤将确定在第一次选举中计算其投票的主合格节点集。在开发模式下，如果未配置发现设置，此步骤将由节点自己自动执行。 由于自动引导原生不安全，因此在生产模式下启动新集群时，必须明确列出在第一次选举中应计算其投票的主合格节点。你可以使用 cluster.initial_master_nodes 设置此列表。 重要 集群首次成功形成后，删除每个节点配置中的 cluster.initial_master_nodes 设置。重新启动集群或向现有集群添加新节点时，不要使用此设置。 discovery.seed_hosts: - 192.168.1.10:9300 - 192.168.1.11 - seeds.mydomain.com - [0:0:0:0:0:ffff:c0a8:10c]:9301 cluster.initial_master_nodes: - master-node-a - master-node-b - master-node-c  cluster.initial_master_nodes：按他们的 node.name 标识初始主节点，默认为其主机名。确保 cluster.initial_master_nodes 中的值与 node.name 完全匹配。如果使用完全限定域名（FQDN），例如 master-node-a.example.com 作为节点名称，则必须使用此列表中的 FQDN。相反，如果 node.name 是一个没有任何尾部限定符的裸主机名，你还必须省略 cluster.initial_master_nodes 中的尾部限定符。 参阅引导集群以及发现和集群构成设置。 ","version":"Next","tagName":"h2"},{"title":"堆大小设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#堆大小设置","content":"默认情况下，Elasticsearch 根据节点的角色和总内存自动设置 JVM 堆大小。我们建议大多数生产环境使用默认大小。 如果需要，可以通过手动设置 JVM 堆大小来覆盖默认大小。 ","version":"Next","tagName":"h2"},{"title":"JVM 堆转储路径设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#jvm-堆转储路径设置","content":"默认情况下，Elasticsearch 将 JVM 配置为将内存不足异常的堆转储到默认数据目录。在 RPM 和 Debian 软件包中，数据目录是 /var/lib/elasticsearch。在Linux 和 MacOS 及 Windows 发行版上，data 目录位于 Elasticsearch 安装的根目录下。 如果此路径不适合接收堆转储，请修改 jvm.options 中的 -XX:HeapDumpPath=… 条目： 如果指定目录，JVM 将根据运行实例的 PID 为堆转储生成文件名。 如果指定固定文件名而不是目录，则当 JVM 需要对内存不足异常执行堆转储时，该文件必须不存在。否则，堆转储将失败。 ","version":"Next","tagName":"h2"},{"title":"GC 日志设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#gc-日志设置","content":"默认情况下，Elasticsearch 启用垃圾收集（GC）日志。这些是在 jvm.options 中配置的，并输出到与 Elasticsearch 日志相同的默认位置。默认配置每 64 MB 旋转一次日志，最多可消耗 2 GB 的磁盘空间。 你可以使用JEP 158：统一 JVM 日志中描述的命令行选项重新配置 JVM 日志。除非更改默认 jvm.options 文件中，除了你自己的设置之外，还将应用 Elasticsearch 默认配置。要禁用默认配置，首先通过提供 -Xlog:disable 选项禁用日志记录，然后提供你自己的命令行选项。这将禁用所有 JVM 日志记录，因此请确保查看可用选项并启用所需的所有功能。 要查看原始 JEP 中未包含的其他选项，参阅使用 JVM 统一日志框架启用日志。 ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#示例","content":"使用一些示例选项，通过创建 $ES_HOME/config/jvm.options.d/gc.options 来变更默认 GC 日志输出路径为 /opt/my-app/gc.log： # Turn off all previous logging configuratons -Xlog:disable # Default settings from JEP 158, but with `utctime` instead of `uptime` to match the next line -Xlog:all=warning:stderr:utctime,level,tags # Enable GC logging to a custom location with a variety of options -Xlog:gc*,gc+age=trace,safepoint:file=/opt/my-app/gc.log:utctime,pid,tags:filecount=32,filesize=64m  配置 Elasticsearch Docker 容器，将 GC 调试日志发送到标准错误（stderr）。这允许容器编排器处理输出。如果使用 CLI_JAVA_OPTS 环境变量，请指定： MY_OPTS=&quot;-Xlog:disable -Xlog:all=warning:stderr:utctime,level,tags -Xlog:gc=debug:stderr:utctime&quot; docker run -e CLI_JAVA_OPTS=&quot;$MY_OPTS&quot; # etc  ","version":"Next","tagName":"h2"},{"title":"临时目录设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#临时目录设置","content":"默认情况下，Elasticsearch 使用启动脚本在系统临时目录下创建的私有临时目录。 在某些 Linux 发行版上，如果文件和目录最近未被访问，系统实用程序将从 /tmp 中清除这些文件和目录。如果长时间未使用需要临时目录的功能，则此行为可能导致在Elasticsearch运行时删除专用临时目录。如果随后使用需要此目录的功能，则删除专用临时目录会导致问题。 如果使用 .deb 或 .rpm 软件包安装 Elasticsearch 并在 systemd 下运行，Elasticsearch 使用的私有临时目录将被排除在定期清理之外。 如果你打算运行 .tar.gz 在 Linux 或 MacOS 上的长期发行版，请考虑为 Elasticsearch 创建一个专用的临时目录，该目录不在将清除旧文件和目录的路径下。该目录应设置权限，以便只有运行 Elasticsearch 的用户才能访问该目录。然后，在启动 Elasticsearch 之前，将 $ES_TMPDIR 环境变量设置为指向该目录。 ","version":"Next","tagName":"h2"},{"title":"JVM 致命错误日志设置​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#jvm-致命错误日志设置","content":"默认情况下，Elasticsearch 将 JVM 配置为将致命错误日志写入默认日志目录。在 RPM 和 Debian 软件包中，这个目录是 /var/log/elasticsearch。在 Linux 和 MacOS 和 Windows 发行版上，日志目录位于 Elasticsearch 安装的根目录下。 这些是 JVM 遇到致命错误（如分段错误）时生成的日志。如果此路径不适合接收日志，请修改 jvm.options 中的 -XX:ErrorFile=… 条目。 ","version":"Next","tagName":"h2"},{"title":"集群备份​","type":1,"pageTitle":"重要的 Elasticsearch 配置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/import_elasticsearch_configuration#集群备份","content":"在灾难中，快照可以防止永久数据丢失。快照生命周期管理是对集群进行定期备份的最简单方法。有关详细信息，参阅创建快照。 警告 快照是备份集群的唯一可靠且受支持的方法。你无法通过复制 Elasticsearch 集群节点的数据目录来备份该集群。不支持从文件系统级备份中恢复任何数据的方法。如果尝试从这样的备份中恢复集群，它可能会失败，并报告损坏或丢失文件或其他数据不一致，或者它似乎成功又悄悄地丢失了一些数据。 原文链接 ","version":"Next","tagName":"h2"},{"title":"本地网关设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/local_gateway_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"悬空索引​","type":1,"pageTitle":"本地网关设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/local_gateway_settings#悬空索引","content":"当节点加入集群时，如果发现存储在其本地数据目录中的任何碎片在集群中尚不存在，则会认为这些分片属于“悬空”索引。你可以使用悬空索引 API 列出、导入或删除悬空索引。 注意 当索引仍然是集群的一部分时，API 无法保证导入的数据是否真正代表数据的最新状态。 原文链接 ","version":"Next","tagName":"h2"},{"title":"授权设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/license_settings","content":"授权设置 你可以在 elasticsearch.yml 文件中配置此许可设置。有关详细信息，参阅授权管理。 xpack.license.self_generated.type (静态设置为 basic（默认）以启用基本 X-Pack特性。 如果设置为 trial，自动生成的授权仅允许在 30 天内访问 x-pack 的所有功能。如果需要，你可以稍后将集群降级为基本授权。 原文链接","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"日志","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/logging","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"日志配置​","type":1,"pageTitle":"日志","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/logging#日志配置","content":"重要 Elastic 强烈建议使用默认提供的 Log4j 2 配置。 Elasticsearch 使用 Log4j 2 进行日志记录。可以使用 log4j2.properties 文件配置 Log4j 2。Elasticsearch 暴露了三个属性，${sys:es.logs.base_path}、${sys:es.logs.cluster_name} 和 ${sys:es.logs.node_name}，它们可以在配置文件中引用以确定日志文件的位置。属性 ${sys:es.logs.base_path} 会解析为日志目录，${sys:es.logs.cluster_name} 会解析为集群名字（在默认配置中用作日志文件名的前缀），以及 ${sys:es.logs.node_name} 会解析为节点名字（如果显示设置了节点名字）。 例如，如果你的日志目录（path.logs）是 /var/log/elasticsearch 且你的集群被命名为 production 那么 ${sys:es.logs.base_path} 会解析为 /var/log/elasticsearch，并且 ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}.log 会解析为 /var/log/elasticsearch/production.log。 ######## Server JSON ############################ appender.rolling.type = RollingFile appender.rolling.name = rolling appender.rolling.fileName = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}_server.json appender.rolling.layout.type = ECSJsonLayout appender.rolling.layout.dataset = elasticsearch.server appender.rolling.filePattern = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}-%d{yyyy-MM-dd}-%i.json.gz appender.rolling.policies.type = Policies appender.rolling.policies.time.type = TimeBasedTriggeringPolicy appender.rolling.policies.time.interval = 1 appender.rolling.policies.time.modulate = true appender.rolling.policies.size.type = SizeBasedTriggeringPolicy appender.rolling.policies.size.size = 256MB appender.rolling.strategy.type = DefaultRolloverStrategy appender.rolling.strategy.fileIndex = nomax appender.rolling.strategy.action.type = Delete appender.rolling.strategy.action.basepath = ${sys:es.logs.base_path} appender.rolling.strategy.action.condition.type = IfFileName appender.rolling.strategy.action.condition.glob = ${sys:es.logs.cluster_name}-* appender.rolling.strategy.action.condition.nested_condition.type = IfAccumulatedFileSize appender.rolling.strategy.action.condition.nested_condition.exceeds = 2GB ################################################  appender.rolling.type = RollingFile：配置 RollingFile 附加器appender.rolling.fileName = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}_server.json：记录日志到 /var/log/elasticsearch/production_server.jsonappender.rolling.layout.type = ECSJsonLayout：使用 JSON 布局appender.rolling.layout.dataset = elasticsearch.server：dataset 是填充事件的标志。ECSJsonLayout 中的数据集字段。它可以用于在解析日志时更容易地区分不同类型的日志。appender.rolling.filePattern = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}-%d{yyyy-MM-dd}-%i.json.gz：将日志滚动到 /var/log/lelasticsearch/production-yyyy-MM-dd-i.json；日志将在每个卷上压缩，i 将递增appender.rolling.policies.time.type = TimeBasedTriggeringPolicy： 使用基于时间的滚动策略appender.rolling.policies.time.interval = 1：每天滚动日志appender.rolling.policies.time.modulate = true：在白天边界上对齐滚动（而不是每 24 小时滚动一次）appender.rolling.policies.size.type = SizeBasedTriggeringPolicy：使用基于大小的滚动策略appender.rolling.policies.size.size = 256MB：256 MB 后滚动日志appender.rolling.strategy.action.type = Delete：滚动日志时使用删除操作appender.rolling.strategy.action.condition.type = IfFileName：仅删除与文件模式匹配的日志appender.rolling.strategy.action.condition.glob = ${sys:es.logs.cluster_name}-*：模式是只删除主日志appender.rolling.strategy.action.condition.nested_condition.type = IfAccumulatedFileSize：仅当我们累积了太多压缩日志时才删除appender.rolling.strategy.action.condition.nested_condition.exceeds = 2GB：压缩日志的大小条件为 2 GB ######## Server - old style pattern ########### appender.rolling_old.type = RollingFile appender.rolling_old.name = rolling_old appender.rolling_old.fileName = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}_server.log appender.rolling_old.layout.type = PatternLayout appender.rolling_old.layout.pattern = [%d{ISO8601}][%-5p][%-25c{1.}] [%node_name]%marker %m%n appender.rolling_old.filePattern = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}-%d{yyyy-MM-dd}-%i.old_log.gz  appender.rolling_old.fileName = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}_server.log：old style 附加器的配置。这些日志将保存在 *.log 文件中，如果压缩，将在 * .log.gz 文件中。请注意，这些应被视为已弃用，将来将被删除。 注意 Log4j 的配置解析被任何无关的空格所混淆；如果复制并粘贴此页面上的任何 Log4j 设置，或输入任何 Log4j 配置，请确保删除任何前导和尾随空格。 注意，在 appender.rolling.filePattern 使用 .zip 格式替代 .gz 以通过 zip 格式压缩滚动日志。如果删除 .gz 扩展名，则日志在滚动时不会被压缩。 如果要在指定的时间段内保留日志文件，可以使用滚动策略和删除操作。 appender.rolling.strategy.type = DefaultRolloverStrategy appender.rolling.strategy.action.type = Delete appender.rolling.strategy.action.basepath = ${sys:es.logs.base_path} appender.rolling.strategy.action.condition.type = IfFileName appender.rolling.strategy.action.condition.glob = ${sys:es.logs.cluster_name}-* appender.rolling.strategy.action.condition.nested_condition.type = IfLastModified appender.rolling.strategy.action.condition.nested_condition.age = 7D  appender.rolling.strategy.type = DefaultRolloverStrategy：配置 DefaultRolloverStrategyappender.rolling.strategy.action.type = Delete：配置用于处理回滚的 Delete 操作appender.rolling.strategy.action.basepath = ${sys:es.logs.base_path}：Elasticsearch 日志的基本路径appender.rolling.strategy.action.condition.type = IfFileName：处理滚动时应用的条件appender.rolling.strategy.action.condition.glob = ${sys:es.logs.cluster_name}-*：从与 glob ${sys:es.logs.cluster_name}-* 匹配的基本路径中删除文件；这是日志文件滚动到的 glob；这不仅需要删除滚动的 Elasticsearch 日志，还需要删除弃用日志和慢日志appender.rolling.strategy.action.condition.nested_condition.type = IfLastModified：要应用于与 glob 匹配的文件的嵌套条件appender.rolling.strategy.action.condition.nested_condition.age = 7D：日志保留七天 可以加载多个配置文件（在这种情况下，它们将被合并），只要它们被命名为 log4j2.properties，并将 Elasticsearch 配置目录作为前驱；这对于暴露附加记录器的插件很有用。logger 部分包含 java 包及其相应的日志级别。appender 部分包含日志的目标。有关如何自定义日志记录和所有支持的附加程序的详细信息，可以在 Log4j 文档中找到。 ","version":"Next","tagName":"h2"},{"title":"配置日志级别​","type":1,"pageTitle":"日志","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/logging#配置日志级别","content":"Elasticsearch 源代码中的每个 Java 包都有一个相关的记录器。例如，org.elasticsearch.discovery 包有 logger.org.elasticsearch.discovery 用于与发现过程相关的日志。 要获取更多或更少的详细日志，请使用集群更新设置 API 更改相关记录器的日志级别。每个记录器都接受 Log4j 2 的内置日志级别，从最低到最详细：OFF、FATAL、ERROR、WARN、INFO、DEBUG 和 TRACE。默认日志级别为 INFO。以较高详细级别（DEBUG 和 TRACE）记录的消息仅供专家使用。 PUT /_cluster/settings { &quot;persistent&quot;: { &quot;logger.org.elasticsearch.discovery&quot;: &quot;DEBUG&quot; } }  更改日志级别的其他方法包括： elasticsearch.yml： logger.org.elasticsearch.discovery: DEBUG  在单个节点上调试问题时，这是最合适的。 log4j2.properties： logger.discovery.name = org.elasticsearch.discovery logger.discovery.level = debug  当你已经因为其他原因需要更改 Log4j 2 配置时，这是最合适的。例如，你可能希望将特定记录器的日志发送到另一个文件。然而，这些用例很少。 ","version":"Next","tagName":"h2"},{"title":"弃用的日志​","type":1,"pageTitle":"日志","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/logging#弃用的日志","content":"Elasticsearch 还将弃用日志写入日志目录。当你使用已弃用的 Elasticsearch功能时，这些日志会记录一条消息。在将 Elasticsearch 升级到新的主要版本之前，你可以使用弃用日志来更新应用程序。 默认情况下，Elasticsearch 以 1GB 的速度滚动和压缩弃用日志。默认配置最多保留五个日志文件：四个滚动日志和一个活动日志。 Elasticsearch 在 CRITICAL 级别发出弃用日志消息。这些消息表明，在下一个主要版本中将删除使用过的弃用功能。WARN 级别的弃用日志消息表明使用了一个不太关键的功能，它不会在下一个主要版本中删除，但可能会在将来删除。 要停止写入弃用日志消息，请设置 log4j2.properties 中的 logger.deprevention.level 为 OFF： logger.deprecation.level = OFF  或者，你可以动态更改日志记录级别： 参考配置日志级别 如果 X-Opaque-Id 用作 HTTP 头，你可以确定是什么触发了不推荐的功能。用户 ID 包含在弃用 JSON 日志的 X-Opaque-ID 字段中。 { &quot;type&quot;: &quot;deprecation&quot;, &quot;timestamp&quot;: &quot;2019-08-30T12:07:07,126+02:00&quot;, &quot;level&quot;: &quot;WARN&quot;, &quot;component&quot;: &quot;o.e.d.r.a.a.i.RestCreateIndexAction&quot;, &quot;cluster.name&quot;: &quot;distribution_run&quot;, &quot;node.name&quot;: &quot;node-0&quot;, &quot;message&quot;: &quot;[types removal] Using include_type_name in create index requests is deprecated. The parameter will be removed in the next major version.&quot;, &quot;x-opaque-id&quot;: &quot;MY_USER_ID&quot;, &quot;cluster.uuid&quot;: &quot;Aq-c-PAeQiK3tfBYtig9Bw&quot;, &quot;node.id&quot;: &quot;D7fUYfnfTLa2D7y-xw6tZg&quot; }  cluster.deprecation_indexing.enabled 设置被设置为 true，弃用日志可被索引到 .logs-deprecation.elasticsearch-default 数据流。 ","version":"Next","tagName":"h2"},{"title":"弃用日志限制​","type":1,"pageTitle":"日志","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/logging#弃用日志限制","content":"弃用日志基于弃用的功能键和 x-opaque-id 进行重复数据消除，这样，如果重复使用某个功能，则不会使弃用日志过载。这适用于索引的弃用日志和发送到日志文件的日志。通过将 luster.deprecation_indexing.x_opaque_id_used.enabled 更改为 false，你可以禁用在节流中使用 x-opaque-id。参阅 RateLimitingFilter。 ","version":"Next","tagName":"h2"},{"title":"JSON 日志格式​","type":1,"pageTitle":"日志","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/logging#json-日志格式","content":"为了更容易解析 Elasticsearch 日志，日志现在以 JSON 格式打印。这由 Log4J 布局属性 appender.rolling.layout.type=ECSJsonLayout 配置。此布局需要设置数据集属性，该属性用于在分析时区分日志流。 appender.rolling.layout.type = ECSJsonLayout appender.rolling.layout.dataset = elasticsearch.server  每行包含一个 JSON 文档，属性在 ECSJsonLayout 中配置。有关详细信息，参阅此类 javadoc。但是，如果 JSON 文档包含异常，则将在多行上打印。第一行将包含常规属性，随后的行将包含格式化为 JSON 数组的堆栈跟踪。 注意 你仍然可以使用自己的自定义布局。为此，使用不同的布局替换行 appender.rolling.layout。参见以下示例： appender.rolling.type = RollingFile appender.rolling.name = rolling appender.rolling.fileName = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}_server.log appender.rolling.layout.type = PatternLayout appender.rolling.layout.pattern = [%d{ISO8601}][%-5p][%-25c{1.}] [%node_name]%marker %.-10000m%n appender.rolling.filePattern = ${sys:es.logs.base_path}${sys:file.separator}${sys:es.logs.cluster_name}-%d{yyyy-MM-dd}-%i.log.gz  原文链接 ","version":"Next","tagName":"h2"},{"title":"Elasticsearch 中的机器学习设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/machine_learning_settings_in_elasticsearch","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"通用机器学习设置​","type":1,"pageTitle":"Elasticsearch 中的机器学习设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/machine_learning_settings_in_elasticsearch#通用机器学习设置","content":"node.roles: [ ml ] (静态）将 node.role 设置为包含 ml，以将该节点标识为机器学习节点。如果要运行机器学习作业，集群中必须至少有一个机器学习节点。 如果设置 node.role，则必须显式指定节点所需的所有角色。要了解更多信息，参阅节点。 :::danger 重要 在专用协调节点或专用主节点上，不要设置 ml 角色。强烈建议专用机器学习节点也具有 remote_cluster_client 角色；否则，在机器学习作业或数据反馈中使用跨集群搜索会失败。参阅远程合格节点。 ::: xpack.ml.enabled (静态）默认值（true）启用节点上的机器学习 API。 :::danger 重要 如果要在集群中使用机器学习功能，建议在所有节点上使用此设置的默认值。 ::: 如果设置为 false，则在节点上禁用机器学习 API。例如，节点无法打开作业、启动数据源、接收传输（内部）通信请求或来自客户端（包括 Kibana）的与机器学习 API 相关的请求。 xpack.ml.inference_model.cache_size (静态）允许的最大推测缓存大小。推测缓存存在于每个预处理节点上的 JVM 堆中。高速缓存为推测处理器提供了更快的处理时间。该值可以是静态字节大小的值（例如 2gb），也可以是总分配堆的百分比。默认为 40%。另参阅机器学习断路器设置。 xpack.ml.inference_model.time_to_live (静态）推理模型缓存中训练模型的生存时间（TTL）。TTL从上次访问开始计算。缓存的用户（例如推理处理器或推理聚合器）在第一次使用时缓存模型，并在每次使用时重置TTL。如果在TTL期间未访问缓存模型，则会将其标记为从缓存中逐出。如果稍后处理文档，则模型将再次加载到缓存中。要在Elasticsearch服务中更新此设置，参阅添加 Elasticsearch 用户设置。默认为 5m。 xpack.ml.max_inference_processors （动态）所有预处理管道中允许的 inference 类型处理器总数。一旦达到限制，就不允许向管道中添加 inference 处理器。默认值为 50。 xpack.ml.max_machine_memory_percent （动态）机器学习可用于运行分析过程的机器内存的最大百分比。这些进程与 Elasticsearch JVM 分离。该限制基于机器的总内存，而不是当前可用内存。如果这样做会导致机器学习作业的估计内存使用超过限制，则不会将作业分配给节点。启用操作员权限功能后，此设置只能由操作员用户更新。最小值为5；最大值为 200。默认值为 30。 :::tip 注意 不要将此设置配置为高于运行 Elasticsearch JVM 后剩余内存量的值，除非你有足够的 swap 空间来容纳它，并且确定这是适合于特定用例的配置。最大设置值适用于已确定为机器学习作业使用交换空间是可接受的特殊情况。一般的最佳实践是不要在 Elasticsearch 节点上使用 swap。 ::: xpack.ml.max_model_memory_limit （动态）可以为此集群中的任何机器学习作业设置的最大 model_memory_limit 属性值。如果尝试创建 model_memory_limit 属性值大于此设置值的作业，则会发生错误。更新此设置时，现有作业不受影响。如果此设置为 0 或未设置，则没有最大 model_memory_limit 值。如果没有满足作业内存要求的节点，那么缺少最大内存限制意味着可以创建无法分配给任何可用节点的作业。有关 model_memory_limit 属性的更多信息，参阅创建异常检测作业或创建数据帧分析作业。如果 xpack.ml.use_auto_machine_memory_percent 为 false，则默认为 0。如果 xpack.ml.use_auto_machine_memory_percent 为 true 且 xpack.ml.max_model_memory_limit 未显示设置，则它默认为可分配给集群的最大 model_memory_limit。 xpack.ml.max_open_jobs （动态）节点上可以同时运行的最大作业数。在这种情况下，作业包括异常检测作业和数据帧分析作业。作业的最大数量也受到内存使用的限制。因此，如果作业的估计内存使用率高于允许值，则节点上运行的作业将更少。在版本 7.1 之前，此设置是每个节点的非动态设置。在 7.1 版中，它成为了集群范围的动态设置。因此，只有在集群中的每个节点都运行 7.1 或更高版本后，才会在节点启动后对其值进行更改。最小值为 1；最大值为 512。默认值为 512。 xpack.ml.nightly_maintenance_requests_per_second （动态）夜间维护任务删除过期模型快照和结果的速率。该设置是按查询请求删除中使用的 requests_per_second 参数的代理，并控制节流。启用操作员权限功能后，此设置只能由操作员用户更新。有效值必须大于 0.0 或等于 -1.0，其中 -1.0 表示使用默认值。默认值为 -1.0。 xpack.ml.node_concurrent_job_allocations （动态）每个节点上可以同时处于 opening 状态的最大作业数。通常，工作在进入 open 状态之前会在这种状态下花费少量时间。必须在大型模型打开时恢复的工作在 opening 状态下花费更多时间。启用操作员权限功能后，此设置只能由操作员用户更新。默认值为 2。 ","version":"Next","tagName":"h2"},{"title":"高级机器学习设置​","type":1,"pageTitle":"Elasticsearch 中的机器学习设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/machine_learning_settings_in_elasticsearch#高级机器学习设置","content":"这些设置适用于高级用例；默认值通常足够： xpack.ml.enable_config_migration （动态）保留。启用操作员权限功能后，此设置只能由操作员用户更新。 xpack.ml.max_anomaly_records （动态）每个存储桶输出的最大记录数。默认值为 500。 xpack.ml.max_lazy_ml_nodes （动态）延迟启动的机器学习节点的数量。在第一个机器学习作业打开之前不需要机器学习节点的情况下有用。如果机器学习节点的当前数量大于或等于此设置，则假设没有更多的空闲节点可用，因为已经提供了所需数量的节点。如果作业已打开，并且此设置的值大于零，并且没有节点可以接受该作业，则该作业将保持在 OPENING 状态，直到将新的机器学习节点添加到集群，并将作业分配到该节点上运行。启用操作员权限功能后，此设置只能由操作员用户更新。默认值为 0。 :::danger 重要 此设置假定某些外部进程能够将机器学习节点添加到集群。此设置仅在与此类外部进程一起使用时有用。 ::: xpack.ml.max_ml_node_size （动态）支持自动集群扩展的部署中机器学习节点的最大节点大小。如果将其设置为未来机器学习节点的最大可能大小，则当机器学习作业分配给懒节点时，当缩放无法支持作业的大小时，它可以检查（并快速失败）。启用操作员权限功能后，此设置只能由操作员用户更新。默认值为 0b，这意味着将假设自动集群缩放可以向集群添加任意大的节点。 xpack.ml.persist_results_max_retries （动态）处理机器学习结果时重试失败的批量索引请求的最大次数。如果达到限制，机器学习作业将停止处理数据，其状态为失败。启用操作员权限功能后，此设置只能由操作员用户更新。最小值为 0；最大值为 50。默认值为 20。 xpack.ml.process_connect_timeout （动态）与 Elasticsearch JVM 分开运行的机器学习进程的连接超时。当这些进程启动时，它们必须连接到 Elasticsearch JVM。如果进程在该设置指定的时间段内未连接，则认为该进程已失败。启用操作员权限功能后，此设置只能由操作员用户更新。最小值为 5s。默认值为 10s。 xpack.ml.use_auto_machine_memory_percent （动态）如果此设置为true，则将忽略 xpack.ml.max_machine_memory_percent 设置。相反，可以用于运行机器学习分析过程的机器内存的最大百分比是自动计算的，并考虑了节点的总大小和节点上 JVM 的大小。启用操作员权限功能后，此设置只能由操作员用户更新。默认值为 false。 :::danger 重要 如果没有专用的机器学习节点（也就是说，节点具有多个角色），请不要启用此设置。其计算假设机器学习分析是节点的主要目的。 计算假设专用机器学习节点在 JVM 外部至少保留了 256MB 内存。如果集群中有微小的机器学习节点，则不应使用此设置。 ::: 如果此设置为 true，则还会影响 xpack.ml.max_model_memory_limit 的默认值。在这种情况下，xpack.ml.max_model_memory_limit 默认为当前集群中可以分配的最大大小。 ","version":"Next","tagName":"h2"},{"title":"机器学习断路器设置​","type":1,"pageTitle":"Elasticsearch 中的机器学习设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/machine_learning_settings_in_elasticsearch#机器学习断路器设置","content":"breaker.model_inference.limit （动态）训练模型断路器的限定。该值定义为 JVM 堆的百分比。默认为 50%。如果父断路器设置为小于 50% 的值，则此设置将使用该值作为默认值。 breaker.model_inference.overhead （动态）所有经过训练的模型估计值乘以确定最终估计值的常数。参阅断路器设置。默认值为 1。 breaker.model_inference.type (静态断路器的基本类型。有两个有效的选项：noop 和 memory。noop 意味着断路器不采取任何措施来防止过多的内存使用。memory 意味着断路器跟踪训练模型使用的内存，并可能中断和防止内存溢出错误。默认值为 memory。 原文链接 ","version":"Next","tagName":"h2"},{"title":"网络","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"常用网络设置​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#常用网络设置","content":"大多数用户只需要配置以下网络设置。 network.host （静态，字符串）为 HTTP 和传输流量设置此节点的地址。节点将绑定到此地址，并将其用作发布地址。接受 IP 地址、主机名或特殊值。 默认为 _local_。 http.port （静态，整数）为 HTTP 客户端通信绑定的端口。接受单个值或范围。如果指定了一个范围，则节点将绑定到该范围中的第一个可用端口。 默认为 9200-9300。 transport.port （静态，整数）为节点之间的通信而绑定的端口。接受单个值或范围。如果指定了一个范围，则节点将绑定到该范围中的第一个可用端口。在每个符合主条件的节点上，将此设置设置为单个端口，而不是范围。 默认为 9300-9400。 ","version":"Next","tagName":"h2"},{"title":"网络地址的特殊值​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#网络地址的特殊值","content":"你可以使用以下特殊值配置 Elasticsearch 以自动确定其地址。配置 network.host、network.bind_host、network.publish_host 以及 HTTP 和传输接口的相应设置时，请使用这些值。 _local_ 系统上的任何环回地址，例如 127.0.0.1。 _site_ 系统上的任何站点本地地址，例如 192.168.0.1。 _global_ 系统上任何全局范围的地址，例如 8.8.8.8。 _[networkInterface]_ 使用名为 [networkInterface]的网络接口的地址。例如，如果你希望使用名为 en0 的接口的地址，则设置 network.host: _en0_。 0.0.0.0 所有可用网络接口的地址。 注意 在一些系统中，这些特殊值解析为多个地址。如果是这样，Elasticsearch 将选择其中一个作为其发布地址，并可能在每次节点重新启动时更改其选择。确保每个可能的地址都可以访问你的节点。 注意 任何包含 : 的值（例如 IPv6 地址或某些特殊值）都必须引用，因为 : 是 YAML 中的一个特殊字符。 ","version":"Next","tagName":"h2"},{"title":"IPv4 与 IPv6​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#ipv4-与-ipv6","content":"默认情况下，这些特殊值同时产生 IPv4 和 IPv6 地址，但你也可以添加 :ipv4 或 :ipv6 后缀，将它们分别限制为 IPv4 或 IPv6 地址。例如，network.host: &quot;_en0:ipv4_&quot; 会将此节点的地址设置为接口 en0 的 IPv4 地址。 提示 云端发现 当在安装了 EC2 发现插件或谷歌计算引擎发现插件的云上运行时，可以使用更多特殊设置。 ","version":"Next","tagName":"h2"},{"title":"绑定和发布​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#绑定和发布","content":"Elasticsearch 将网络地址用于两个不同的目的，即绑定和发布。大多数节点将对所有内容使用相同的地址，但更复杂的设置可能需要为不同的目的配置不同的地址。 当像 Elasticsearch 这样的应用程序希望接收网络通信时，它必须向操作系统指示应该接收其流量的一个或多个地址。这被称为绑定到这些地址。如果需要，Elasticsearch 可以绑定到多个地址，但大多数节点只绑定到一个地址。Elasticsearch 只能绑定到一个地址，前提是它运行在具有该地址的网络接口的主机上。如有必要，你可以配置传输和 HTTP 接口以绑定到不同的地址。 每个 Elasticsearch 节点都有一个地址，客户端和其他节点可以在该地址与它联系，即它的发布地址。每个节点的 HTTP 接口和传输接口各有一个发布地址。这两个地址可以是任何地址，不需要是主机上网络接口的地址。唯一的要求是每个节点必须： 在其传输发布地址时，可由其集群中的所有其他节点进行访问，并能被任何远程集群使用嗅探模式发现它。所有使用嗅探发现它的客户端，都可以在其 HTTP 发布地址访问它。 ","version":"Next","tagName":"h2"},{"title":"使用单个地址​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#使用单个地址","content":"最常见的配置是将 Elasticsearch 绑定到客户端和其他节点可以访问的单个地址。在此配置中，你只需将 network.host 设置为该地址即可。不应单独设置任何绑定或发布地址，也不应单独配置 HTTP 或传输接口的地址。 ","version":"Next","tagName":"h3"},{"title":"使用多个地址​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#使用多个地址","content":"如果你希望将 Elasticsearch 绑定到多个地址，或者发布与要绑定的地址不同的地址，请使用高级网络设置。将 network.bind_host 设置为绑定地址，将 network.publish_host 设置为此节点公开的地址。在复杂的配置中，你可以为 HTTP 和传输接口以不同的方式配置这些地址。 ","version":"Next","tagName":"h3"},{"title":"高级网络设置​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#高级网络设置","content":"通过这些高级设置，你可以绑定到多个地址，或者使用不同的地址进行绑定和发布。在大多数情况下，它们不是必需的，如果可以使用常用设置，则不应使用它们。 network.bind_host （静态，字符串）节点应绑定到的网络地址，以便监听传入连接。接受 IP 地址、主机名和特殊值的列表。默认为 network.host 提供的地址。仅当绑定到多个地址或使用不同的地址进行发布和绑定时，才使用此设置。 network.publish_host （静态，字符串）客户端和其他节点可以用来联系此节点的网络地址。接受IP 地址、主机名或特殊值。默认为 network.host 提供的地址。仅当绑定到多个地址或使用不同的地址进行发布和绑定时，才使用此设置。 注意 你可以指定 network.host 和 network.publish_host 的地址列表。你还可以指定一个或多个主机名或解析为多个地址的特殊值。如果你这样做，那么 Elasticsearch 会选择其中一个地址作为其发布地址。这种选择使用基于 IPv4/IPv6 堆栈偏好和可达性的启发式方法，并且可能在节点重新启动时发生变化。确保每个节点在所有可能的发布地址都可以访问。 ","version":"Next","tagName":"h2"},{"title":"高级 TCP 设置​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#高级-tcp-设置","content":"使用以下设置来控制 HTTP 和传输接口使用的 TCP 连接的低级别参数。 network.tcp.keep_alive （静态，布尔值）为网络套接字配置 SO_KEEPALIVE 选项，该选项确定每个连接是否发送 TCP 保活探测。默认为 true。 network.tcp.keep_idle （静态，整数）为网络套接字配置 TCP_KEEPIDLE 选项，该选项确定连接在开始发送 TCP 保活探测之前必须处于空闲状态的时间（以秒为单位）。默认值为 -1，这意味着使用系统默认值。此值不能超过 300 秒。仅适用于 Linux 和 macOS。 network.tcp.keep_interval （静态，整数）为网络套接字配置 TCP_KEEPINTVL 选项，该选项确定发送 TCP 保活探测之间的时间（以秒为单位）。默认值为 -1，这意味着使用系统默认值。此值不能超过 300 秒。仅适用于 Linux 和 macOS。 network.tcp.keep_count （静态，整数）为网络套接字配置 TCP_KEEPCNT 选项，该选项确定在断开连接之前可能在连接上发送的未确认 TCP 保活探测的数量。默认值为 -1，这意味着使用系统默认值。仅适用于 Linux 和 macOS。 network.tcp.no_delay （静态，布尔值）在网络套接字上配置 TCP_NODELAY 选项，该选项确定是否启用 TCP 无延迟。默认为 true。 network.tcp.reuse_address （静态，布尔值）为网络套接字配置 SO_REUSEADDR 选项，该选项决定地址是否可以重用。在 Windows 上默认为 false，在其他情况下默认为 true。 network.tcp.send_buffer_size （静态，字节值）为网络套接字配置 TCP 发送缓冲区的大小。默认值为 -1，这意味着使用系统默认值。 network.tcp.receive_buffer_size （静态，字节值）配置 TCP 接收缓冲区的大小。默认值为 -1，这意味着使用系统默认值。 ","version":"Next","tagName":"h3"},{"title":"高级 HTTP 设置​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#高级-http-设置","content":"使用以下高级设置可以独立于传输接口配置 HTTP 接口。你也可以使用网络设置同时配置这两个接口。 http.host （静态，字符串）为 HTTP 流量设置此节点的地址。节点将绑定到此地址，并将其用作其 HTTP 发布地址。接受 IP 地址、主机名或特殊值。只有当你需要对传输和 HTTP 接口进行不同的配置时，才能使用此设置。 默认为 network.host 提供的地址。 http.bind_host （静态，字符串）节点应绑定到的网络地址，以便侦听传入的 HTTP 连接。接受 IP 地址、主机名和特殊值的列表。默认为 http.host 或 network.bind_host 提供的地址。只有当你需要绑定到多个地址或使用不同的地址进行发布和绑定，并且还需要传输和 HTTP 接口的不同绑定配置时，才使用此设置。 http.publish_host （静态，字符串）HTTP 客户端使用嗅探与节点联系的网络地址。接受 IP 地址、主机名或特殊值。默认为 http.host 或 network.publish_host 提供的地址。只有当你需要绑定到多个地址或使用不同的地址进行发布和绑定，并且还需要传输和 HTTP 接口的不同绑定配置时，才使用此设置。 http.max_content_length （静态，字节值）HTTP 请求正文的最大大小。默认值为 100mb。将此设置配置为大于 100mb 可能会导致集群不稳定，建议不要这样做。如果在向批量 API 发送请求时达到此限制，请将客户端配置为在每个批量请求中发送较少的文档。如果你希望索引超过 100mb 的单个文档，请在将其发送到 Elasticsearch 之前将其预处理为较小的文档。例如，将原始数据存储在 Elasticsearch 之外的系统中，并在 Elastic 搜索索引的文档中包含原始数据的链接。 http.max_initial_line_length （静态，字节值）HTTP URL 的最大值。默认值为 4kb。 http.max_header_size （静态，字节值）允许的头的最大值。默认值为 16kb。 http.compression （静态，布尔值）尽可能支持压缩（使用 Accept-Encoding）。如果启用了 HTTPS，则默认为 false。否则，默认为 true。 禁用 HTTPS 压缩可以降低潜在的安全风险，例如 BreaACH 攻击。要压缩 HTTPS 流量，必须将 http.compressure 显式设置为 true。 http.compression_level （静态，整数）定义用于 HTTP 响应的压缩级别。有效值介于1（最小压缩）和 9（最大压缩）之间。默认值为 3。 http.cors.enabled （静态，布尔值）启用或禁用跨源资源共享，这决定了另一个源上的浏览器是否可以执行针对 Elasticsearch 的请求。设置为 true 可使 Elasticsearch 处理预检 CORS 请求。如果 http.cors.allow-origin 列表允许请求中发送的 Origin，则 Elasticsearch 将使用 Access-Control-Allow-Origin 头来响应这些请求。设置为 false（默认值）可使 Elasticsearch 忽略 Origin 请求头，从而有效地禁用 CORS 请求，因为 Elasticsearch 永远不会使用 Access-Control-Allow-Origin 响应头进行响应。 :::tip 注意 如果客户端没有发送带有 Origin 头的预检请求，或者没有检查服务器的响应标头以验证 Access-Control-Allow-Origin 响应头，则跨来源安全性会受到损害。如果 Elasticsearch 上没有启用 CORS，那么客户端知道的唯一方法就是发送预检请求，并意识到所需的响应头丢失。 ::: http.cors.allow-origin （静态，字符串）允许哪些来源。如果你在值前面加上一个正斜杠（/），这将被视为一个正则表达式，从而允许你支持 HTTP 和 HTTPs。例如，使用 /https?:\\/\\/localhost(:[0-9]+)?/ 在这两种情况下都会适当地返回请求头。默认为不允许源。 :::danger 重要 通配符（*）是一个有效值，但被认为是一个安全风险，因为你的 Elasticsearch 实例对来自任何地方的跨源请求都是开放的。 ::: http.cors.max-age （静态，整数）浏览器发送”预检“ OPTIONS 请求以确定 CORS 设置。max-age 定义了缓存结果的时间（以秒为单位）。默认值为 1728000（20 天）。 http.cors.allow-methods （静态，字符串）允许使用哪些方法。默认为 OPTIONS、HEAD、GET、POST、PUT、DELETE。 http.cors.allow-headers （静态，字符串）允许哪些头。默认为 X-Requested-With、Content-Type、Content-Length。 http.cors.allow-credentials （静态，布尔值）是否应返回 Access-Control-Allow-Credentials 头。默认为 false。 :::tip 注意 只有当设置设置为 true 时，才会返回此头。 ::: http.detailed_errors.enabled （静态，布尔值）配置是否启用 HTTP 响应中的详细错误报告。默认为true，这意味着包含的 ?error_trace 参数的 HTTP 请求如果遇到异常，将返回一条详细的错误消息，其中包括堆栈跟踪。如果设置为 false，则使用请求 ?error_trace 参数被拒绝。 http.pipelining.max_events （静态，整数）在 HTTP 连接关闭之前，要在内存中排队的最大事件数，默认为 10000。 http.max_warning_header_count （静态，整数）客户端 HTTP 响应中警告标头的最大数目。默认值为 -1，这意味着警告头的数量是无限的。 http.max_warning_header_size （静态，字节值）客户端 HTTP 响应中警告头的最大总大小。默认值为 -1，这意味着警告头的大小是无限的。 http.tcp.keep_alive （静态，布尔值）为此套接字配置 SO_KEEPALIVE 选项，该选项决定是否发送 TCP 保活探测。默认为 network.tcp.keep_alive。 http.tcp.keep_idle （静态，整数）为 HTTP 套接字配置 TCP_KEEPIDLE 选项，该选项确定连接在开始发送 TCP 保活探测之前必须处于空闲状态的时间（以秒为单位）。默认为 network.tcp.keep_idle，它使用系统默认值。此值不能超过 300 秒。仅适用于 Linux 和 macOS。 http.tcp.keep_interval （静态，整数）为 HTTP 套接字配置 TCP_KEEPINTVL 选项，该选项确定发送 TCP 保活探测之间的时间（以秒为单位）。默认为 network.tcp.keep_interval，它使用系统默认值。此值不能超过 300 秒。仅适用于 Linux 和 macOS。 http.tcp.keep_count （静态，整数）为 HTTP 套接字配置 TCP_KEEPCNT 选项，该选项确定在断开连接之前可能在连接上发送的未确认 TCP 保活探测的数量。默认为 network.tcp.keep_count，使用系统默认值。仅适用于 Linux 和 macOS。 http.tcp.no_delay （静态，布尔值）在 HTTP 套接字上配置 TCP_NODELAY 选项，该选项确定是否启用 TCP 无延迟。默认为 true。 http.tcp.reuse_address （静态，布尔值）为 HTTP 套接字配置 SO_REUSEADDR 选项，该选项决定地址是否可以重用。在 Windows 上默认为 false，在其他情况下默认为 true。 http.tcp.send_buffer_size （静态，字节值）HTTP 流量的 TCP 发送缓冲区的大小。默认为 network.tcp.send_buffer_size。 http.tcp.receive_buffer_size （静态，字节值）HTTP 流量的 TCP 发送缓冲区的大小。默认为 network.tcp.send_buffer_size。 http.client_stats.enabled （静态，布尔值）启用或禁用 HTTP 客户端统计信息的收集。默认为 true。 http.client_stats.closed_channels.max_count （静态，整数）当 http.client_stats.enabled 为 true 时，设置 Elasticsearch 报告统计信息的最大关闭 HTTP 通道数。默认值为 10000。 http.client_stats.closed_channels.max_age （静态，时间值）当 http.client_stats.enabled 为 true 时，设置关闭 HTTP 通道后 Elasticsearch 将报告该通道统计信息的最大时间长度。默认值为 5m。 ","version":"Next","tagName":"h2"},{"title":"高级传输设置​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#高级传输设置","content":"使用以下高级设置可以独立于 HTTP 接口配置传输接口。使用网络设置可以同时配置两个接口。 transport.host （静态，字符串）为传输流量设置此节点的地址。节点将绑定到此地址，并将其用作传输发布地址。接受 IP 地址、主机名或特殊值。只有当你需要对传输和 HTTP 接口进行不同的配置时，才能使用此设置。 默认为 network.host 提供的地址。 transport.bind_host （静态，字符串）节点应绑定到的网络地址，以便监听传入的传输连接。接受 IP 地址、主机名和特殊值的列表。默认为 transport.host 或 network.bind_host 提供的地址。仅当你需要绑定到多个地址或使用不同的地址进行发布和绑定，并且你还需要传输和 HTTP 接口的不同绑定配置时，才使用此设置。 transport.publish_host （静态，字符串）其他节点可以联系该节点的网络地址。接受 IP 地址、主机名或特殊值。默认为 transport.host 或 network.publish_host 提供的地址。仅当你需要绑定到多个地址或使用不同的地址进行发布和绑定，并且你还需要传输和 HTTP 接口的不同绑定配置时，才使用此设置。 transport.publish_port （静态，整数）传输发布地址的端口。仅当你需要发布端口与 transport.port 不同时才设置此参数。默认为通过 transport.port分配的端口。 transport.connect_timeout （静态，时间值）启动新连接的连接超时（以时间设置格式）。默认值为 30s。 transport.compress （静态，字符串）设置为 true、indexing_data 或 false 可配置节点之间的传输压缩。选项 true 将压缩所有数据。indexing_data 选项将仅压缩在摄取、ccr 跟随（排除引导）和基于操作的分片恢复（不包括传输 lucene 文件）期间在节点之间发送的原始索引数据。默认为 indexing_data。 transport.compression_scheme （静态，字符串）配置 transport.compress 的压缩方案。选项为 deflate 或 lz4。如果配置了 lz4，并且远程节点尚未升级到支持 lz4 的版本，则流量将以未压缩的方式发送。默认值为 lz4。 transport.tcp.keep_alive （静态，布尔值）为传输套接字配置 SO_KEEPALIVE 选项，用于确定它们是否发送 TCP 保活探测。默认为 network.tcp.keep_alive。 transport.tcp.keep_idle （静态，整数）为传输套接字配置 TCP_KEEPIDLE 选项，该选项确定连接在开始发送 TCP 保活探测之前必须处于空闲状态的时间（以秒为单位）。如果已设置，则默认为 network.tcp.keep_idle，否则为系统默认值。此值不能超过 300 秒。在系统默认值高于 300 的情况下，该值会自动降低到 300。仅适用于 Linux 和 macOS。 transport.tcp.keep_interval （静态，整数）为传输套接字配置 TCP_KEEPINTVL 选项，该选项确定发送 TCP 保活探测之间的时间（以秒为单位）。如果已设置，则默认为 network.tcp.keep_interval，否则为系统默认值。此值不能超过 300 秒。在系统默认值高于 300 的情况下，该值会自动降低到 300。仅适用于 Linux 和 macOS。 transport.tcp.keep_count （静态，整数）为传输套接字配置 TCP_KEEPCNT 选项，该选项确定在断开连接之前可能在连接上发送的未确认 TCP 保活探测的数量。如果已设置，则默认为 network.tcp.keep_count，否则为系统默认值。仅适用于 Linux 和 macOS。 transport.tcp.no_delay （静态，布尔值）配置传输套接字上的 TCP_NODELAY 选项，该选项确定是否启用 TCP 无延迟。默认为 true。 transport.tcp.reuse_address （静态，布尔值）为网络套接字配置 SO_REUSEADDR 选项，该选项决定地址是否可以重用。默认为 network.tcp.reuse_address。 transport.tcp.send_buffer_size （静态，字节值）传输流量的 TCP 发送缓冲区的大小。默认为 network.tcp.send_buffer_size。 transport.tcp.receive_buffer_size （静态，字节值）用于传输流量的 TCP 接收缓冲区的大小。默认为 network.tcp.receive_buffer_size。 transport.ping_schedule （静态，时间值）配置在所有传输连接上发送应用程序级 ping 的间隔时间，以便在传输连接出现故障时及时检测。默认值为 -1，表示不发送应用程序级 ping。你应该尽可能使用 TCP 保活（参阅 transport.tcp.keep_alive），而不是应用程序级别的 ping。 ","version":"Next","tagName":"h2"},{"title":"传输配置文件​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#传输配置文件","content":"Elasticsearch 允许你通过使用传输配置文件绑定到不同接口上的多个端口。参阅此配置示例： transport.profiles.default.port: 9300-9400 transport.profiles.default.bind_host: 10.0.0.1 transport.profiles.client.port: 9500-9600 transport.profiles.client.bind_host: 192.168.0.1 transport.profiles.dmz.port: 9700-9800 transport.profiles.dmz.bind_host: 172.16.1.2  默认配置文件是特殊的。它被用作任何其他配置文件的后备，如果这些配置文件没有设置特定的配置设置，并且是该节点连接到集群中其他节点的方式。其他配置文件可以有任何名称，并且可以用于为传入连接设置特定的端点。 可以在每个传输配置文件上配置以下参数，如上面的示例所示： port：要绑定的端口。bind_host：要绑定到的主机。publish_host：在信息 API 中发布的主机。 配置文件还支持在传输设置部分指定的所有其他传输设置，并将这些设置用作默认设置。例如，transport.profiles.client.tcp.reuse_address 可以显式配置，否则默认为 transport.tcp.reuse_address。 ","version":"Next","tagName":"h3"},{"title":"长期闲置连接​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#长期闲置连接","content":"两个节点之间的传输连接由许多长寿命的 TCP 连接组成，其中一些连接可能会闲置很长一段时间。尽管如此，Elasticsearch 要求这些连接保持开放，如果任何节点间连接被防火墙等外部影响关闭，它可能会中断集群的运行。重要的是要配置你的网络以保留 Elasticsearch 节点之间的长期空闲连接，例如，通过启用 *.tcp.keep_alive 并确保保活间隔短于可能导致空闲连接关闭的任何超时，或者如果无法配置保活，则通过设置 transport.ping_schedule。当设备达到一定年龄时会断开连接，这是 Elasticsearch 集群的常见问题来源，因此不得使用。 ","version":"Next","tagName":"h3"},{"title":"请求压缩​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#请求压缩","content":"默认的 transport.compress 配置选项 indexing_data 将只压缩与节点之间原始索引源数据传输相关的请求。此选项主要压缩在摄取、ccr 和分片恢复期间发送的数据。这种默认设置通常对本地集群通信有意义，因为压缩原始文档往往会显著减少节点间网络的使用，而对 CPU 的影响最小。 transport.compress 设置始终配置本地集群请求压缩，并且是远程集群请求压缩的后备设置。如果要以不同于本地请求压缩的方式配置远程请求压缩，可以使用 cluster.remote.${cluster_alias}.transport.compress 设置按每个远程集群进行设置。 ","version":"Next","tagName":"h3"},{"title":"响应压缩​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#响应压缩","content":"压缩设置不配置响应的压缩。如果入站请求被压缩，Elasticsearch 将压缩响应——​即使在没有启用压缩的情况下。同样，如果入站请求未压缩，Elasticsearch 也不会压缩响应——​即使在启用压缩时也是如此。用于压缩响应的压缩方案与用于压缩请求的远程节点的压缩方案相同。 ","version":"Next","tagName":"h3"},{"title":"请求跟踪​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#请求跟踪","content":"你可以跟踪在 HTTP 和传输层上发出的单个请求。 警告 跟踪可能会生成极高的日志卷，从而破坏集群的稳定。不要在繁忙或重要的集群上启用请求跟踪。 ","version":"Next","tagName":"h2"},{"title":"REST 请求跟踪器​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#rest-请求跟踪器","content":"HTTP 层有一个专用的跟踪器，用于记录传入请求和相应的传出响应。通过将 org.elasticsearch.http.HttpTracer 记录器的级别设置为 TRACE 来激活跟踪器： PUT _cluster/settings { &quot;persistent&quot; : { &quot;logger.org.elasticsearch.http.HttpTracer&quot; : &quot;TRACE&quot; } }  你还可以使用一组包含和排除通配符模式来控制将跟踪哪些 URI。默认情况下，将跟踪每个请求。 PUT _cluster/settings { &quot;persistent&quot; : { &quot;http.tracer.include&quot; : &quot;*&quot;, &quot;http.tracer.exclude&quot; : &quot;&quot; } }  ","version":"Next","tagName":"h3"},{"title":"传输跟踪器​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#传输跟踪器","content":"传输层有一个专用的跟踪器，用于记录传入和传出的请求和响应。通过将 org.elasticsearch.transport.TransportService.tracer 记录器的级别设置为 TRACE 来激活跟踪器： PUT _cluster/settings { &quot;persistent&quot; : { &quot;logger.org.elasticsearch.transport.TransportService.tracer&quot; : &quot;TRACE&quot; } }  你还可以使用一组包含和排除通配符模式来控制将跟踪哪些操作。默认情况下，除了故障检测 ping 之外，将跟踪每个请求： PUT _cluster/settings { &quot;persistent&quot; : { &quot;transport.tracer.include&quot; : &quot;*&quot;, &quot;transport.tracer.exclude&quot; : &quot;internal:coordination/fault_detection/*&quot; } }  ","version":"Next","tagName":"h3"},{"title":"网络线程模型​","type":1,"pageTitle":"网络","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/networking#网络线程模型","content":"本节描述了 Elasticsearch 中网络子系统使用的线程模型。使用 Elasticsearch 不需要这些信息，但它可能对诊断集群中网络问题的高级用户有用。 Elasticsearch 节点通过一组 TCP 通道进行通信，这些通道共同形成传输连接。Elasticsearch 客户端通过 HTTP 与集群通信，HTTP 也使用一个或多个 TCP 通道。这些 TCP 通道中的每一个都恰好由节点中的一个 transport_worker 线程所拥有。该拥有线程是在通道打开时选择的，并且在通道的生命周期内保持不变。 每个 transport_worker 线程都全权负责通过其拥有的通道发送和接收数据。此外，每个 http 和传输服务器套接字都被分配给其中一个 transport_worker 线程。该工作者有责任接受到其拥有的服务器套接字的新传入连接。 如果 Elasticsearch 中的线程想要通过特定通道发送数据，它会将数据传递给拥有 transport_worker 的线程进行实际传输。 如果 Elasticsearch 中的线程想要通过特定通道发送数据，它会将数据传递给拥有 transport_worker 的线程进行实际传输。 通常 transport_worker 线程不会完全处理它们接收到的消息。相反，他们将进行少量的初步处理，然后将消息分派（移交）到另一个线程池，以进行其余的处理。例如，批量消息被调度到写线程池，搜索被调度到其中一个搜索线程池，对统计信息和其他管理任务的请求大多被调度到管理线程池。然而，在某些情况下，消息的处理速度预计会非常快，以至于 Elasticsearch 将在 transport_worker 线程上完成所有处理，而不是在其他地方调度消息。 默认情况下，每个 CPU 有一个 transport_worker 线程。相比之下，有时可能有数以万计的 TCP 通道。如果数据到达 TCP 通道，并且它所属的 transport_worker 线程正忙，那么在线程完成它正在做的任何事情之前，都不会处理数据。类似地，在拥有 transport_worker 线程空闲之前，不会通过通道发送传出数据。这意味着我们要求每个 transport_worker 线程经常处于空闲状态。闲置的 transport_worker 在堆栈转储中看起来像这样： &quot;elasticsearch[instance-0000000004][transport_worker][T#1]&quot; #32 daemon prio=5 os_prio=0 cpu=9645.94ms elapsed=501.63s tid=0x00007fb83b6307f0 nid=0x1c4 runnable [0x00007fb7b8ffe000] java.lang.Thread.State: RUNNABLE at sun.nio.ch.EPoll.wait(java.base@17.0.2/Native Method) at sun.nio.ch.EPollSelectorImpl.doSelect(java.base@17.0.2/EPollSelectorImpl.java:118) at sun.nio.ch.SelectorImpl.lockAndDoSelect(java.base@17.0.2/SelectorImpl.java:129) - locked &lt;0x00000000c443c518&gt; (a sun.nio.ch.Util$2) - locked &lt;0x00000000c38f7700&gt; (a sun.nio.ch.EPollSelectorImpl) at sun.nio.ch.SelectorImpl.select(java.base@17.0.2/SelectorImpl.java:146) at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:813) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:460) at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at java.lang.Thread.run(java.base@17.0.2/Thread.java:833)  在节点热线程 API 中，空闲的 transport_worker 线程报告如下：  100.0% [cpu=0.0%, other=100.0%] (500ms out of 500ms) cpu usage by thread 'elasticsearch[instance-0000000004][transport_worker][T#1]' 10/10 snapshots sharing following 9 elements java.base@17.0.2/sun.nio.ch.EPoll.wait(Native Method) java.base@17.0.2/sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:118) java.base@17.0.2/sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:129) java.base@17.0.2/sun.nio.ch.SelectorImpl.select(SelectorImpl.java:146) io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:813) io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:460) io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) java.base@17.0.2/java.lang.Thread.run(Thread.java:833)  请注意，transport_worker 线程应该始终处于 RUNNABLE 状态，即使在等待输入时也是如此，因为它们会阻塞本机 EPoll#wait 方法。这意味着热线程 API 将以 100% 的总体利用率报告这些线程。这是正常的，将时间分解为 cpu= 和 other= 部分可以分别显示线程运行和等待输入所花费的时间。 如果 transport_worker 线程不经常处于空闲状态，那么它可能会积累积压的工作。这可能会导致在其拥有的通道上处理消息的延迟。很难准确预测哪些工作会被推迟： 通道比线程多得多。如果与一个通道相关的工作导致其工作线程延迟，那么该线程拥有的所有其他通道也将遭受延迟。从 TCP 通道到工作线程的映射是固定的，但却是任意的。当通道打开时，以循环方式为每个通道分配一个拥有的线程。每个工作线程负责许多不同类型的通道。每对节点之间都有许多通道打开。对于每个请求，Elasticsearch 将以循环方式从适当的通道中进行选择。一些请求可能会在延迟工作人员拥有的通道上结束，而其他相同的请求则会在工作正常的通道上发送。 如果积压工作积累得太多，一些消息可能会延迟几秒钟。该节点甚至可能无法通过其运行状况检查并从集群中删除。有时，你可以使用节点热线程 API 找到繁忙的 transport_worker 线程的证据。然而，此 API 本身会发送网络消息，因此如果 transport_worker 线程太忙，则可能无法正常工作。使用 jstack 获取堆栈转储或使用 Java Flight Recorder 获取评测跟踪更可靠。这些工具独立于 JVM 正在执行的任何工作。 原文链接 ","version":"Next","tagName":"h2"},{"title":"节点","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"节点角色​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#节点角色","content":"可以通过在 elasticsearch.yml 中设置 node.role 来定义节点的角色。如果设置 node.roles，则仅为节点分配指定的角色。如果不设置 node.role，则会为节点指定以下角色： masterdatadata_contentdata_hotdata_warmdata_colddata_frozeningestmlremote_cluster_clienttransform 重要 如果设置 node.role，请确保指定集群所需的每个节点角色。每个集群都需要以下节点角色： masterdata_content 和 data_hot，或 data 某些 Elastic 堆栈功能还需要特定的节点角色： 跨集群搜索和跨集群复制需要 remote_cluster_client 角色。堆栈监视和摄取管道需要 ingest 角色。Elastic 安全应用 Fleet 和转换需要 transform 角色。还需要 remote_cluster_client 角色才能在这些功能中使用跨集群搜索。机器学习功能，如异常检测，需要 ml 角色。 随着集群的增长，特别是如果你有大型机器学习作业或连续转换，请考虑将专用的符合主机条件的节点与专用的数据节点、机器学习节点和转换节点分开。 主资格节点 具有 master 角色的节点，使其有资格被选为主节点，用于控制集群。 数据节点 具有 data 角色的节点。数据节点保存数据并执行数据相关操作，如 CRUD、搜索和聚合。具有 data 角色的节点可以填充任何专用数据节点角色。 摄取节点 具有 ingest 角色的节点。摄取节点能够将摄取管道应用于文档，以便在索引之前转换和丰富文档。对于繁重的摄取负载，使用专用摄取节点并且不包括具有主或数据角色的节点的摄取角色是有意义的。 远程资格节点 具有 remote_cluster_client 角色的节点，该角色使其有资格充当远程客户端。 机器学习节点 具有 ml 角色的节点。如果要使用机器学习功能，集群中必须至少有一个机器学习节点。更多信息，参阅机器学习设置和 Elastic 堆栈中的机器学习。 转换节点 具有 transform 角色的节点。如果要使用转换，则集群中必须至少有一个转换节点。详细信息，参阅转换设置和转换数据。 注意 协调节点 搜索请求或批量索引请求等请求可能涉及保存在不同数据节点上的数据。例如，搜索请求分两个阶段执行，这两个阶段由接收客户端请求的节点协调——协调节点。 在 scatter（分散）阶段，协调节点将请求转发给持有数据的数据节点。每个数据节点在本地执行请求，并将其结果返回给协调节点。在 gather （收集）阶段，协调节点将每个数据节点的结果缩减为单个全局结果集。 每个节点都隐含地是一个协调节点。这意味着，通过 node.role 具有显式空角色列表的节点只能充当协调节点，不能禁用。因此，这样的节点需要有足够的内存和 CPU 来处理收集阶段。 ","version":"Next","tagName":"h2"},{"title":"主资格节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#主资格节点","content":"主节点负责轻量级集群范围的操作，例如创建或删除索引、跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。拥有一个稳定的主节点对集群健康非常重要。 任何不是仅投票节点的主资格节点都可以通过主选举过程被选为主节点。 重要 主节点必须有一个 path.data 目录，该目录的内容与数据节点一样，在重新启动时持续存在，因为这是存储集群元数据的地方。集群元数据描述了如何读取存储在数据节点上的数据，因此，如果数据丢失，则无法读取数据节点上存储的数据。 ","version":"Next","tagName":"h2"},{"title":"专用主资格节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#专用主资格节点","content":"选择的主节点拥有履行其职责所需的资源对于集群的健康非常重要。如果选定的主节点被其他任务过载，那么集群将无法正常运行。避免其他任务使主机过载的最可靠方法是将所有主资格节点配置为仅具有 master 角色的专用主资格节点，从而使它们能够专注于管理集群。符合条件的 master 节点仍将充当协调节点，将请求从客户端路由到集群中的其他节点，但不应为此使用专用主节点。 如果一个小型或负载较轻的集群的主资格节点具有其他角色和职责，那么它可以很好地运行，但是一旦你的集群包含多个节点，那么使用专用的主资格的节点通常是有意义的。 要创建专用的主资格节点，请设置： node.roles: [ master ]  ","version":"Next","tagName":"h3"},{"title":"仅投票主资格节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#仅投票主资格节点","content":"只有投票权的主资格节点是指参与主选举但不会充当集群的当选主节点的节点。特别是，只有投票权的节点可以在选举中充当决定者。 使用术语“主资格节点”来描述仅投票的节点可能会令人困惑，因为这样的节点实际上根本没有资格成为主节点。这个术语是历史的一个不幸后果：符合资格的主节点是那些在集群状态发布期间参与选举并执行特定任务的节点，而仅投票的节点具有相同的责任，即使它们永远无法成为当选的主节点。 要将符合资格的主节点配置为仅投票节点，请在角色列表中包括 master 和 voting_only。例如，要创建仅投票的数据节点： node.roles: [ data, master, voting_only ]  重要 只有具有 master 角色的节点才能标记为具有 voting_Only 角色。 高可用性（HA）集群需要至少三个主资格节点，其中至少两个不是仅投票的节点。即使其中一个节点发生故障，这样的集群也能够选择主节点。 仅投票主资格节点也可以担任集群中的其他角色。例如，节点既可以是数据节点，也可以是仅投票的主资格节点。专用的仅投票主资格节点是仅投票主资格节点，不填充集群中的其他角色。要创建专用的仅投票主资格节点，请设置： node.roles: [ master, voting_only ]  由于专用的仅投票节点从不充当集群的当选主节点，因此它们可能比真正的主节点需要更少的堆和更少的 CPU。但是，所有符合条件的主节点（包括仅投票的节点）都位于发布群集状态更新的关键路径上。群集状态更新通常独立于性能关键型工作负载（如索引或搜索），但它们涉及管理活动，如索引创建和滚动、映射更新以及故障后恢复。这些活动的性能特征取决于每个主合格节点上的存储速度，以及所选主节点和集群中其他节点之间网络互连的可靠性和延迟。因此，你必须确保集群中节点可用的存储和网络足够好，以满足你的性能目标。 ","version":"Next","tagName":"h3"},{"title":"数据节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#数据节点","content":"数据节点保存包含已编制索引的文档的分片。数据节点处理与数据相关的操作，如 CRUD、搜索和聚合。这些操作是 I/O 密集、内存密集和 CPU 密集型的。监视这些资源并在它们过载时添加更多数据节点非常重要。 拥有专用数据节点的主要好处是主角色和数据角色的分离。 要创建专用数据节点，请设置： node.roles: [ data ]  在多层部署架构中，你使用专门的数据角色将数据节点分配给特定的层：data_content、data_hot、data_warm、data_cold 或 data_frozen。节点可以属于多个层，但具有一个专用数据角色的节点不能具有通用数据角色。 ","version":"Next","tagName":"h2"},{"title":"内容数据节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#内容数据节点","content":"内容数据节点是内容层的一部分。存储在内容层中的数据通常是产品目录或文章归档等项目的集合。与时间序列数据不同，随着时间的推移，内容的价值保持相对恒定，因此随着时间的增长，将其移动到具有不同性能特征的层是没有意义的。内容数据通常具有较长的数据保留期要求，你希望能够快速检索项目，而不管项目的使用年限如何。 内容层节点通常针对查询性能进行优化-​它们将处理能力优先于 IO 吞吐量，以便能够处理复杂的搜索和聚合，并快速返回结果。虽然他们也负责索引，但内容数据的摄取率通常不如日志和度量等时间序列数据高。从弹性角度来看，应将此层中的索引配置为使用一个或多个副本。 需要内容层。不属于数据流的系统索引和其他索引将自动分配给内容层。 要创建专用内容节点，请设置： node.roles: [ data_content ]  ","version":"Next","tagName":"h2"},{"title":"热门数据节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#热门数据节点","content":"热门数据节点是热层的一部分。热层是时间序列数据的 Elasticsearch 入口点，保存最新、最频繁搜索的时间序列数据。热层中的节点需要快速读取和写入，这需要更多的硬件资源和更快的存储（SSD）。为了恢复，应将热层中的索引配置为使用一个或多个副本。 热层是必需的。作为数据流一部分的新索引将自动分配给热层。 要创建专用热节点，请设置： node.roles: [ data_hot ]  ","version":"Next","tagName":"h2"},{"title":"温数据节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#温数据节点","content":"温数据节点是热层的一部分。一旦时间序列数据的查询频率低于热层中最近索引的数据，它就可以移动到温层。温层通常保存最近几周的数据。仍然允许更新，但可能不频繁。温层中的节点通常不需要像热层中那样快。为了恢复，应将温层中的索引配置为使用一个或多个副本。 要创建专用温节点，请设置： node.roles: [ data_warm ]  ","version":"Next","tagName":"h2"},{"title":"冷数据节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#冷数据节点","content":"冷数据节点是冷层的一部分。当你不再需要定期搜索时间序列数据时，它可以从温层移动到冷层。虽然仍然可以搜索，但这一层通常是为了降低存储成本而不是搜索速度而优化的。 为了更好地节省存储空间，你可以在冷层保留可搜索快照的完全挂载索引。与常规索引不同，这些完全装载的索引不需要副本以提高可靠性。如果发生故障，他们可以从基础快照恢复数据。这可能会使数据所需的本地存储减半。需要快照存储库才能在冷层中使用完全装载的索引。完全装入的索引是只读的。 或者，你可以使用冷层来存储带有副本的常规索引，而不是使用可搜索的快照。这允许你在较便宜的硬件上存储较旧的数据，但与热层相比，不会减少所需的磁盘空间。 要创建专用冷节点，请设置： node.roles: [ data_cold ]  ","version":"Next","tagName":"h2"},{"title":"冻结数据节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#冻结数据节点","content":"冻结数据节点是冻结层的一部分。一旦数据不再被查询，或者很少被查询，它可能会从冷层移动到冻结层，在那里它会一直保存。 冻结层需要快照存储库。冻结层使用部分挂载的索引来存储和加载快照存储库中的数据。这降低了本地存储和操作成本，同时仍允许你搜索冻结的数据。由于 Elasticsearch 有时必须从快照存储库获取冻结数据，因此冻结层上的搜索通常比冷层上的慢。 要创建专用冻结节点，请设置： node.roles: [ data_frozen ]  ","version":"Next","tagName":"h2"},{"title":"摄取节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#摄取节点","content":"摄取节点可以执行由一个或多个摄取处理器组成的预处理管道。根据摄取处理器执行的操作类型和所需的资源，使用专用的摄取节点可能是有意义的，这些节点将仅执行此特定任务。 要创建专用摄取节点，请设置： node.roles: [ ingest ]  ","version":"Next","tagName":"h2"},{"title":"仅协调节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#仅协调节点","content":"如果你失去了处理主任务、保存数据和预处理文档的能力，那么你将剩下一个协调节点，它只能路由请求、处理搜索减少阶段和分发批量索引。本质上，仅协调节点充当智能负载平衡器。 仅协调节点可以通过将协调节点角色从符合数据和主资格的节点上卸下而使大型集群受益。它们加入集群并接收完整的集群状态，就像其他节点一样，它们使用集群状态将请求直接路由到适当的位置。 警告 向集群添加太多的仅协调节点会增加整个集群的负担，因为所选的主节点必须等待来自每个节点的集群状态更新确认！仅协调节点的好处不应夸大——数据节点可以愉快地服务于相同的目的。 要创建专用协调节点，请设置： node.roles: [ ]  ","version":"Next","tagName":"h2"},{"title":"远程资格节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#远程资格节点","content":"符合条件的远程节点充当跨集群客户端并连接到远程集群。连接后，可以使用跨集群搜索来搜索远程集群。你还可以使用跨集群复制在集群之间同步数据。 node.roles: [ remote_cluster_client ]  ","version":"Next","tagName":"h2"},{"title":"机器学习节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#机器学习节点","content":"机器学习节点运行作业并处理机器学习 API 请求。有关更多信息，参阅机器学习设置。 要创建专用机器学习节点，请设置： node.roles: [ ml, remote_cluster_client]  remote_cluster_client 角色是可选的，但强烈建议使用。否则，在机器学习作业或数据反馈中使用跨集群搜索时会失败。如果在异常检测作业中使用跨集群搜索，则所有符合条件的主节点上也需要 remote_cluster_client 角色。否则，无法启动数据馈送。参阅远程资格节点。 ","version":"Next","tagName":"h2"},{"title":"转换节点​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#转换节点","content":"转换节点运行转换并处理转换 API 请求。有关详细信息，请参见变换设置。 要创建专用变换节点，请设置： node.roles: [ transform, remote_cluster_client ]  remote_cluster_client 角色是可选的，但强烈建议使用。否则，在转换中使用跨集群搜索时会失败。参阅远程资格节点。 ","version":"Next","tagName":"h2"},{"title":"更改节点角色​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#更改节点角色","content":"每个数据节点在磁盘上维护以下数据： 分配给该节点的每个分片的分片数据，与分配给该节点的每个分片相对应的索引元数据，以及集群范围的元数据，如设置和索引模板。 同样，每个符合资格的主节点在磁盘上维护以下数据： 集群中每个索引的索引元数据，以及集群范围的元数据，如设置和索引模板。 每个节点在启动时检查其数据路径的内容。如果它发现意外数据，那么它将拒绝启动。这是为了避免导入不需要的悬挂索引，这可能会导致红色集群运行状况。更准确地说，如果启动时在磁盘上发现任何碎片数据，则没有数据角色的节点将拒绝启动；如果启动时磁盘上有任何索引元数据，则没有 master 角色和 data 角色的节点将拒绝启动。 可以通过调整其 elasticsearch.yml 文件并重新启动它来更改节点的角色。这被称为重新调整节点的用途。为了满足对上述意外数据的检查，在启动没有 data 或 master 角色的节点时，必须执行一些额外的步骤来准备重新调整节点的用途。 如果你想通过删除数据角色来重新调整数据节点的用途，那么应该首先使用分配过滤器将所有分片数据安全地迁移到集群中的其他节点上。 如果你希望重新调整节点的用途，使其既不具有 data 角色，也不具有 master 角色，那么最简单的方法是启动一个具有空数据路径和所需角色的新节点。你可能会发现，首先使用分配过滤器将分片数据迁移到集群中的其他位置是最安全的。 如果无法执行这些额外步骤，则可以使用 elasticsearch 节点重新调整用途工具删除阻止节点启动的任何多余数据。 ","version":"Next","tagName":"h2"},{"title":"节点路径数据设置​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#节点路径数据设置","content":"","version":"Next","tagName":"h2"},{"title":"path.data​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#pathdata","content":"每个符合条件的数据和主节点都需要访问数据目录，其中将存储分片、索引和集群元数据。path.data 默认为 $ES_HOME/data，但可以在 elasticsearch.yml 配置文件中配置绝对路径或相对于 $ES_HOME的路径，如下所示： path.data: /var/elasticsearch/data  与所有节点设置一样，也可以在命令行中将其指定为： ./bin/elasticsearch -Epath.data=/var/elasticsearch/data  path.data 目录的内容必须在重新启动期间保持，因为这是存储数据的位置。Elasticsearch 要求文件系统像由本地磁盘备份一样工作，但这意味着只要远程存储的行为与本地存储无异，它就可以在正确配置的远程块设备（如 SAN）和远程文件系统（如 NFS）上正常工作。你可以在同一文件系统上运行多个 Elasticsearch 节点，但每个 Elasticearch 节点必须有自己的数据路径。 Elasticsearch 集群的性能通常受到底层存储性能的限制，因此必须确保存储支持可接受的性能。某些远程存储性能非常差，特别是在 Elasticsearch 所施加的负载下，因此在使用特定存储体系结构之前，请确保仔细地对系统进行基准测试。 提示 使用 .zip 或 .tar.gz 发行版时，应将 path.data 设置配置为查找 Elasticsearch 主目录之外的数据目录，以便在不删除数据的情况下删除主目录！RPM 和 Debian 发行版已经为你做到了这一点。 警告 不要修改数据目录中的任何内容或运行可能干扰其内容的进程。如果 Elasticsearch 以外的其他东西修改了数据目录的内容，那么 Elasticsearch 可能会失败，报告损坏或其他数据不一致，或者可能在默默丢失了一些数据后看起来工作正常。不要尝试对数据目录进行文件系统备份；没有支持的方法来恢复这样的备份。相反，请使用快照和恢复来安全地进行备份。不要在数据目录上运行病毒扫描程序。病毒扫描程序可以阻止 Elasticsearch 正常工作，并可能修改数据目录的内容。数据目录不包含可执行文件，因此病毒扫描只能发现误报。 ","version":"Next","tagName":"h3"},{"title":"其他节点设置​","type":1,"pageTitle":"节点","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/node#其他节点设置","content":"更多节点设置可在配置 Elasticsearch 和重要 Elasticearch 配置中找到，包括： cluster.namenode.name网络设置 原文链接 ","version":"Next","tagName":"h2"},{"title":"安全设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/secure_settings","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"可重新加载的安全设置​","type":1,"pageTitle":"安全设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/secure_settings#可重新加载的安全设置","content":"就像 elasticsearch.yml 中的设置值一样中，对密钥存储库内容的更改不会自动应用到正在运行的 Elasticsearch 节点。重新读取设置需要重新启动节点。但是，某些安全设置被标记为 reloadable（可重新加载）。这些设置可以重新读取并应用到运行中的节点上。 所有安全设置的值(无论是否reloadable（可重新加载）)，必须在所有集群节点上相同。在完成所需的安全设置更改后，使用bin/elasticsearch-keystore add命令，调用: POST _nodes/reload_secure_settings { &quot;secure_settings_password&quot;: &quot;keystore-password&quot; }  &quot;secure_settings_password&quot;: &quot;keystore-password&quot;：Elasticsearch 密钥存储库使用的加密密码。 该 API 在每个集群节点上解密并重新读取整个密钥存储库，但只应用 reloadable（可重新加载）的安全设置。对其他设置的更改直到下一次重启才生效。一旦调用返回，重新加载就完成了，这意味着依赖于这些设置的所有内部数据结构都已被更改。一切都应该看起来好像设置从一开始就有了新的值。 在更改多个 reloadable（可重新加载）的安全设置时，在每个集群节点上修改所有这些设置，然后发出 reload_secure_settings 调用，而不是在每次修改后重新加载。 有可重新加载的安全设置: Azure 存储库插件 EC2 发现插件 GCS 存储库插件 S3 存储库插件 监控设置 观察器设置 原文链接 ","version":"Next","tagName":"h2"},{"title":"Elasticsearch 中的监控设置","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"常规监控设置​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#常规监控设置","content":"xpack.monitoring.enabled [7.8.0]（静态）已弃用，设置无效。 ","version":"Next","tagName":"h2"},{"title":"监控集合设置​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#监控集合设置","content":"xpack.monitoring.collection 设置控制如何从 Elasticsearch 节点收集数据。 xpack.monitoring.collection.enabled （动态）[7.1.6] 设置为 true 以启用监控数据的收集。如果此设置为 false（默认值），则不会收集 Elasticsearch 监控数据，并忽略来自其他来源（如 Kibana、Beats 和 Logstash）的所有监控数据。 xpack.monitoring.collection.interval [6.3.0]（动态）从 7.0.0 开始，不再支持设置为 -1 以禁用数据收集。 控制数据采样的频率。默认值为 10s。如果修改收集间隔，请将 kibana.yml 中的 xpack.monitoring.min_interval_seconds 选项设置为相同的值。 xpack.monitoring.elasticsearch.collection.enabled （动态）[7.16.0] 控制是否应收集有关 Elasticsearch 集群的统计信息。默认为 true。这与 xpack.monitoring.collection.enabled 不同，它允许你启用或禁用所有监视集合。然而，此设置只是禁用 Elasticsearch 数据的收集，同时仍允许其他数据通过此集群收集（例如，Kibana、Logstash、Beats 或 APM 服务器监控数据）。 xpack.monitoring.collection.cluster.stats.timeout （动态）[7.16.0] 收集集群统计信息的超时（时间单位）。默认值为 10s。 xpack.monitoring.collection.node.stats.timeout （动态）[7.16.0] 收集节点统计信息的超时（时间单位）。默认值为 10s。 xpack.monitoring.collection.indices （动态）[7.16.0] 控制监控功能从中收集数据的索引。默认为所有索引。将索引名称指定为逗号分隔的列表，例如 test1,test2,test3。名称可以包含通配符，例如 test*。可以通过在 - 前面加前缀来显式排除索引。例如 test*,-test3 将监视除 test3 之外的所有以 test 开头的索引。像 .security* 或 .kibana* 这样的系统索引总是以 . 并且通常应当被监测。可以考虑在索引列表中添加 .*，以确保对系统索引进行监控。例如：.*,test*,-test3 xpack.monitoring.collection.index.stats.timeout （动态）[7.16.0] 收集索引统计信息超时（时间单位）。默认值为 10s。 xpack.monitoring.collection.index.recovery.active_only （动态）[7.16.0] 控制是否收集所有恢复。设置为 true 以仅收集活动恢复。默认为 false。 xpack.monitoring.collection.index.recovery.timeout （动态）[7.16.0] 收集恢复信息的超时（时间单位）。默认值为 10s。 xpack.monitoring.history.duration （动态）[7.16.0] 保留期限，超过该期限后，监控导出器创建的索引将自动删除（时间单位）。默认为 7d（7 天）。 此设置的最小值为 1d（1 天），以确保正在监控某些内容并且无法禁用。 :::danger 重要 此设置当前仅影响 local - 类型导出程序。使用 http 导出器创建的索引不会自动删除。 ::: xpack.monitoring.exporters （静态）配置代理存储监视数据的位置。默认情况下，代理使用本地导出器，该导出器为安装它的集群上的监控数据编制索引。使用 HTTP 导出器将数据发送到单独的监视集群。详细信息，参阅本地导出器设置、HTTP 导出器设置和如何运行。 ","version":"Next","tagName":"h2"},{"title":"本地导出器设置​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#本地导出器设置","content":"local 导出器是监控功能使用的默认导出器。顾名思义，它将数据导出到本地集群，这意味着不需要太多配置。 如果你没有提供任何导出程序，那么监控功能将自动为你创建一个导出程序。如果提供了任何导出器，则不会添加默认值。 xpack.monitoring.exporters.my_local: type: local  type [7.16.0] 本地导出器的值必须始终是 local，并且是必需的。 use_ingest 是否为集群提供占位符管道，并为每个批量请求提供管道处理器。默认值为 true。如果禁用，则意味着它将不使用管道，这意味着将来的版本无法自动将批量请求升级到将来的版本。 cluster_alerts.management.enabled [7.16.0] 是否为此群集创建集群警报。默认值为 true。若要使用此功能，必须启用观察器。如果你拥有基本许可，则不会显示集群警报。 wait_master.timeout [7.16.0] 等待主节点设置本地导出器以进行监控的时间（时间单位）。在等待期之后，非主节点会警告用户可能丢失的配置。默认为 30s。 ","version":"Next","tagName":"h2"},{"title":"HTTP 导出器设置​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#http-导出器设置","content":"以下列出了可以随 http 导出器提供的设置。所有设置都显示为你为导出器选择的名称后面的内容： xpack.monitoring.exporters.my_remote: type: http host: [&quot;host:port&quot;, ...]  type [7.16.0] HTTP 导出器的值必须始终为 http，并且是必需的。 host [7.16.0] 主机支持多种格式，既可以作为数组，也可以作为单个值。支持的格式包括 hostname、hostname:port、http://hostname、http://hostname:port、https://hostname 和 https://hostname:port。无法假定主机。默认协议始终为 http，如果未作为 host 字符串的一部分提供，则默认端口始终为 9200。 xpack.monitoring.exporters: example1: type: http host: &quot;10.1.2.3&quot; example2: type: http host: [&quot;http://10.1.2.4&quot;] example3: type: http host: [&quot;10.1.2.5&quot;, &quot;10.1.2.6&quot;] example4: type: http host: [&quot;https://10.1.2.3:9200&quot;] auth.username [7.16.0] 如果提供了 auth.secure_password，则需要用户名。 auth.secure_password （安全，可重载）[7.16.0] auth.username 的密码。 connection.timeout [7.16.0] HTTP 连接等待套接字打开请求的时间值（时间单位）。默认值为 6s。 connection.read_timeout [7.16.0] HTTP 连接等待套接字发送回响应的时间值（时间单位）。默认值为 10 * connection.timeout（如果两者都未设置，则为 60s）。 ssl [7.16.0] 每个 HTTP 导出器都可以定义自己的 TLS/SSL 设置或继承它们。参阅 X-Pack 监控 TLS/SSL 设置。 proxy.base_path [7.16.0] 前缀任何传出请求的基本路径，例如 /base/path（例如，批量请求将以 /base/path/_bulk 的形式发送）。没有默认值。 headers [7.16.0] 添加到每个请求的可选头，可以帮助通过代理路由请求。 xpack.monitoring.exporters.my_remote: headers: X-My-Array: [abc, def, xyz] X-My-Header: abc123 基于数组的头发送 n 次，其中 n 是数组的大小。Content-Type 和 Content-Length 不能设置。监视代理创建的任何头都将覆盖此处定义的任何内容。 index.name.time_format [7.16.0] 用于更改每日监控索引的默认日期后缀的机制。默认格式为 yyyy.MM.dd。例如，.monitoring-es-7-2021.08.26。 use_ingest 是否为每个批量请求向监视集群和管道处理器提供占位符管道。默认值为 true。如果禁用，则意味着它将不使用管道，这意味着将来的版本无法自动将批量请求升级到将来的版本。 cluster_alerts.management.enabled [7.16.0] 是否为此集群创建集群警报。默认值为 true。若要使用此功能，必须启用观察器。如果你拥有基本许可，则不会显示集群警报。 cluster_alerts.management.blacklist [7.16.0] 防止创建特定集群警报。它还会删除当前集群中已存在的所有适用的监控。 你可以将以下任何监控标识符添加到阻止的警报列表中： elasticsearch_cluster_status elasticsearch_version_mismatch elasticsearch_nodes kibana_version_mismatch logstash_version_mismatch xpack_license_expiration 例如：[&quot;elasticsearch_version_mismatch&quot;,&quot;xpack_license_expiration&quot;]。 ","version":"Next","tagName":"h2"},{"title":"X-Pack 监控 TLS/SSL 设置​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#x-pack-监控-tlsssl-设置","content":"你可以配置以下的 TLS/SSL 设置。 xpack.monitoring.exporters.$NAME.ssl.supported_protocols （静态）[7.16.0] 支持的协议版本。有效协议：SSLv2Hello、SSLv3、TLSv1、TLSv1.1、TLSv1.2、TLSv1.3。如果 JVM 的 SSL 提供程序支持 TLSv1.3，则默认值为 TLSv1.3,TLSv1.2,TLSv1.1。否则，默认值为 TLSv1.2,TLSv1.1。 Elasticsearch 依赖于 JDK 对 SSL 和 TLS 的实现。查看 JDK 版本支持的 SSL/TLS 版本以了解更多信息。 :::tip 注意 如果 xpack.security.fips_mode.enabled 为 true，则不能使用 SSLv2Hello 或 SSLv3。参阅 FIPS 140-2。 ::: xpack.monitoring.exporters.$NAME.ssl.verification_mode （静态）[7.16.0] 控制证书的验证。 有效值： full，它验证所提供的证书是否由可信机构（CA）签名，并验证服务器的主机名（或 IP 地址）是否与证书中标识的名称匹配。 certificate，该证书验证所提供的证书是否由可信机构（CA）签名，但不执行任何主机名验证。 none，它不执行服务器证书的验证。此模式禁用了 SSL/TLS 的许多安全优势，只有在非常仔细的考虑后才能使用。它主要用于解决TLS错误时的临时诊断机制；强烈反对将其用于生产集群。 默认值为 full。 xpack.monitoring.exporters.$NAME.ssl.cipher_suites （静态）[7.16.0] 支持的密码套件因你使用的Java版本而异。例如，对于版本12，默认值为：TLS_AES_256_GCM_SHA384、 TLS_AES_128_GCM_SHA256、 TLS_CHACHA20_POLY1305_SHA256、 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384、 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384、 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、 TLS_RSA_WITH_AES_256_GCM_SHA384、 TLS_RSA_WITH_AES_128_GCM_SHA256、 TLS_RSA_WITH_AES_256_CBC_SHA256、 TLS_RSA_WITH_AES_128_CBC_SHA256、 TLS_RSA_WITH_AES_256_CBC_SHA、 TLS_RSA_WITH_AES_128_CBC_SHA。 有关更多信息，参阅 Oracle 的 Java Cryptography Architecture 文档。 ","version":"Next","tagName":"h2"},{"title":"X-Pack 监控 TLS/SSL 密钥和受信任的证书设置​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#x-pack-监控-tlsssl-密钥和受信任的证书设置","content":"以下设置用于指定在通过 SSL/TLS 连接进行通信时应使用的私钥、证书和受信任证书。私钥和证书是可选的，如果服务器需要客户端认证以进行 PKI 认证，则将使用私钥和证书。 ","version":"Next","tagName":"h3"},{"title":"PEM 编码文件​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#pem-编码文件","content":"使用 PEM 编码文件时，请使用以下设置： xpack.monitoring.exporters.$NAME.ssl.key （静态）[7.16.0] 包含私钥的 PEM 编码文件的路径。 如果需要 HTTP 客户端认证，它将使用此文件。不能同时使用此设置和 ssl.keystore.path。 xpack.monitoring.exporters.$NAME.ssl.key_passphrase （静态）[7.16.0] 用于解密私钥的密码。由于密钥可能未加密，因此此值是可选的。 不能同时使用此设置和 ssl.secure_key_passphrase。 xpack.monitoring.exporters.$NAME.ssl.secure_key_passphrase （安全）[7.16.0] 用于解密私钥的密码。由于密钥可能未加密，因此此值是可选的。 xpack.monitoring.exporters.$NAME.ssl.certificate （静态）[7.16.0] 指定与密钥关联的 PEM 编码证书（或证书链）的路径。 仅当设置了 ssl.key 时，才能使用此设置。 xpack.monitoring.exporters.$NAME.ssl.certificate_authorities （静态）[7.16.0] 7.16.0 已弃用。应信任的 PEM 编码证书文件的路径列表。 此设置和 ssltruststore.path 不能同时使用。 ","version":"Next","tagName":"h3"},{"title":"Java keystore 文件​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#java-keystore-文件","content":"当使用 Java keystore 文件（JKS）（其中包含应信任的私钥、证书和证书）时，请使用以下设置： xpack.monitoring.exporters.$NAME.ssl.keystore.path （静态）[7.16.0] 包含私钥和证书的密钥库文件的路径。 它必须是 Java keystore 库（jks）或 PKCS#12 文件。不能同时使用此设置和 ssl.key。 xpack.monitoring.exporters.$NAME.ssl.keystore.password （静态）[7.16.0] keystore 的密码。 xpack.monitoring.exporters.$NAME.ssl.keystore.secure_password （安全）[7.16.0] keystore 的密码。 xpack.monitoring.exporters.$NAME.ssl.keystore.key_password （静态）[7.16.0] keystore 中密钥的密码。默认值是 keystore 密码。 不能同时使用此设置和 ssl.keystore.secure_password。 xpack.monitoring.exporters.$NAME.ssl.keystore.secure_key_password （安全）[7.16.0] keystore 中密钥的密码。默认值是 keystore 密码。 xpack.monitoring.exporters.$NAME.ssl.truststore.path （静态）[7.16.0] 包含要信任的证书的 keystore 的路径。它必须是 Java keystore 库（jks）或 PKCS#12 文件。 不能同时使用此设置和 ssl.certificate_authorities。 xpack.monitoring.exporters.$NAME.ssl.truststore.password （静态）[7.16.0] truststore 的密码。 不能同时使用此设置和 ssltruststore.secure_password。 xpack.monitoring.exporters.$NAME.ssl.truststore.secure_password （安全）[7.16.0] truststore 的密码。 ","version":"Next","tagName":"h3"},{"title":"PKCS#12 文件​","type":1,"pageTitle":"Elasticsearch 中的监控设置","url":"/docs/elasticsearch-cn/set_up_elasticsearch/configuring_elasticsearch/monitoring_settings_in_elasticsearch#pkcs12-文件","content":"Elasticsearch 可以配置为使用 PKCS#12 容器文件（.p12 或 .pfx 文件），这些文件包含应信任的私钥、证书和证书。 PKCS#12 文件的配置方式与 Java keystore 文件相同： xpack.monitoring.exporters.$NAME.ssl.keystore.path （静态）[7.16.0] 包含私钥和证书的密钥库文件的路径。 它必须是 Java keystore（jks）或 PKCS#12 文件。不能同时使用此设置和 ssl.key。 xpack.monitoring.exporters.$NAME.ssl.keystore.type （静态）[7.16.0] keystore 文件的格式。它必须是 jks 或 PKCS12。如果密钥库路径以 “.p12”、“.pfx” 或 “.pkcs12” 结尾，则此设置默认为 pkcs12。否则，默认为 jks。 xpack.monitoring.exporters.$NAME.ssl.keystore.secure_password （安全）[7.16.0] keystore 密码。 xpack.monitoring.exporters.$NAME.ssl.keystore.key_password （静态）[7.16.0] keystore 中密钥的密码。默认值是 keystore 密码。 不能同时使用此设置和 ssl.keystore.secure_password。 xpack.monitoring.exporters.$NAME.ssl.keystore.secure_key_password （安全）[7.16.0] keystore 中密钥的密码。默认值是 keystore 密码。 xpack.monitoring.exporters.$NAME.ssl.truststore.path （静态）[7.16.0] 包含要信任的证书的 keystore 的路径。它必须是 Java keystore（jks）或 PKCS#12 文件。 不能同时使用此设置和 ssl.certificate_authorities。 xpack.monitoring.exporters.$NAME.ssl.truststore.type （静态）[7.16.0] 将其设置为 PKCS12 以指示信任库是 PKCS#12 文件。 xpack.monitoring.exporters.$NAME.ssl.truststore.password （静态）[7.16.0] truststore 密码。 不能同时使用此设置和 ssltruststore.secure_password。 xpack.monitoring.exporters.$NAME.ssl.truststore.secure_password （安全）[7.16.0] truststore 密码。 原文链接 ","version":"Next","tagName":"h3"},{"title":"安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"托管 Elasticsearch​","type":1,"pageTitle":"安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/#托管-elasticsearch","content":"你可以在自己的硬件上运行 Elasticsearch，或者使用我们在 Elastic Cloud 上的托管 Elasticsearch 服务。Elasticsearch 服务 在 AWS 和 GCP 上都有。免费试用 Elasticsearch 服务。 ","version":"Next","tagName":"h2"},{"title":"自己安装 Elasticsearch​","type":1,"pageTitle":"安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/#自己安装-elasticsearch","content":"Elasticsearch 用以下包格式提供： \tLinux and MacOS tar.gz 存档\ttar.gz 存档可以安装在任何 Linux 发行版和 MacOS。在 Linux 或 MacOS 上用存档安装 Elasticsearch Windows .zip 存档\tzip 存档适用于在 Windows 上安装。在 Windows 上用 .zip 安装 Elasticsearch deb\tdeb 包适用于 Debian、Ubuntu 和其他基于 Debian 的系统。Debian 包可以从 Elasticsearch 网站或者从我们的 Debian仓库下载。用 Debian 包安装 Elasticsearch rpm\trpm 包适用于在 Red Hat、Centos、SLES、OpenSuSE以及其他基于 RPM 的系统上安装。RPM 可以从 Elasticsearch 网站或者从我们的 RPM 仓库下载。用 RPM 安装 Elasticsearch msi\t[测试] msi 包适用于在 安装了不低于 .NET 4.5 framework 的 Windows 64位系统上安装，这是在 Windows 上开始 Elasticsearch 最简单的选择。MSI 可以从 Elasticsearch 网站上下载。用 Windows MSI Installer 安装 Elasticsearch docker\t镜像可以作为 Docker 容器运行 Elasticsearch。可以从 Elasticsearch Docker Registry 下载。用 Docker 安装 Elasticsearch brew\tFormulae 可从 Elastic Homebrew tap 上获得，用 Homebrew 包管理器在 macOS上安装 Elasticsearch。用 Homebrew 在 macOS 上安装 Elasticsearch ","version":"Next","tagName":"h2"},{"title":"配置管理工具​","type":1,"pageTitle":"安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/#配置管理工具","content":"我们也提供以下的配置管理工具用于协助大型部署： \tPuppet\tpuppet-elasticsearch Chef\tcookbook-elasticsearch Ansible\tansible-elasticsearch 原文链接 ","version":"Next","tagName":"h2"},{"title":"使用 Homebrew 在 macOS 上安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/brew","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"Homebrew 安装的目录结构​","type":1,"pageTitle":"使用 Homebrew 在 macOS 上安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/brew#homebrew-安装的目录结构","content":"当你使用 brew install 安装 Elasticsearch，配置文件、日志和数据目录存储在以下位置。 类型\t描述\t默认位置\t设置home\tElasticsearch 主目录或 $ES_HOME\t/usr/local/var/homebrew/linked/elasticsearch-full bin\t二进制脚本，包括启动节点的 elasticsearch 和安装插件的 elasticsearch-plugin\t/usr/local/var/homebrew/linked/elasticsearch-full/bin conf\t配置文件，包括 elasticsearch.yml\t/usr/local/etc/elasticsearch\tES_PATH_CONF data\t分配在节点上的每个索引和分片的数据文件位置。可以有多个位置。\t/usr/local/var/lib/elasticsearch\tpath.data logs\t日志文件位置\t/usr/local/var/log/elasticsearch\tpath.logs plugins\t插件文件位置。每个插件会包含在一个子目录中。\t/usr/local/var/homebrew/linked/elasticsearch/plugins repo\t共享文件系统仓库位置。可以有多个位置。文件系统仓库可以放在此处指定的任何目录的任何子目录中。\t未配置\tpath.repo ","version":"Next","tagName":"h2"},{"title":"下一步​","type":1,"pageTitle":"使用 Homebrew 在 macOS 上安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/brew#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"为 Linux 下载和安装压缩包​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#为-linux-下载和安装压缩包","content":"Elasticsearch v7.11.1 的 Linux 压缩包，可以按以下操作进行下载和安装： wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-linux-x86_64.tar.gz wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-linux-x86_64.tar.gz.sha512 shasum -a 512 -c elasticsearch-7.11.1-linux-x86_64.tar.gz.sha512 tar -xzf elasticsearch-7.11.1-linux-x86_64.tar.gz cd elasticsearch-7.11.1/  shasum -a 512 -c 比较下载的 .tar.gz SHA 值和公开的校验值。正常应该输出 elasticsearch-{version}-linux-x86_64.tar.gz: OK。 cd elasticsearch-7.11.1/ 此目录一般也是环境变量里的 $ES_HOME。 ","version":"Next","tagName":"h2"},{"title":"为 MacOS 下载和安装压缩包​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#为-macos-下载和安装压缩包","content":"Elasticsearch v7.11.1 的 MacOS 压缩包，可以如以下进行下载和安装： wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-darwin-x86_64.tar.gz wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-darwin-x86_64.tar.gz.sha512 shasum -a 512 -c elasticsearch-7.11.1-darwin-x86_64.tar.gz.sha512 tar -xzf elasticsearch-7.11.1-darwin-x86_64.tar.gz cd elasticsearch-7.11.1/  shasum -a 512 -c 比较下载的 .tar.gz SHA 值和公开的校验值。正常应该输出 elasticsearch-{version}-darwin-x86_64.tar.gz: OK。 cd elasticsearch-7.11.1/ 此目录一般也是环境变量里的 $ES_HOME。 ","version":"Next","tagName":"h2"},{"title":"启用系统索引自动创建 [X-Pack]​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#启用系统索引自动创建-x-pack","content":"一些商业特性会在 Elasticsearch 中自动创建索引。默认情况下， Elasticsearch 配置为允许自动创建索引而不需要额外的步骤。然而，如果你在 Elasticsearch 中禁用了自动索引创建，则必须在 elasticsearch.yml 中配置 action.auto_create_index 以允许商业特性创建以下索引： action.auto_create_index: .monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*  警告 如果你在使用 Logstash 或 Beats，那么你很可能需要在你的 action.auto_create_index 设置中使用额外的索引名字，具体的值取决于你的本地配置。如果你不确定你环境的正确值，可以考虑设置这个值为*以允许自动创建所有索引。 ","version":"Next","tagName":"h2"},{"title":"从命令行运行 Elasticsearch​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#从命令行运行-elasticsearch","content":"Elasticsearch 可以如以下从命令行启动： ./bin/elasticsearch  如果你对 Elasticsearch 密钥库进行了密码保护，会提示输入密码库密码。查看安全设置获取更多详情。 默认情况下，Elasticsearch 在前台运行，从标准输出（stdout）打印日志，且可以通过按 Ctrl-C 中止。 提示 所有与 Elasticsearch 关联的脚本，需要一个支持数组版本的 Bash，且 Bash 要放在 /bin/bash中。因此，Bash 需要放在或者通过符号链接到这个路径中。 ","version":"Next","tagName":"h2"},{"title":"检查 Elasticsearch 是否正在运行​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#检查-elasticsearch-是否正在运行","content":"你可以通过向 localhost 的 9200 端口发送 HTTP 请求来测试 Elasticsearch 节点是否正在运行： GET /  这会给你这样的响应： { &quot;name&quot; : &quot;Cp8oag6&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;AT69_T_DTp-1qgIJlatQqA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.11.1&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;f27399d&quot;, &quot;build_date&quot; : &quot;2016-03-30T09:51:41.449Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.7.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;1.2.3&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;1.2.3&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; }  可以在命令行中通过 -q 或 --quiet 选项禁用日志输出到标准输出（stdout）。 ","version":"Next","tagName":"h2"},{"title":"作为守护进程运行​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#作为守护进程运行","content":"要作为守护进程运行 Elasticsearch，在命令行指定 -d，并使用 -p 选项在文件中记录进程 ID： ./bin/elasticsearch -d -p pid  如果你对 Elasticsearch 密码库进行了密码保护，会提示输入密码库密码。查看安全设置获取更多详情。 日志信息可以在 $ES_HOME/logs/ 目录中找到。 要关闭 Elasticsearch，杀死记录在 pid 文件中的 进程 ID： pkill -F pid  提示 Elasticsearch .tar.gz 包不包含 systemd 模块。要把 Elasticsearch 作为服务，改用 Debian 或者 RPM 包。 ","version":"Next","tagName":"h2"},{"title":"在命令行配置 Elasticsearch​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#在命令行配置-elasticsearch","content":"Elasticsearch 默认从 $ES_HOME/configuring_elasticsearch/elasticsearch.yml 加载配置。配置文件的格式在配置 Elasticsearch中解释。 在配置文件中可以指定的设置，也能在命令行中指定，如下使用 -E 语法： ./bin/elasticsearch -d -Ecluster.name=my_cluster -Enode.name=node_1  提示 通常，任意集群范围设置（如 cluster.name）应该添加到 elasticsearch.yml 配置文件中，而任何节点特定设置，如 node.name，应该在命令行中指定。 ","version":"Next","tagName":"h2"},{"title":"压缩包文件目录结构​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#压缩包文件目录结构","content":"压缩包发行版是完全独立的。默认情况下，所有文件和目录都包含在 $ES_HOME——解压压缩包时创建的目录。 这样很方便，因为你不必创建任意目录去启用 Elasticsearch，且卸载 Elasticsearch 就像移除 $ES_HOME 目录一样简单。但是，建议修改默认的配置目录（config）和数据目录（data）以便以后不用删除重要数据。 类型\t描述\t默认位置\t设置home\tElasticsearch 主目录或 $ES_HOME\t解压压缩包创建的目录 bin\t二进制脚本，包括启动节点的 elasticsearch 和安装插件的 elasticsearch-plugin\t$ES_HOME/bin conf\t配置文件，包括 elasticsearch.yml\t$ES_HOME/config\tES_PATH_CONF data\t分配在节点上的每个索引和分片的数据文件位置。可以有多个位置。\t$ES_HOME/data\tpath.data logs\t日志文件位置\t$ES_HOME/logs\tpath.logs plugins\t插件文件位置。每个插件会包含在一个子目录中。\t$ES_HOME/plugins repo\t共享文件系统仓库位置。可以有多个位置。文件系统仓库可以放在此处指定的任何目录的任何子目录中。\t未配置\tpath.repo ","version":"Next","tagName":"h2"},{"title":"下一步​","type":1,"pageTitle":"在 Linux 或 MacOS 上用压缩包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/linux#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"使用 Debian 包安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"导入 Elasticsearch PGP 密钥​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#导入-elasticsearch-pgp-密钥","content":"我们使用带指纹的 Elasticsearch 签名密钥（PGP 密钥 D88E42B4，存在https://pgp.mit.edu上）签名所有的包： 4609 5ACC 8548 582C 1A26 99A9 D27D 666C D88E 42B4 下载和安装公共签名密钥： wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -  ","version":"Next","tagName":"h2"},{"title":"从 APT 仓库安装​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#从-apt-仓库安装","content":"在继续之前，你可能需要在 Debian 上安装 apt-transport-https包： sudo apt-get install apt-transport-https  将仓库定义保存到 /etc/apt/sources.list.d/elastic-7.x.list: echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | sudo tee /etc/apt/sources.list.d/elastic-7.x.list  由于以下原因，指南不使用 add-apt-repository: add-apt-repository 向系统 /etc/apt/sources.list 文件中添加条目，而不是 /etc/apt/sources.list.d 中的每个仓库的干净文件 add-apt-repository 不是许多发行版本的默认安装部分，需要许多非默认的依赖 老版本的 add-apt-repository 总会添加一个 deb-src 条目，由于我们没有提供源包，这会导致错误。如果你已经添加了 deb-src 条目，在你删除 deb-src 条目前，你会看到如下错误： Unable to find expected entry 'main/source/Sources' in Release file (Wrong sources.list entry or malformed file) 你可以这样安装 Elasticsearch Debian 包： sudo apt-get update &amp;&amp; sudo apt-get install elasticsearch  警告 如果 Elasticsearch 仓库中存在两条相同的条目，你在 apt-get update 操作时，会看到如下错误： Duplicate sources.list entry https://artifacts.elastic.co/packages/7.x/apt/ ... 检查 /etc/apt/sources.list.d/elasticsearch-7.x.list 的重复条目，或者在 /etc/apt/sources.list.d/ 中的文件和 /etc/apt/sources.list 文件中定位重复条目。 提示 在基于 systemd 的发行版上，安装脚本尝试设置内核参数（如，vm.max_map_count）；你可以通过屏蔽 systemd-sysctl.service 单位来跳过这个操作。 ","version":"Next","tagName":"h2"},{"title":"手工下载和安装 Debian 包​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#手工下载和安装-debian-包","content":"Elasticsearch v7.11.1 的 Debian 包，可以按以下命令从网站下载和安装： wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-amd64.deb wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.1-amd64.deb.sha512 shasum -a 512 -c elasticsearch-7.11.1-amd64.deb.sha512 sudo dpkg -i elasticsearch-7.11.1-amd64.deb  shasum -a 512 -c 比较下载的 Debian 包 SHA 值和公开的校验值。正常应该输出 elasticsearch-{version}-amd64.deb: OK。 ","version":"Next","tagName":"h2"},{"title":"启用系统索引自动创建 [X-Pack]​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#启用系统索引自动创建-x-pack","content":"一些商业特性会在 Elasticsearch 中自动创建索引。默认情况下， Elasticsearch 配置为允许自动创建索引而不需要额外的步骤。然而，如果你在 Elasticsearch 中禁用了自动索引创建，则必须在 elasticsearch.yml 中配置 action.auto_create_index 以允许商业特性创建以下索引： action.auto_create_index: .monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*  警告 如果你在使用 Logstash 或 Beats，那么你很可能需要在你的 action.auto_create_index 设置中使用额外的索引名字，具体的值取决于你的本地配置。如果你不确定你环境的正确值，可以考虑设置这个值为*以允许自动创建所有索引。 ","version":"Next","tagName":"h2"},{"title":"SysV init 对 systemd​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#sysv-init-对-systemd","content":"Elasticsearch 在安装后不会自动启动。如何启动和停止 Elasticsearch，取决于你的系统用的 SysV init 还是 systemd（更新的发行版用的）。你可以通过以下命令来判断用的哪个： ps -p 1  ","version":"Next","tagName":"h2"},{"title":"使用 SysV init 运行 Elasticsearch​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#使用-sysv-init-运行-elasticsearch","content":"使用 update-rc.d 命令配置当系统启动时自动启动 Elasticsearch： sudo update-rc.d elasticsearch defaults 95 10  Elasticsearch 可以使用 service 命令来启动和停止： sudo -i service elasticsearch start sudo -i service elasticsearch stop  如果 Elasticsearch 由于任何原因启动失败，它会输出失败原因到标准输出（STDOUT）。日志文件可以在 /var/log/elasticsearch/ 中被找到。 ","version":"Next","tagName":"h2"},{"title":"使用 systemd 运行 Elasticsearch​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#使用-systemd-运行-elasticsearch","content":"为了配置 Elasticsearch 在系统启动时自动启动，运行以下命令： sudo /bin/systemctl daemon-reload sudo /bin/systemctl enable elasticsearch.service  Elasticsearch 可以按以下方式启动和停止： sudo systemctl start elasticsearch.service sudo systemctl stop elasticsearch.service  这些命令不提供 Elasticsearch 运行成功与否的反馈。相反，信息写在位于 /var/log/elasticsearch/ 中的日志文件。 如果你的 Elasticsearch 密码库受密码保护，你需要使用本地文件和 systemd 环境变量向密码库提供密码。本地文件存在时，应该受到保护，一旦 Elasticsearch 启动并运行，就可以安全删除此文件。 echo &quot;keystore_password&quot; &gt; /path/to/my_pwd_file.tmp chmod 600 /path/to/my_pwd_file.tmp sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=/path/to/my_pwd_file.tmp sudo systemctl start elasticsearch.service  默认情况下，Elasticsearch 服务不会在 systemd 日志中记录信息。要启用 journalctl 日志，必须从文件 elasticsearch.service 中的 ExecStart 命令行移除 --quiet 选项。 当 systemd 日志启用时，使用 journalctl 命令日志信息可用。 要跟踪日志： sudo journalctl -f  列出 Elasticsearch 服务的日志条目： sudo journalctl --unit elasticsearch  要列出从给定时间开始的 Elasticsearch 服务的日志条目，请执行以下操作： sudo journalctl --unit elasticsearch --since &quot;2016-10-30 18:17:16&quot;  检查 man journalctl 或者 https://www.freedesktop.org/software/systemd/man/journalctl.html 获取更多的命令行选项。 ","version":"Next","tagName":"h2"},{"title":"检查 Elasticsearch 是否正在运行​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#检查-elasticsearch-是否正在运行","content":"你可以通过向 localhost 的 9200 端口发送 HTTP 请求来测试 Elasticsearch 节点是否正在运行： GET /  这会给你这样的响应： { &quot;name&quot; : &quot;Cp8oag6&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;AT69_T_DTp-1qgIJlatQqA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.11.1&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;f27399d&quot;, &quot;build_date&quot; : &quot;2016-03-30T09:51:41.449Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.7.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;1.2.3&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;1.2.3&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; }  ","version":"Next","tagName":"h2"},{"title":"配置 Elasticsearch​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#配置-elasticsearch","content":"/etc/elasticsearch 目录包含 Elasticsearch 默认运行时配置。该目录和所包含的所有文件所有权在包安装时设置为 root:elasticsearch。 setgid 标志对目录 /etc/elasticsearch 应用组权限，以确保 Elasticsearch 能读取任何包含的文件和子目录。所有文件和子目录继承 root:elasticsearch 所有权。从该目录或者任何子目录运行命令，如 elasticsearch-keystore 工具，需要 root:elasticsearch 权限。 Elasticsearch 默认从 /etc/elasticsearch/elasticsearch.yml 文件加载它的配置。在配置 Elasticsearch 中解释了配置文件的格式。 Debian 包也有一个系统配置文件（/etc/default/elasticsearch），它允许你设置以下的变量： \tJAVA_HOME\t设置使用的自定义 Java 路径 MAX_OPEN_FILES\t打开文件的最大值，默认为 65535 MAX_LOCKED_MEMORY\t最大锁定内存值。如果你在 elasticsearch.yml 中使用 bootstrap.memory_lock 选项，设置为 unlimited。 MAX_MAP_COUNT\t进程可能具有的最大内存映射区域数。如果你使用 mmapfs 作为索引存储类型，请确保将其设置一个高值。有关更多的信息，请查看关于 max_map_count 的 linux 内核文档。在 Elasticsearch 启动前，通过 sysctl 设置，默认为 262144。 ES_PATH_CONF\t配置文件目录（需要包含 elasticsearch.yml、jvm.options 和 log4j2.properties 文件），默认为 /etc/elasticsearch。 ES_JAVA_OPTS\t你想应用的任何其他 JVM 系统属性。 RESTART_ON_UPGRADE\t在包升级时配置重启，默认为 false。这意味着你必须在手工安装包后重启你的 Elasticseach 实例。这样做的原因是为了确保集群的升级不会导致持续的分片重分配，进而导致的高网络流量和降低了集群的响应时间。 提示 使用 systemd 的发行版本要求需要通过 systemd 配置系统资源限制，而不是通过 /etc/sysconfig/elasticsearch 文件。更多信息，请参阅 Systemd 配置。 ","version":"Next","tagName":"h2"},{"title":"Debian 包目录结构​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#debian-包目录结构","content":"Debian 包将配置文件、日志和数据目录放在基于 Debian 系统的适当位置： 类型\t描述\t默认位置\t设置home\tElasticsearch 主目录或 $ES_HOME\t/usr/share/elasticsearch bin\t二进制脚本，包括启动节点的 elasticsearch 和安装插件的 elasticsearch-plugin\t/usr/share/elasticsearch/bin conf\t配置文件，包括 elasticsearch.yml\t/etc/elasticsearch\tES_PATH_CONF conf\t环境变量，包括堆大小，文件描述符。\t/etc/default/elasticsearch data\t分配在节点上的每个索引和分片的数据文件位置。可以有多个位置。\t/var/lib/elasticsearch\tpath.data jdk\t用于运行 Elasticsearch 的捆绑 Java 开发工具包。可以通过在 /etc/default/elasticsearch 中覆盖 JAVA_HOME环境变量。\t/usr/share/elasticsearch/jdk logs\t日志文件位置\t/var/log/elasticsearch\tpath.logs plugins\t插件文件位置。每个插件会包含在一个子目录中。\t/usr/share/elasticsearch/plugins repo\t共享文件系统仓库位置。可以有多个位置。文件系统仓库可以放在此处指定的任何目录的任何子目录中。\t未配置\tpath.repo ","version":"Next","tagName":"h2"},{"title":"下一步​","type":1,"pageTitle":"使用 Debian 包安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/debian#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"使用 Windows MSI 安装程序安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"下载 .msi 包​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#下载-msi-包","content":"从 https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.2.msi 下载 Elasticsearch v7.11.2 .msi 包。 ","version":"Next","tagName":"h2"},{"title":"使用图形化界面（GUI）安装​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#使用图形化界面gui安装","content":"双击下载的 .msi 包以启动 GUI 向导，它会引导你完成安装过程。任何一步，你都可以通过点击 ? 按钮浏览帮助，它会通过侧面板展示每一个输入的附加信息：  在每个界面，选择安装的目录。此外，选择数据、日志以及配置的目录或者[使用默认位置](/msi#命令行选项）：  接着，按需选择是作为服务安装还是手工启动 Elasticsearch。作为服务安装时，你还可以配置运行这个服务的 Windows 账户、安装后是否启动以及 Windows 启动行为。  警告 当选择运行服务的 Windows 账户时，请确保选择的账户有足够的权限访问安装和其他选择的部署目录。还要确保这个账户能运行 Windows 服务。 公共配置在配置页展示，除了内存和网络设置，还支持集群名字、节点名字以及角色设置：  作为安装的一部分，可以下载和安装一系列常见插件，通过配置 HTTPS 代理选项就可以下载这些插件。 提示 确保安装机器可能访问互联网，且任何公司防火墙已配置允许从 artifacts.elastic.co 下载：  从 6.3.0 版本开始，默认情况下 X-Pack 是捆绑的。除了安全配置和内置用户配置，最后一步允许选择要安装的授权类型：  在点击安装按钮后，安装开始：  然后安装成功后会展示：  ","version":"Next","tagName":"h3"},{"title":"使用命令行安装​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#使用命令行安装","content":".msi 也可以通过命令行安装 Elasticsearch。使用与图形化界面相同的默认配置的最简单安装，就是先定位到下载目录，然后运行： msiexec.exe /i elasticsearch-7.11.2.msi /qn  默认情况下， msiexec.exe 不会等待安装进程完成，因为它在 Windows 子系统中运行。要等待进程完成，并确保相应设置了 %ERRORLEVEL%，推荐使用 start /wait 去创建进程并等待它退出。 start /wait msiexec.exe /i elasticsearch-7.11.2.msi /qn  与任何 MSI 安装包一样，安装过程的日志文件可以在 %TEMP% 目录中找到，随机生成文件名的格式为 MSI&lt;random&gt;.LOG。日志文件的路径 可以通过 /l 命令行参数提供。 start /wait msiexec.exe /i elasticsearch-7.11.2.msi /qn /l install.log  Windows 安装程序支持的命令行参数可以通过以下查看： msiexec.exe /help  或者查阅 Windows 安装程序 SDK命令行选项 ","version":"Next","tagName":"h3"},{"title":"命令行选项​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#命令行选项","content":"GUI 中展示的设置也可以用作命令行参数（在 Windows 安装程序文档中叫作属性），这些参数可传递给 msiexec.exe： \tINSTALLDIR\t安装目录。目录结尾必须是 Elasticsearch 的版本。默认为 %ProgramW6432%\\Elastic\\Elasticsearch\\7.11.2. DATADIRECTORY\t存储数据的目录。默认为 %ALLUSERSPROFILE%\\Elastic\\Elasticsearch\\data CONFIGDIRECTORY\t存储配置的目录。默认为 %ALLUSERSPROFILE%\\Elastic\\Elasticsearch\\config LOGSDIRECTORY\t存储日志的目录。默认为 %ALLUSERSPROFILE%\\Elastic\\Elasticsearch\\logs PLACEWRITABLELOCATIONSINSAMEPATH\t是否在安装目录下创建数据、配置和日志目录。默认为 false INSTALLASSERVICE\tElasticsearch 是否作为 Windows 服务安装和配置。默认为 true STARTAFTERINSTALL\t在安装完成后是否启动此 Windows 服务。默认为 true STARTWHENWINDOWSSTARTS\t当 Windows 启动时是否记启动此 Windows 服务。默认为 true USELOCALSYSTEM\t此Windows 服务是否以 LocalSystem 账户运行。默认为 true USENETWORKSERVICE\t此Windows 服务是否以 NetworkService 账户运行。默认为 false USEEXISTINGUSER\t此Windows 服务是否以指定的现有账户运行。默认为 false USER\t运行此 Windows 服务账户名。默认为 “” PASSWORD\t运行此 Windows 服务的账户的密码。默认为“” CLUSTERNAME\t集群名字。默认为 elasticsearch NODENAME\t节点的名字。默认为 %COMPUTERNAME% MASTERNODE\t此 Elasticsearch 是否配置作为主节点。默认为 true DATANODE\t此 Elasticsearch 是否配置作为数据节点。默认为 true INGESTNODE\t此 Elasticsearch 是否配置作为预处理节点。默认为 true SELECTEDMEMORY\t分配给 Elasticsearch 的 JVM 堆内存大小。默认为 2048，除非目标机器内存总共小于 4 GB，这种情况默认为总内存的 50% LOCKMEMORY\t是否 bootstrap.memory_lock 应用于尝试锁定进程地址空间到内存中。默认为 false UNICASTNODES\t用逗号分割的用于单播发现的主机列表，格式为 host:port 或 host 。默认为 “” MINIMUMMASTERNODES\t形成集群的符合主节点的节点最小数量。默认为 “” NETWORKHOST\t要把节点绑定和发布（广播）该主机到集群中其他节点的主机名或者 IP 地址。默认为 “” HTTPPORT\t用于通过 HTTP 暴露 Elasticsearch API 的端口。默认为 9200 TRANSPORTPORT\t用于集群内节点间内部通信的端口。默认为 9300 PLUGINS\t作为安装一部分，逗号分割的下载和安装的插件列表。默认为 “” HTTPSPROXYHOST\t通过 HTTPS 下载插件的代理主机。默认为 “” HTTPSPROXYPORT\t通过 HTTPS 下载插件的代理端口。默认为 443 HTTPPROXYHOST\t通过 HTTP 下载插件的代理主机。默认为 “” HTTPPROXYPORT\t通过 HTTP 下载插件的代理端口。默认为 80 XPACKLICENSE\t安装的授权类型。Basic 或者 Trial。默认为 Basic XPACKSECURITYENABLED\t使用 Trial 授权安装时，是否启用安全特性。默认为 true BOOTSTRAPPASSWORD\t使用 Trial 授权安装时，且安全特性启用，用于引导集群并作为 bootstrap.password 设置存在密码库中。默认为随机值 SKIPSETTINGPASSWORDS\t使用 Trial 授权安装时，且安全特性启用，安装是否跳过设置内置用户。默认为 false ELASTICUSERPASSWORD\t使用 Trial 授权安装时，且安全特性启用，用作内置用户 elastic 的密码。默认为 “” KIBANAUSERPASSWORD\t使用 Trial 授权安装时，且安全特性启用，用作内置用户 kibana 的密码。默认为 “” LOGSTASHSYSTEMUSERPASSWORD\t使用 Trial 授权安装时，且安全特性启用，用作内置用户 logstash_system 的密码。默认为 “” 要传值，只需把属性名字和值，按格式 &lt;PROPERTYNAME&gt;=&quot;&lt;VALUE&gt;&quot; 添加给安装命令。比如，使用与默认安装目录不同的目录： start /wait msiexec.exe /i elasticsearch-7.11.2.msi /qn INSTALLDIR=&quot;C:\\Custom Install Directory{version}&quot;  有关包含引号的值的其他规则，请参阅 Windows 安装程序 SDK 命令行选项。 ","version":"Next","tagName":"h3"},{"title":"启用系统索引自动创建 [X-Pack]​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#启用系统索引自动创建-x-pack","content":"一些商业特性会在 Elasticsearch 中自动创建索引。默认情况下， Elasticsearch 配置为允许自动创建索引而不需要额外的步骤。然而，如果你在 Elasticsearch 中禁用了自动索引创建，则必须在 elasticsearch.yml 中配置 action.auto_create_index 以允许商业特性创建以下索引： action.auto_create_index: .monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*  警告 如果你在使用 Logstash 或 Beats，那么你很可能需要在你的 action.auto_create_index 设置中使用额外的索引名字，具体的值取决于你的本地配置。如果你不确定你环境的正确值，可以考虑设置这个值为*以允许自动创建所有索引。 ","version":"Next","tagName":"h2"},{"title":"从命令行运行 Elasticsearch​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#从命令行运行-elasticsearch","content":"一旦安装，如果未作为服务安装以及配置安装完成后启动，Elasticsearch 可以从命令行启动，如下： .\\bin\\elasticsearch.exe  命令行终端将展示类似于以下的输出：  默认情况下，Elasticsearch 在前台运行，除了向 LOGSDIRECTORY 中 &lt;cluster name&gt;.log 文件打印日志，还将日志打印到标准输出（STDOUT），且可以通过 Ctrl-C 中止。 ","version":"Next","tagName":"h2"},{"title":"在命令行配置 Elasticsearch​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#在命令行配置-elasticsearch","content":"Elasticsearch 默认从文件 %ES_PATH_CONF%\\elasticsearch.yml 加载配置。在配置 Elasticsearch 中解释了配置文件的格式。 在配置文件中可以指定的设置，也能在命令行中指定，如下使用 -E 的语法： .\\bin\\elasticsearch.exe -E cluster.name=my_cluster -E node.name=node_1  提示 包含空格的值必须使用引号括起来。如 -Epath.logs=&quot;C:\\My Logs\\logs&quot;。 提示 通常，任意集群范围设置（如 cluster.name）应该添加到 elasticsearch.yml 配置文件中，而任何节点特定设置，如 node.name，应该在命令行中指定。 ","version":"Next","tagName":"h2"},{"title":"检查 Elasticsearch 是否正在运行​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#检查-elasticsearch-是否正在运行","content":"你可以通过向 localhost 的 9200 端口发送 HTTP 请求来测试 Elasticsearch 节点是否正在运行： GET /  这会给你这样的响应： { &quot;name&quot; : &quot;Cp8oag6&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;AT69_T_DTp-1qgIJlatQqA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.11.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;f27399d&quot;, &quot;build_date&quot; : &quot;2016-03-30T09:51:41.449Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.7.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;1.2.3&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;1.2.3&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; }  ","version":"Next","tagName":"h2"},{"title":"在 Windows 上作为服务安装 Elasticsearch​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#在-windows-上作为服务安装-elasticsearch","content":"Elasticsearch 可以作为服务安装在后台运行，也可以没有任何用户交互下，在系统启动时自动启动。这可以在安装时使用以下命令行选项实现： INSTALLASSERVICE=trueSTARTAFTERINSTALL=trueSTARTWHENWINDOWSSTARTS=true 一旦安装，Elasticsearch 就会出现在服务控制面板：  而且，可以在控制面板中或从命令行使用以下命令停止和重启： 命令行： sc.exe stop Elasticsearch sc.exe start Elasticsearch  Powershell： Get-Service Elasticsearch | Stop-Service Get-Service Elasticsearch | Start-Service  在安装后，可以修改 jvm.options 和 elasticsearch.yml 配置文件用来配置服务。大多数的修改（如 JVM 设置），都需要重启服务才能生效。 ","version":"Next","tagName":"h2"},{"title":"使用图形化界面（GUI）升级​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#使用图形化界面gui升级","content":".msi 包支持升级已安装的 Elasticsearch 版本到更新的版本。通过 GUI 的升级过程处理升级所有已安装的插件，以及保留数据和配置。 下载并双击更新版本的 .msi 包将启动 GUI 向导。第一步将列出之前安装的只读属性：  下一步允许更改某些配置选项：  最后，插件步骤允许升级或删除当前安装的插件，对于当前未安装的插件，可以下载并安装：  ","version":"Next","tagName":"h2"},{"title":"使用命令行升级​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#使用命令行升级","content":".msi 还可以使用命令行升级 Elasticsearch。 警告 命令行升级需要传递与第一次安装一致的命令行属性；Windows 安装程序不会记录这些属性。 例如，如果你最初使用命令行选项 PLUGINS=&quot;ingest-geoip&quot; 和 LOCKMEMORY=&quot;true&quot; 来安装，那通过命令行升级也要传递相同的值。 例外是 INSTALLDIR 参数（如果最初指定了），它必须与当前安装目录不同。如果设置 INSTALLDIR，路径中的结尾必须是 Elasticsearch 的版本，如： C:\\Program Files\\Elastic\\Elasticsearch\\7.11.2 如果 Elasticsearch 是使用所有默认值安装的，最简单的升级是先定位到下载目录，然后运行： start /wait msiexec.exe /i elasticsearch-7.11.2.msi /qn  与安装过程类似，可以通过传递 /l 命令行参数指定升级过程的日志文件路径： start /wait msiexec.exe /i elasticsearch-7.11.2.msi /qn /l upgrade.log  ","version":"Next","tagName":"h2"},{"title":"使用 添加/移除程序 卸载​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#使用-添加移除程序-卸载","content":".msi 包会处理作为安装的一部分的所有目录和文件的卸载。 警告 卸载将删除作为安装部分创建的所有内容，数据、配置或日志目录除外。建议在升级前复制数据目录，或考虑使用快照 API。 MSI 安装包不提供用于卸载 GUI。通过按 Windows 键并输入 add or remove programs 以打开系统设置，即可卸载已安装的程序。 一旦打开，在已安装应用列表中找到 Elasticsearch ，点击并选择卸载：  这会启动卸载过程。 ","version":"Next","tagName":"h2"},{"title":"使用命令行卸载​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#使用命令行卸载","content":"通过导航到包含 .msi 包的目录，并运行以下命令，可以从命令行执行卸载： start /wait msiexec.exe /x elasticsearch-7.11.2.msi /qn  与安装过程类似，可以使用 /l 命令行参数传递卸载过程的日志文件路径： start /wait msiexec.exe /x elasticsearch-7.11.2.msi /qn /l uninstall.log  ","version":"Next","tagName":"h2"},{"title":"下一步​","type":1,"pageTitle":"使用 Windows MSI 安装程序安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/msi#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"使用 Docker 安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"拉取镜像​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#拉取镜像","content":"Docker 上获取 Elasticsearch，简单到只要向 Elastic Docker 仓库发出 docker pull 命令一样。 docker pull docker.elastic.co/elasticsearch/elasticsearch:7.11.2  ","version":"Next","tagName":"h2"},{"title":"使用 Docker 启动单节点集群​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#使用-docker-启动单节点集群","content":"要启动单节点 Elasticsearch 集群进行开发或测试，请指定单节点发现以绕过启动检查： docker run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.11.2  ","version":"Next","tagName":"h2"},{"title":"使用 Docker Compose 启动多节点集群​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#使用-docker-compose-启动多节点集群","content":"为了在 Docker 中启动和运行一个三节点 Elasticsearch 集群，你可以使用 Docker Compose： 创建一个 docker-compose.yml 文件： version: '2.2' services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:7.11.2 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: docker.elastic.co/elasticsearch/elasticsearch:7.11.2 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data02:/usr/share/elasticsearch/data networks: - elastic es03: image: docker.elastic.co/elasticsearch/elasticsearch:7.11.2 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data03:/usr/share/elasticsearch/data networks: - elastic volumes: data01: driver: local data02: driver: local data03: driver: local networks: elastic: driver: bridge  提示 例子中的 docker-compose.yml 使用环境变量 ES_JAVA_OPTS 手工设置堆大小为 512 MB。我们不推荐在生产环境使用 ES_JAVA_OPTS。参看手工设置堆大小。 这个示例 Docker Compose 文件，提供了一个三节点 Elasticsearch 集群。节点 es01 监听 localhost:9200，es02 和 es03 通过 Docker 网络与 es01 通信。 请注意此配置在所有网络接口上暴露端口 9200，并且考虑到 Docker 怎么在 Linux 上操作 iptables，这意味着你的 Elasticsearch 集群可以公开访问，可能会忽略任何防火墙设置。如果你不想暴露端口 9200，转而使用反向代理，在 docker-compose.yml 文件中用 127.0.0.1:9200:9200 替代 9200:9200。Elasticsearch 将只能从主机自身访问。 Docker 命名卷 data01、data02 和 data03 存储节点数据目录，以便重启时数据持续存在。如果他们不存在，docker-compose 将会在你创建集群时创建他们。 确保 Docker Engine 分配了至少 4 GiB 内存。在 Docker 桌面中，你可以在首选项（macOS）或设置（Windows）的高级选项卡中配置资源使用。 提示 在 Linux 上，Docker Compose 未与 Docker 一起预装。在 docs.docker.com 查看安装指南：在 Linux 安装 Compose 运行 docker-compose 以启动集群： docker-compose up  提交请求 _cat/nodes 查看节点是否启动运行 curl -X GET &quot;localhost:9200/_cat/nodes?v=true&amp;pretty&quot;  日志消息进入控制台，由配置的 Docker 日志驱动处理。默认情况下，你可以使用 docker logs 访问日志。如果你更想 Elasticsearch 容器把日志写入磁盘，设置环境变量 ES_LOG_STYLE 为 file。这将导致 Elasticsearch 使用与其他 Elasticsearch 分发格式相同的配置。 要停止集群，运行 docker-compose down。当你使用 docker-compose up 重启集群，Docker 卷中的数据将被保存和加载。为了在停止集群时删除数据卷，指定 -v 选项： docker-compose down -v。 ","version":"Next","tagName":"h2"},{"title":"启动开启 TLS 的多节点集群​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#启动开启-tls-的多节点集群","content":"参阅 在Elasticsearch Docker 容器的加密通信和在 Docker 中开启 TLS 运行 Elastic 栈。 ","version":"Next","tagName":"h3"},{"title":"在生产环境使用 Docker 镜像​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#在生产环境使用-docker-镜像","content":"以下要求和建议适用于生产环境中在 Docker 中运行 Elasticsearch。 ","version":"Next","tagName":"h2"},{"title":"设置 vm.max_map_count 至少为 262144​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#设置-vmmax_map_count-至少为-262144","content":"在生产环境使用，vm.max_map_count 内核设置必须至少为 262144。 如何设置 vm.max_map_count 基于你的平台： Linux vm.max_map_count 应该永久设置在 /etc/sysctl.conf： grep vm.max_map_count /etc/sysctl.conf vm.max_map_count=262144  在运行的系统中应用此配置，执行： sysctl -w vm.max_map_count=262144  带 Mac 版 Docker 的 macOS vm.max_map_count 设置必须在 xhyve 虚机中设置： a. 从命令行运行： screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty  b. 按回车，使用 &quot;sysctl&quot; 配置 vm.max_map_count ： sysctl -w vm.max_map_count=262144  c. 退出 screen 会话，按 Ctrl a d 带 Docker 桌面版的 Windows 和 macOS vm.max_map_count 必须通过 docker-machine 设置。 docker-machine ssh sudo sysctl -w vm.max_map_count=262144  带 Docker WSL 2 后端桌面版的 Windows vm.max_map_count 必须在 docker-desktop 容器中设置。 wsl -d docker-desktop sysctl -w vm.max_map_count=262144  ","version":"Next","tagName":"h3"},{"title":"配置文件必须可被用户 elasticsearch 用户读取​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#配置文件必须可被用户-elasticsearch-用户读取","content":"默认情况下，Elasticsearch 通过 uid:gid 1000:0，以用户 elasticsearch 在容器中运行。 警告 一个例外是 OpenShift，它使用任意分配的用户 ID 运行容器。OpenShift 显示的持久卷的 gid 设置为 0，它可以无需调整的运行。 如果你要绑定挂载本地目录或文件，它必须可被用户 elasticsearch 读取。此外，此用户对 配置、数据和日志目录有写权限（Elasticsearch 需要对 config 目录有写权限，这样它才能生成密钥库）。一个好的策略是为本地目录 gid 0 分配组访问权限。 例如，要准备本地目录以通过绑定挂载来存储数据，按以下操作： mkdir esdatadir chmod g+rwx esdatadir chgrp 0 esdatadir  你也可以使用自定义 UID 和 GID 来运行 Elasticsearch 容器。除非你绑定挂载每个 config、data 和 logs 目录，否则必须为 docker run 传递命令行选项 --group-add 0。这样可以确保运行 Elasticsearch 的用户也是容器 root （GID 0）组的成员。 最后，你还可以通过环境变量 TAKE_FILE_OWNERSHIP 强制容器更改用于数据和日志目录的绑定挂载的所有权。当你这样做的时候，它们将属于 uid:gid 1000:0，它提供了 Elasticsearch 进程所需的读写访问权限。 ","version":"Next","tagName":"h3"},{"title":"为 nofile 和 nproc 增加 ulimit​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#为-nofile-和-nproc-增加-ulimit","content":"必须为 Elasticsearch 容器提供 nofile 和 nproc 增加 ulimit。验证 Docker 的守护进程是否的 init system 是否将它们设置为可接受的值。 为了检测 Docker 守护进程默认的 ulimit，执行： docker run --rm centos:8 /bin/bash -c 'ulimit -Hn &amp;&amp; ulimit -Sn &amp;&amp; ulimit -Hu &amp;&amp; ulimit -Su'  如果需要，在守护进程中调整他们，或者在每个容器中重载他们。例如，使用 docker run 时，设置： --ulimit nofile=65535:65535  ","version":"Next","tagName":"h3"},{"title":"禁用 swapping​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#禁用-swapping","content":"为了提高性能和节点稳定性，swapping 需要禁用。有关执行此操作的更多信息，请参阅 禁用 swapping。 如果你选择 bootstrap.memory_lock: true，你也需要在 Docker 守护进程中定义 memlock: true 限定，或者如示例 compose 文件中显示的设置。当使用 docker run，你可以指定： -e &quot;bootstrap.memory_lock=true&quot; --ulimit memlock=-1:-1 ","version":"Next","tagName":"h3"},{"title":"随机发布端口​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#随机发布端口","content":"镜像暴露 TCP 端口 9200 和 9300。对生产环境集群，推荐通过 --publish-all 随机发布端口，除非你为每个主机固定一个容器。 ","version":"Next","tagName":"h3"},{"title":"手工设置堆大小​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#手工设置堆大小","content":"默认情况下，Elasticsearch 基于节点的角色和节点容器总可用内存，自动地设置 JVM 堆。对大多数生产环境，我们推荐默认大小设置。如果有需要，你可以通过手工设置 JVM 堆大小来重载默认设置。 为了在生产环境手工设置堆大小，绑定挂载包含了你期望的堆大小设置的 JVM 选项文件（在 /usr/share/elasticsearch/configuring_elasticsearchjvm.options.d中）。 用于测试的话，你可以通过环境变量 ES_JAVA_OPTS 手工设置堆大小。例如，要用 16 GB，通过 docker run 指定 -e ES_JAVA_OPTS=&quot;-Xms16g -Xmx16g&quot;。ES_JAVA_OPTS 重载所有其他 JVM 选项。在生产环境，我们不推荐使用 ES_JAVA_OPTS。上方的 docker-compose.yml 可以看到设置堆大小为 512 MB。 ","version":"Next","tagName":"h3"},{"title":"部署固定为指定的镜像版本​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#部署固定为指定的镜像版本","content":"将部署固定为指定的 Elasticsearch Docker 镜像。例如 docker.elastic.co/elasticsearch/elasticsearch:7.11.2。 ","version":"Next","tagName":"h3"},{"title":"始终绑定数据卷​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#始终绑定数据卷","content":"出于以下原因，你应该对 /usr/share/elasticsearch/data 使用卷绑定： 如果容器被杀死，Elasticsearch 节点数据不会丢失Elasticsearch 对 I/O 敏感，而 Docker 存储驱动不适合快速 I/O允许使用高级 Docker 卷插件 ","version":"Next","tagName":"h3"},{"title":"禁止使用 loop-lvm 模式​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#禁止使用-loop-lvm-模式","content":"如果你正在使用 devicemapper 存储驱动，不要使用默认的 loop-lvm 模式。配置 docker-engine 以使用 direct-lvm。 ","version":"Next","tagName":"h3"},{"title":"集中你的日志​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#集中你的日志","content":"考虑使用不同的日志驱动来集中日志。还要注意，默认的 json-file 日志驱动不适合生产环境。 ","version":"Next","tagName":"h3"},{"title":"使用 Docker 配置 Elasticsearch​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#使用-docker-配置-elasticsearch","content":"当你在 Docker 中运行时， Elasticsearch 配置文件从 /usr/share/elasticsearch/configuring_elasticsearch 加载。为了使用自定义配置文件，你要绑定挂载文件到镜像中的配置文件上。 你可以通过环境变量设置独立的 Elasticsearch 配置参数。示例 compose 文件和单节点示例就用的这种方法。 要使用文件内容设置环境变量，给环境变量名字加上后缀 _FILE。这对于秘密传输配置（如密码）给 Elasticsearch，而不是直接指定它们非常有用。 例如，为了从文件设置 Elasticsearch 的启动密码，你可以绑定挂载这个文件，然后在挂载路径中设置环境变量ELASTIC_PASSWORD_FILE。如果你挂载的密码文件为 /run/secrets/bootstrapPassword.txt,如下指定： -e ELASTIC_PASSWORD_FILE=/run/secrets/bootstrapPassword.txt  你还可以通过传递 Elasticsearch 配置参数作为命令行选项，来重载默认的命令。例如： docker run &lt;various parameters&gt; bin/elasticsearch -Ecluster.name=mynewclustername  虽然绑定挂载配置文件通常在生产环境是首选方法，你也可以创建包含你自己配置的自定义 Docker 镜像。 ","version":"Next","tagName":"h2"},{"title":"挂载 Elasticsearch 配置文件​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#挂载-elasticsearch-配置文件","content":"创建自定义配置文件，将其绑定挂载到 Docker 镜像的相应文件上。例如，使用 docker run 绑定挂载 custom_elasticsearch.yml，如下指定： -v full_path_to/custom_elasticsearch.yml:/usr/share/elasticsearch/configuring_elasticsearch/elasticsearch.yml  警告 容器以用户 elasticsearch，使用 uid:gid 1000:0 运行 Elasticsearch。绑定挂载的主机目录和文件，必须能被此用户访问，且数据和日志目录必须能被此用户写入。 ","version":"Next","tagName":"h3"},{"title":"挂载 Elasticsearch 密钥库​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#挂载-elasticsearch-密钥库","content":"默认情况下，Elasticsearch 会为安全设置自动生成密钥库文件。这个文件是混淆的，但没有加密。如果你想使用密码加密你的安全设置，你必须使用 elasticsearch-keystore 程序去创建一个密码保护的密钥库，然后绑定挂载它到容器中文件 /usr/share/elasticsearch/configuring_elasticsearchelasticsearch.keystore。为了在启动时向 Docker 容器提供密码，将 Docker 的环境变量值 KEYSTORE_PASSWORD 设置为密码值。例如，docker run 命令可以有以下的选项： -v full_path_to/elasticsearch.keystore:/usr/share/elasticsearch/configuring_elasticsearch/elasticsearch.keystore -E KEYSTORE_PASSWORD=mypassword  ","version":"Next","tagName":"h3"},{"title":"使用自定义 Docker 镜像​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#使用自定义-docker-镜像","content":"在一些环境中，准备包含你配置的自定义镜像更有意义。实现这一点的 Dockerfile 可能如下一样简单： FROM docker.elastic.co/elasticsearch/elasticsearch:7.11.2 COPY --chown=elasticsearch:elasticsearch elasticsearch.yml /usr/share/elasticsearch/configuring_elasticsearch  你可以这样构建和运行镜像： docker build --tag=elasticsearch-custom . docker run -ti -v /usr/share/elasticsearch/data elasticsearch-custom  一些插件需要额外的安全权限。你必须通过以下方式明确接受它们： 当你运行 Docker 镜像时，附加 tty 并在提供时允许权限。通过向插件安装命令添加 --batch 标志来检查安全权限，并且接受它们（如果合适） 参阅插件管理，获取更多信息。 ","version":"Next","tagName":"h3"},{"title":"下一步​","type":1,"pageTitle":"使用 Docker 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/docker#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"翻译对照表","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/vocabulary","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"C​","type":1,"pageTitle":"翻译对照表","url":"/docs/elasticsearch-cn/vocabulary#c","content":"单词\t中文cluster\t集群 ","version":"Next","tagName":"h2"},{"title":"I​","type":1,"pageTitle":"翻译对照表","url":"/docs/elasticsearch-cn/vocabulary#i","content":"单词\t中文index\t索引 ingest\t摄取 ","version":"Next","tagName":"h2"},{"title":"R​","type":1,"pageTitle":"翻译对照表","url":"/docs/elasticsearch-cn/vocabulary#r","content":"单词\t中文reindex\t重索引，重新索引 ","version":"Next","tagName":"h2"},{"title":"S​","type":1,"pageTitle":"翻译对照表","url":"/docs/elasticsearch-cn/vocabulary#s","content":"单词\t中文scroll\t滚动 shard\t分片 slice\t切片，切分 slicing\t切片 ","version":"Next","tagName":"h2"},{"title":"在 Windows 上用 .zip 安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"下载安装 .zip 包​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#下载安装-zip-包","content":"Elasticsearch v7.11.1 的 .zip 存档可以从这里下载：  用你最喜欢的解压工具解压它。这会创建一个名为 elasticsearch-7.11.1 的文件夹，我们将其作为 %ES_HOME%。在终端窗口，cd 到 %ES_HOME% 目录，如： cd c:\\elasticsearch-7.11.1  ","version":"Next","tagName":"h2"},{"title":"启用系统索引自动创建 [X-Pack]​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#启用系统索引自动创建-x-pack","content":"一些商业特性会在 Elasticsearch 中自动创建索引。默认情况下， Elasticsearch 配置为允许自动创建索引而不需要额外的步骤。然而，如果你在 Elasticsearch 中禁用了自动索引创建，则必须在 elasticsearch.yml 中配置 action.auto_create_index 以允许商业特性创建以下索引： action.auto_create_index: .monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*  警告 如果你在使用 Logstash 或 Beats，那么你很可能需要在你的 action.auto_create_index 设置中使用额外的索引名字，具体的值取决于你的本地配置。如果你不确定你环境的正确值，可以考虑设置这个值为*以允许自动创建所有索引。 ","version":"Next","tagName":"h2"},{"title":"从命令行运行 Elasticsearch​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#从命令行运行-elasticsearch","content":"Elasticsearch 可以如以下从命令行启动： .\\bin\\elasticsearch.bat  如果你对 Elasticsearch 密码库进行了密码保护，会提示输入密码库密码。查看安全设置获取更多详情。 默认情况下，Elasticsearch 在前台运行，从标准输出（stdout）打印日志，且可以通过按 Ctrl-C 中止。 ","version":"Next","tagName":"h2"},{"title":"在命令行配置 Elasticsearch​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#在命令行配置-elasticsearch","content":"Elasticsearch 默认从 $ES_HOME/configuring_elasticsearch/elasticsearch.yml 加载配置。配置文件的格式在配置 Elasticsearch中解释。 在配置文件中可以指定的设置，也能在命令行中指定，如下使用 -E 语法： .\\bin\\elasticsearch.bat -Ecluster.name=my_cluster -Enode.name=node_1  提示 包含空格的值必须使用引号括起来。如 -Epath.logs=&quot;C:\\My Logs\\logs&quot;。 提示 通常，任意集群范围设置（如 cluster.name）应该添加到 elasticsearch.yml 配置文件中，而任何节点特定设置，如 node.name，应该在命令行中指定。 ","version":"Next","tagName":"h2"},{"title":"检查 Elasticsearch 是否正在运行​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#检查-elasticsearch-是否正在运行","content":"你可以通过向 localhost 的 9200 端口发送 HTTP 请求来测试 Elasticsearch 节点是否正在运行： GET /  这会给你这样的响应： { &quot;name&quot; : &quot;Cp8oag6&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;AT69_T_DTp-1qgIJlatQqA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.11.1&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;f27399d&quot;, &quot;build_date&quot; : &quot;2016-03-30T09:51:41.449Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.7.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;1.2.3&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;1.2.3&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; }  ","version":"Next","tagName":"h2"},{"title":"在 Windows 上安装 Elasticsearch 作为服务​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#在-windows-上安装-elasticsearch-作为服务","content":"Elasticsearch 可以作为一项服务安装在后台运行，也可以无需用户交互的在启动时自动启动。这可以通过在 bin\\ 目录中的 elasticsearch-service.bat 脚本来在命令行允许安装、移除、管理或者配置服务，且能启动和停止服务。 c:\\elasticsearch-7.11.1\\bin&gt;elasticsearch-service.bat Usage: elasticsearch-service.bat install|remove|start|stop|manager [SERVICE_ID]  这脚本需要一个参数（要执行的命令），后面跟着一个可选参数表示服务的id（安装多个 Elasticsearch 服务时很有用）。 命令有： \tinstall\t安装 Elasticsearch 作为服务 remove\t移除安装的 Elasticsearch 服务（如果已启动，则停止服务） start\t启动 Elasticsearch 服务（如果已安装） stop\t停止 Elasticsearch 服务（如果已启动） manager\t启动图形化界面（GUI）管理已安装的服务 在安装时，将提供服务的名字和 JAVA_HOME 的值： c:\\elasticsearch-7.11.1\\bin&gt;elasticsearch-service.bat install Installing service : &quot;elasticsearch-service-x64&quot; Using JAVA_HOME (64-bit): &quot;c:\\jvm\\jdk1.8&quot; The service 'elasticsearch-service-x64' has been installed.  提示 虽然 JRE 可以用于 Elasticsearch 服务，由于它使用客户端 VM （而不是服务器 JVM——它为长时间运行的应用程序提供更好的性能），不鼓励使用，并将发出警告。 提示 系统环境变量 JAVA_HOME 应该设置为你想让服务使用的 JDK 的安装路径。如果你升级 JDK，你不必重装服务，但你必须设置系统环境变量 JAVA_HOME 为最新的 JDK 安装路径。然而，不支持跨 JVM 类型（如，JRE 对 SE）的升级，必须重装服务。 ","version":"Next","tagName":"h2"},{"title":"自定义服务配置​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#自定义服务配置","content":"可以在安装之前通过设置以下环境变量（使用命令行中的设置（set）命令，或通过系统属性-&gt;环境变量 GUI）来配置 Elasticsearch 服务。 \tSERVICE_ID\t服务唯一标识。在同一台机器上安装多个实例时有用。默认为 elasticsearch-service-x64。 SERVICE_USERNAME\t运行服务的用户，默认为本地系统账户。 SERVICE_PASSWORD\t在 SERVICE_USERNAME 中指定的用户的密码。 SERVICE_DISPLAY_NAME\t服务名字。默认为 Elasticsearch &lt;version&gt; %SERVICE_ID%。 SERVICE_DESCRIPTION\t服务描述。默认为 Elasticsearch &lt;version&gt; Windows Service - https://elastic.co。 JAVA_HOME\t运行服务所需的 JVM 安装目录。 SERVICE_LOG_DIR\t服务的日志目录，默认为 %ES_HOME%\\logs。注意这不控制 Elasticsearch 日志路径，这个路径通过在配置文件 elasticsearch.yml 中的设置 path.logs 或在命令行中设置。 ES_PATH_CONF\t配置文件目录（需要包含 elasticsearch.yml、jvm.options 和 log4j2.properties 文件），默认为 %ES_HOME%\\config。 ES_JAVA_OPTS\t你想应用的任何其他 JVM 系统属性。 ES_START_TYPE\t服务启动模式。可以为 auto 或 manual（默认）。 ES_STOP_TIMEOUT\tprocrun 等待服务优雅退出的超时（秒）。默认为 0。 提示 作为它的核心，elasticsearch-service.bat 依赖于 Apache Commons Daemon 项目来安装服务。在服务安装之前设置的环境变量被复制，并在服务生命周期中使用。这意味着除非重装服务，否则在安装后对他们的变更都不会被获取。 提示 默认情况，Elasticsearch 依据节点的角色和总内存，自动调整 JVM 堆大小。对于大多数生产环境，我们推荐默认调整。如果需要，你可以手动设置堆大小来覆盖默认调整。 提示 当第一次在 Windows 上安装 Elasticsearch 作为服务或者从命令行运行 Elasticsearch 时，你可以按[JVM 堆大小设置](/set_up_elasticsearch/configuring_elasticsearch/advanced#JVM 堆大小设置)手工设置堆大小。为了调整已安装服务的堆大小，使用服务管理器：bin\\elasticsearch-service.bat manager。 提示 该服务会自动配置一个私有临时目录供 Elasticsearch 运行时使用。该私有临时目录配置为用户运行安装的私有临时目录的子目录。如果这个服务要在不同的用户下运行，你可以在执行服务安装之前，通过设置环境变量 ES_TMPDIR 配置这个临时目录的优先位置。 ","version":"Next","tagName":"h2"},{"title":"使用管理 GUI​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#使用管理-gui","content":"也可以在安装后使用管理界面（elasticsearch-service-mgr.exe）来配置服务，它提供了对已安装服务的深入了解，包括其状态、启动类型、JVM、启动和停止设置等。从命令行调用 elasticsearch-service.bat 将会打开管理器窗口：  通过管理界面所做的大多数修改（如 JVM 设置），都需要重启服务才能生效。 ","version":"Next","tagName":"h3"},{"title":".zip 存档的目录结构​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#zip-存档的目录结构","content":".zip 包是完全独立的。默认情况下，所有文件和目录都包含在 $ES_HOME——解压存档时创建的目录。 这样很方便，因为你不必创建任意目录去启用 Elasticsearch，且卸载 Elasticsearch 就像移除 $ES_HOME 目录一样简单。但是，建议修改默认的配置目录（config）和数据目录（data）以便以后不用删除重要数据。 类型\t描述\t默认位置\t设置home\tElasticsearch 主目录或 %ES_HOME%\t解压存档创建的目录 bin\t二进制脚本，包括启动节点的 elasticsearch 和安装插件的 elasticsearch-plugin\t%ES_HOME%\\bin conf\t配置文件，包括 elasticsearch.yml\t%ES_HOME%\\config\tES_PATH_CONF data\t分配在节点上的每个索引和分片的数据文件位置。可以有多个位置。\t%ES_HOME%\\data\tpath.data logs\t日志文件位置\t%ES_HOME%\\logs\tpath.logs plugins\t插件文件位置。每个插件会包含在一个子目录中。\t%ES_HOME%\\plugins repo\t共享文件系统仓库位置。可以有多个位置。文件系统仓库可以放在此处指定的任何目录的任何子目录中。\t未配置\tpath.repo ","version":"Next","tagName":"h2"},{"title":"下一步​","type":1,"pageTitle":"在 Windows 上用 .zip 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/windows#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"},{"title":"使用 RPM 安装 Elasticsearch","type":0,"sectionRef":"#","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm","content":"","keywords":"Elastic Elasticsearch Elasticsearch api ElasticStack ELK Document docs 文档 中文文档 入门","version":"Next"},{"title":"导入 Elasticsearch PGP 密钥​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#导入-elasticsearch-pgp-密钥","content":"我们使用带指纹的 Elasticsearch 签名密钥（PGP 密钥 D88E42B4，存在https://pgp.mit.edu上）签名所有的包： 4609 5ACC 8548 582C 1A26 99A9 D27D 666C D88E 42B4 下载和安装公共签名密钥： wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -  ","version":"Next","tagName":"h2"},{"title":"从 RPM 仓库安装​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#从-rpm-仓库安装","content":"为基于 RedHat 的发行版，在目录 /etc/yum.repos.d/ 中创建一个命名为 elasticsearch.repo 的文件，或者为基于 OpenSuSE 的发行版在目录 /etc/zypp/repos.d/ 中创建文件，内容包括： [elasticsearch] name=Elasticsearch repository for 7.x packages baseurl=https://artifacts.elastic.co/packages/7.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=0 autorefresh=1 type=rpm-md  仓库已准备就绪。现在可以使用以下的任一命令安装 Elasticsearch： sudo yum install --enablerepo=elasticsearch elasticsearch sudo dnf install --enablerepo=elasticsearch elasticsearch sudo zypper modifyrepo --enable elasticsearch &amp;&amp; \\ sudo zypper install elasticsearch; \\ sudo zypper modifyrepo --disable elasticsearch  sudo yum install 在 CentOS 和老的基于 Red Hat 的发行版上使用 yum。sudo dnf install 在 Fedora 和其他新的 Red Hat 的发行版上使用 dnf。sudo zypper modifyrepo 在基于 OpenSUSE 的发行版本上使用 zypper。 提示 配置的仓库默认是禁用的。这排除了升级系统其他部分时意外升级 Elasticsearch 的可能性。每个安装或者升级命令必须显示启用仓库，如上面的示例命令所示。 ","version":"Next","tagName":"h2"},{"title":"手工下载和安装 RPM​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#手工下载和安装-rpm","content":"Elasticsearch v7.11.2 的 RPM，可以按以下命令从网站下载和安装： wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.2-x86_64.rpm wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.11.2-x86_64.rpm.sha512 shasum -a 512 -c elasticsearch-7.11.2-x86_64.rpm.sha512 sudo rpm --install elasticsearch-7.11.2-x86_64.rpm  shasum -a 512 -c 比较下载的 RPM SHA 值和公开的校验值。正常应该输出 elasticsearch-{version}-x86_64.rpm: OK。 ","version":"Next","tagName":"h2"},{"title":"启用系统索引自动创建 [X-Pack]​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#启用系统索引自动创建-x-pack","content":"一些商业特性会在 Elasticsearch 中自动创建索引。默认情况下， Elasticsearch 配置为允许自动创建索引而不需要额外的步骤。然而，如果你在 Elasticsearch 中禁用了自动索引创建，则必须在 elasticsearch.yml 中配置 action.auto_create_index 以允许商业特性创建以下索引： action.auto_create_index: .monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*  警告 如果你在使用 Logstash 或 Beats，那么你很可能需要在你的 action.auto_create_index 设置中使用额外的索引名字，具体的值取决于你的本地配置。如果你不确定你环境的正确值，可以考虑设置这个值为*以允许自动创建所有索引。 ","version":"Next","tagName":"h2"},{"title":"SysV init 对 systemd​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#sysv-init-对-systemd","content":"Elasticsearch 在安装后不会自动启动。如何启动和停止 Elasticsearch，取决于你的系统用的 SysV init 还是 systemd（更新的发行版用的）。你可以通过以下命令来判断用的哪个： ps -p 1  ","version":"Next","tagName":"h2"},{"title":"使用 SysV init 运行 Elasticsearch​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#使用-sysv-init-运行-elasticsearch","content":"使用 update-rc.d 命令配置当系统启动时自动启动 Elasticsearch： sudo update-rc.d elasticsearch defaults 95 10  Elasticsearch 可以使用 service 命令来启动和停止： sudo -i service elasticsearch start sudo -i service elasticsearch stop  如果 Elasticsearch 由于任何原因启动失败，它会输出失败原因到标准输出（STDOUT）。日志文件可以在 /var/log/elasticsearch/ 中被找到。 ","version":"Next","tagName":"h2"},{"title":"使用 systemd 运行 Elasticsearch​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#使用-systemd-运行-elasticsearch","content":"为了配置 Elasticsearch 在系统启动时自动启动，运行以下命令： sudo /bin/systemctl daemon-reload sudo /bin/systemctl enable elasticsearch.service  Elasticsearch 可以按以下方式启动和停止： sudo systemctl start elasticsearch.service sudo systemctl stop elasticsearch.service  这些命令不提供 Elasticsearch 运行成功与否的反馈。相反，信息写在位于 /var/log/elasticsearch/ 中的日志文件。 如果你的 Elasticsearch 密码库受密码保护，你需要使用本地文件和 systemd 环境变量向密码库提供密码。本地文件存在时，应该受到保护，一旦 Elasticsearch 启动并运行，就可以安全删除此文件。 echo &quot;keystore_password&quot; &gt; /path/to/my_pwd_file.tmp chmod 600 /path/to/my_pwd_file.tmp sudo systemctl set-environment ES_KEYSTORE_PASSPHRASE_FILE=/path/to/my_pwd_file.tmp sudo systemctl start elasticsearch.service  默认情况下，Elasticsearch 服务不会在 systemd 日志中记录信息。要启用 journalctl 日志，必须从文件 elasticsearch.service 中的 ExecStart 命令行移除 --quiet 选项。 当 systemd 日志启用时，使用 journalctl 命令日志信息可用。 要跟踪日志： sudo journalctl -f  列出 Elasticsearch 服务的日志条目： sudo journalctl --unit elasticsearch  要列出从给定时间开始的 Elasticsearch 服务的日志条目，请执行以下操作： sudo journalctl --unit elasticsearch --since &quot;2016-10-30 18:17:16&quot;  检查 man journalctl 或者 https://www.freedesktop.org/software/systemd/man/journalctl.html 获取更多的命令行选项。 ","version":"Next","tagName":"h2"},{"title":"检查 Elasticsearch 是否正在运行​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#检查-elasticsearch-是否正在运行","content":"你可以通过向 localhost 的 9200 端口发送 HTTP 请求来测试 Elasticsearch 节点是否正在运行： GET /  这会给你这样的响应： { &quot;name&quot; : &quot;Cp8oag6&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;AT69_T_DTp-1qgIJlatQqA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;7.11.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;f27399d&quot;, &quot;build_date&quot; : &quot;2016-03-30T09:51:41.449Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.7.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;1.2.3&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;1.2.3&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; }  ","version":"Next","tagName":"h2"},{"title":"配置 Elasticsearch​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#配置-elasticsearch","content":"/etc/elasticsearch 目录包含 Elasticsearch 默认运行时配置。该目录和所包含的所有文件所有权在包安装时设置为 root:elasticsearch。 setgid 标志对目录 /etc/elasticsearch 应用组权限，以确保 Elasticsearch 能读取任何包含的文件和子目录。所有文件和子目录继承 root:elasticsearch 所有权。从该目录或者任何子目录运行命令，如 elasticsearch-keystore 工具，需要 root:elasticsearch 权限。 Elasticsearch 默认从 /etc/elasticsearch/elasticsearch.yml 文件加载它的配置。在配置 Elasticsearch 中解释了配置文件的格式。 RPM 也有一个系统配置文件（/etc/sysconfig/elasticsearch），它允许你设置以下的变量： \tJAVA_HOME\t设置使用的自定义 Java 路径 MAX_OPEN_FILES\t打开文件的最大值，默认为 65535 MAX_LOCKED_MEMORY\t最大锁定内存值。如果你在 elasticsearch.yml 中使用 bootstrap.memory_lock 选项，设置为 unlimited。 MAX_MAP_COUNT\t进程可能具有的最大内存映射区域数。如果你使用 mmapfs 作为索引存储类型，请确保将其设置一个高值。有关更多的信息，请查看关于 max_map_count 的 linux 内核文档。在 Elasticsearch 启动前，通过 sysctl 设置，默认为 262144。 ES_PATH_CONF\t配置文件目录（需要包含 elasticsearch.yml、jvm.options 和 log4j2.properties 文件），默认为 /etc/elasticsearch。 ES_JAVA_OPTS\t你想应用的任何其他 JVM 系统属性。 RESTART_ON_UPGRADE\t在包升级时配置重启，默认为 false。这意味着你必须在手工安装包后重启你的 Elasticseach 实例。这样做的原因是为了确保集群的升级不会导致持续的分片重分配，进而导致的高网络流量和降低了集群的响应时间。 提示 使用 systemd 的发行版本要求需要通过 systemd 配置系统资源限制，而不是通过 /etc/sysconfig/elasticsearch 文件。更多信息，请参阅 Systemd 配置。 ","version":"Next","tagName":"h2"},{"title":"RPM 目录结构​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#rpm-目录结构","content":"RPM 包将配置文件、日志和数据目录放在基于 RPM 系统的适当位置： 类型\t描述\t默认位置\t设置home\tElasticsearch 主目录或 $ES_HOME\t/usr/share/elasticsearch bin\t二进制脚本，包括启动节点的 elasticsearch 和安装插件的 elasticsearch-plugin\t/usr/share/elasticsearch/bin conf\t配置文件，包括 elasticsearch.yml\t/etc/elasticsearch\tES_PATH_CONF conf\t环境变量，包括堆大小，文件描述符。\t/etc/default/elasticsearch data\t分配在节点上的每个索引和分片的数据文件位置。可以有多个位置。\t/var/lib/elasticsearch\tpath.data jdk\t用于运行 Elasticsearch 的捆绑 Java 开发工具包。可以通过在 /etc/sysconfig/elasticsearch 中覆盖 JAVA_HOME环境变量。\t/usr/share/elasticsearch/jdk logs\t日志文件位置\t/var/log/elasticsearch\tpath.logs plugins\t插件文件位置。每个插件会包含在一个子目录中。\t/usr/share/elasticsearch/plugins repo\t共享文件系统仓库位置。可以有多个位置。文件系统仓库可以放在此处指定的任何目录的任何子目录中。\t未配置\tpath.repo ","version":"Next","tagName":"h2"},{"title":"下一步​","type":1,"pageTitle":"使用 RPM 安装 Elasticsearch","url":"/docs/elasticsearch-cn/set_up_elasticsearch/installing_elasticsearch/rpm#下一步","content":"你现在有一个测试 Elasticsearch 环境部署好。在你使用 Elasticsearch 正式开始开发或者生产之前，你必须做一些额外的设置： 学习如何配置 Elasticsearch。配置重要的 Elasticsearch 设置。配置重要的系统设置。 原文链接 ","version":"Next","tagName":"h2"}],"options":{"languages":["en","zh"],"id":"default"}}